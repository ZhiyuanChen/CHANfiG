{"config":{"lang":["ja"],"separator":"[\\s\\u200b\\-]","pipeline":["stemmer"]},"docs":[{"location":"","title":"CHANfiG","text":""},{"location":"#introduction","title":"Introduction","text":"<p>CHANfiG aims to make your configuration easier.</p> <p>There are tons of configurable parameters in training a Machine Learning model. To configure all these parameters, researchers usually need to write gigantic config files, sometimes even thousands of lines. Most of the configs are just replicates of the default arguments of certain functions, resulting in many unnecessary declarations. It is also very hard to alter the configurations. One needs to navigate and open the right configuration file, make changes, save and exit. These had wasted an uncountable1 amount of precious time and are no doubt a crime. Using <code>argparse</code> could relieve the burdens to some extent. However, it takes a lot of work to make it compatible with existing config files, and its lack of nesting limits its potential.</p> <p>CHANfiG would like to make a change.</p> <p>You just type the alternations in the command line, and leave everything else to CHANfiG.</p> <p>CHANfiG is highly inspired by YACS. Different from the paradigm of YACS( <code>your code + a YACS config for experiment E (+ external dependencies + hardware + other nuisance terms ...) = reproducible experiment E</code>), The paradigm of CHANfiG is:</p> <p><code>your code + command line arguments (+ optional CHANfiG config + external dependencies + hardware + other nuisance terms ...) = reproducible experiment E (+ optional CHANfiG config for experiment E)</code></p>"},{"location":"#components","title":"Components","text":"<p>A Config is basically a nested dict structure.</p> <p>However, the default Python dict is hard to manipulate.</p> <p>The only way to access a dict member is through <code>dict['name']</code>, which is obviously extremely complex. Even worse, if the dict is nested like a config, member access could be something like <code>dict['parent']['children']['name']</code>.</p> <p>Enough is enough, it is time to make a change.</p> <p>We need attribute-style access, and we need it now. <code>dict.name</code> and <code>dict.parent.children.name</code> are all you need.</p> <p>Although there have been some other works that achieve a similar functionality of attribute-style access to dict members. Their Config objects either use a separate dict to store information from attribute-style access (EasyDict), which may lead to inconsistency between attribute-style access and dict-style access; or re-use the existing <code>__dict__</code> and redirect dict-style access (ml_collections), which may result in confliction between attributes and members of Config.</p> <p>To overcome the aforementioned limitations, we inherit the Python built-in <code>dict</code> to create <code>FlatDict</code>, <code>DefaultDict</code>, <code>NestedDict</code>, <code>Config</code>, and <code>Registry</code> objects. We also introduce <code>Variable</code> to allow sharing a value across multiple places, and <code>ConfigParser</code> to parse command line arguments.</p>"},{"location":"#flatdict","title":"FlatDict","text":"<p><code>FlatDict</code> improves the default <code>dict</code> in 3 aspects.</p>"},{"location":"#dict-operations","title":"Dict Operations","text":"<p><code>FlatDict</code> supports variable interpolation. Set the value of a member to a string with <code>${}</code> and another member name inside, and call <code>interpolate</code> method. The value will be automatically replaced with the value of another member.</p> <p><code>FlatDict</code> incorporates a <code>merge</code> method which allows you to merge a <code>Mapping</code>, an <code>Iterable</code>, or a path to the <code>FlatDict</code> object. Different to <code>update</code> method, <code>merge</code> assign value instead of replace values, which makes it work better with <code>DefaultDict</code> object.</p> <p>Besides, <code>FlatDict</code> comes with <code>difference</code> and <code>intersect</code>, which makes it very easy to compare a <code>FlatDict</code> with other <code>Mapping</code>, <code>Iterable</code>, or a path.</p>"},{"location":"#ml-operations","title":"ML Operations","text":"<p><code>FlatDict</code> supports the <code>to</code> method similar to PyTorch Tensors. You can simply convert all member values of <code>FlatDict</code> to a certain type or pass to a device in the same way.</p> <p><code>FlatDict</code> also integrates <code>cpu</code>, <code>gpu</code> (<code>cuda</code>), and <code>tpu</code> (<code>xla</code>) methods for easier access.</p>"},{"location":"#io-operations","title":"IO Operations","text":"<p><code>FlatDict</code> provides <code>json</code>, <code>jsons</code>, <code>yaml</code> and <code>yamls</code> methods to dump <code>FlatDict</code> object to a file or string. It also provides <code>from_json</code>, <code>from_jsons</code>, <code>from_yaml</code> and <code>from_yamls</code> methods to build a <code>FlatDict</code> object from a string or file.</p> <p><code>FlatDict</code> also includes <code>dump</code> and <code>load</code> methods which determines the type by its extension and dump/load <code>FlatDict</code> object to/from a file.</p>"},{"location":"#defaultdict","title":"DefaultDict","text":"<p>To facilities the needs of default values, we incorporate <code>DefaultDict</code> which accepts <code>default_factory</code> and works just like a <code>collections.defaultdict</code>.</p>"},{"location":"#nesteddict","title":"NestedDict","text":"<p>Since most Configs are in a nested structure, we further propose a <code>NestedDict</code>.</p> <p>Based on <code>DefaultDict</code>, <code>NestedDict</code> provides <code>all_keys</code>, <code>all_values</code>, and <code>all_items</code> methods to allow iterating over the whole nested structure at once.</p> <p><code>NestedDict</code> also comes with <code>apply</code> method, which made it easier to manipulate the nested structure.</p>"},{"location":"#config","title":"Config","text":"<p><code>Config</code> extends the functionality by supporting <code>freeze</code> and <code>defrost</code> the dict, and by adding a built-in <code>ConfigParser</code> to pare command line arguments.</p> <p>Note that <code>Config</code> also has <code>default_factory=Config()</code> by default for convenience.</p>"},{"location":"#registry","title":"Registry","text":"<p><code>Registry</code> extends the <code>NestedDict</code> and supports <code>register</code>, <code>lookup</code>, and <code>build</code> to help you register constructors and build objects from a <code>Config</code>.</p>"},{"location":"#variable","title":"Variable","text":"<p>Have one value for multiple names at multiple places? We got you covered.</p> <p>Just wrap the value with <code>Variable</code>, and one alteration will be reflected everywhere.</p> <p><code>Variable</code> also supports <code>type</code>, <code>choices</code>, <code>validator</code>, and <code>required</code> to ensure the correctness of the value.</p> <p>To make it even easier, <code>Variable</code> also supports <code>help</code> to provide a description when using <code>ConfigParser</code>.</p>"},{"location":"#configparser","title":"ConfigParser","text":"<p><code>ConfigParser</code> extends <code>ArgumentParser</code> and provides <code>parse</code> and <code>parse_config</code> to parse command line arguments.</p>"},{"location":"#usage","title":"Usage","text":"<p>CHANfiG has great backward compatibility with previous configs.</p> <p>No matter if your old config is json or yaml, you could directly read from them.</p> <p>And if you are using yacs, just replace <code>CfgNode</code> with <code>Config</code> and enjoy all the additional benefits that CHANfiG provides.</p> <p>Moreover, if you find name in the config is too long for command-line, you could simply call <code>self.add_argument</code> with proper <code>dest</code> to use a shorter name in command-line, as you do with <code>argparse</code>.</p> Python<pre><code>from chanfig import Config, Variable\nclass Model:\ndef __init__(self, encoder, dropout=0.1, activation='ReLU'):\nself.encoder = Encoder(**encoder)\nself.dropout = Dropout(dropout)\nself.activation = getattr(Activation, activation)\ndef main(config):\nmodel = Model(**config.model)\noptimizer = Optimizer(**config.optimizer)\nscheduler = Scheduler(**config.scheduler)\ndataset = Dataset(**config.dataset)\ndataloader = Dataloader(**config.dataloader)\nclass TestConfig(Config):\ndef __init__(self):\nsuper().__init__()\ndropout = Variable(0.1)\nself.name = \"CHANfiG\"\nself.seed = 1013\nself.data.batch_size = 64\nself.model.encoder.num_layers = 6\nself.model.decoder.num_layers = 6\nself.model.dropout = dropout\nself.model.encoder.dropout = dropout\nself.model.decoder.dropout = dropout\nself.activation = \"GELU\"\nself.optim.lr = 1e-3\nself.add_argument(\"--batch_size\", dest=\"data.batch_size\")\nself.add_argument(\"--lr\", dest=\"optim.lr\")\ndef post(self):\nself.id = f\"{self.name}_{self.seed}\"\nif __name__ == '__main__':\n# config = Config.load('config.yaml')  # in case you want to read from a yaml\n# config = Config.load('config.json')  # in case you want to read from a json\n# existing_configs = {'data.batch_size': 64, 'model.encoder.num_layers': 8}\n# config = Config(**existing_configs)  # in case you have some config in dict to load\nconfig = TestConfig()\nconfig = config.parse()\n# config.merge('dataset.yaml')  # in case you want to merge a yaml\n# config.merge('dataset.json')  # in case you want to merge a json\n# note that the value of merge will override current values\nconfig.model.decoder.num_layers = 8\nconfig.freeze()\nprint(config)\n# main(config)\n# config.yaml('config.yaml')  # in case you want to save a yaml\n# config.json('config.json')  # in case you want to save a json\n</code></pre> <p>All you need to do is just run a line:</p> Bash<pre><code>python main.py --model.encoder.num_layers 8 --model.dropout=0.2 --lr 5e-3\n</code></pre> <p>You could also load a default configure file and make changes based on it:</p> <p>Note, you must specify <code>config.parse(default_config='config')</code> to correctly load the default config.</p> Bash<pre><code>python main.py --config meow.yaml --model.encoder.num_layers 8 --model.dropout=0.2 --lr 5e-3\n</code></pre> <p>If you have made it dump current configurations, this should be in the written file:</p> YAML<pre><code>activation: GELU\ndata:\nbatch_size: 64\nid: CHANfiG_1013\nmodel:\ndecoder:\ndropout: 0.1\nnum_layers: 6\ndropout: 0.1\nencoder:\ndropout: 0.1\nnum_layers: 6\nname: CHANfiG\noptim:\nlr: 0.005\nseed: 1013\n</code></pre> JSON<pre><code>{\n\"name\": \"CHANfiG\",\n\"seed\": 1013,\n\"data\": {\n\"batch_size\": 64\n},\n\"model\": {\n\"encoder\": {\n\"num_layers\": 6,\n\"dropout\": 0.1\n},\n\"decoder\": {\n\"num_layers\": 6,\n\"dropout\": 0.1\n},\n\"dropout\": 0.1\n},\n\"activation\": \"GELU\",\n\"optim\": {\n\"lr\": 0.005\n},\n\"id\": \"CHANfiG_1013\"\n}\n</code></pre> <p>Define the default arguments in function, put alterations in CLI, and leave the rest to CHANfiG.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install the most recent stable version on pypi:</p> Bash<pre><code>pip install chanfig\n</code></pre> <p>Install the latest version from source:</p> Bash<pre><code>pip install git+https://github.com/ZhiyuanChen/CHANfiG\n</code></pre> <p>It works the way it should have worked.</p>"},{"location":"#license","title":"License","text":"<p>CHANfiG is multi-licensed under the following licenses:</p> <ul> <li>Unlicense</li> <li>GNU GPL 2.0 (or any later version)</li> <li>MIT</li> <li>Apache 2.0</li> <li>BSD 2-Clause</li> <li>BSD 3-Clause</li> <li>BSD 4-Clause</li> </ul> <p>You can choose any (one or more) of these license if you use this work.</p> <p><code>SPDX-License-Identifier: Unlicense OR GPL-2.0-or-later OR MIT OR Apache-2.0 OR BSD-2-Clause OR BSD-3-Clause OR BSD-4-Clause</code></p> <ol> <li> <p>fun fact: time is always uncountable.\u00a0\u21a9</p> </li> </ol>"},{"location":"config/","title":"Config","text":""},{"location":"config/#chanfig.config.Config","title":"<code>Config</code>","text":"<p>             Bases: <code>NestedDict[_K, _V]</code></p> <p><code>Config</code> is an extension of <code>NestedDict</code>.</p> <p>The differences between <code>Config</code> and <code>NestedDict</code> lies in 3 aspects:</p> <ol> <li><code>Config</code> has <code>default_factory</code> set to <code>Config</code> and <code>convert_mapping</code> set to <code>True</code> by default.</li> <li><code>Config</code> has a <code>frozen</code> attribute, which can be toggled with <code>freeze</code>(<code>lock</code>) &amp; <code>defrost</code>(<code>unlock</code>)     or temporarily changed with <code>locked</code> &amp; <code>unlocked</code>.</li> <li><code>Config</code> has a <code>ConfigParser</code> built-in, and supports <code>add_argument</code> and <code>parse</code>.</li> </ol> <p>Config also features a <code>post</code> method and a <code>boot</code> method to support lazy-initilisation. This is useful when you want to perform some post-processing on the config. For example, some values may be a combination of other values, and you may define them in <code>post</code>.</p> <p><code>boot</code> is introduced to call all <code>post</code> methods in the nested structure of <code>Config</code> object. By default, <code>boot</code> will be called to after <code>Config</code> is parsed.</p> <p>You could also manually call <code>boot</code> if you you don\u2019t parse command-line arguments.</p> Notes <p>Since <code>Config</code> has <code>default_factory</code> set to <code>Config</code>, accessing anything that does not exist will create a new empty Config sub-attribute.</p> <p>A frozen <code>Config</code> does not have this behavior and will raises <code>KeyError</code> when accessing anything that does not exist.</p> <p>It is recommended to call <code>config.freeze()</code> or <code>config.to(NestedDict)</code> to avoid this behavior.</p> <p>Attributes:</p> Name Type Description <code>parser</code> <code>ConfigParser</code> <p>Parser for command-line arguments.</p> <code>frozen</code> <code>bool</code> <p>If <code>True</code>, the config is frozen and cannot be altered.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; c = Config(**{\"f.n\": \"chang\"})\n&gt;&gt;&gt; c.i.d = 1013\n&gt;&gt;&gt; c.i.d\n1013\n&gt;&gt;&gt; c.d.i\nConfig(&lt;class 'chanfig.config.Config'&gt;, )\n&gt;&gt;&gt; c.freeze().dict()\n{'f': {'n': 'chang'}, 'i': {'d': 1013}, 'd': {'i': {}}}\n&gt;&gt;&gt; c.d.i = 1013\nTraceback (most recent call last):\nValueError: Attempting to alter a frozen config. Run config.defrost() to defrost first.\n&gt;&gt;&gt; c.d.e\nTraceback (most recent call last):\nAttributeError: 'Config' object has no attribute 'e'\n&gt;&gt;&gt; with c.unlocked():\n...     del c.d\n&gt;&gt;&gt; c.dict()\n{'f': {'n': 'chang'}, 'i': {'d': 1013}}\n</code></pre> Source code in <code>chanfig/config.py</code> Python<pre><code>class Config(NestedDict[_K, _V]):\nr\"\"\"\n    `Config` is an extension of `NestedDict`.\n    The differences between `Config` and `NestedDict` lies in 3 aspects:\n    1. `Config` has `default_factory` set to `Config` and `convert_mapping` set to `True` by default.\n    2. `Config` has a `frozen` attribute, which can be toggled with `freeze`(`lock`) &amp; `defrost`(`unlock`)\n        or temporarily changed with `locked` &amp; `unlocked`.\n    3. `Config` has a `ConfigParser` built-in, and supports `add_argument` and `parse`.\n    Config also features a `post` method and a `boot` method to support lazy-initilisation.\n    This is useful when you want to perform some post-processing on the config.\n    For example, some values may be a combination of other values, and you may define them in `post`.\n    `boot` is introduced to call all `post` methods in the nested structure of `Config` object.\n    By default, `boot` will be called to after `Config` is parsed.\n    You could also manually call `boot` if you you don't parse command-line arguments.\n    Notes:\n        Since `Config` has `default_factory` set to `Config`,\n        accessing anything that does not exist will create a new empty Config sub-attribute.\n        A **frozen** `Config` does not have this behavior and\n        will raises `KeyError` when accessing anything that does not exist.\n        It is recommended to call `config.freeze()` or `config.to(NestedDict)` to avoid this behavior.\n    Attributes:\n        parser (ConfigParser): Parser for command-line arguments.\n        frozen (bool): If `True`, the config is frozen and cannot be altered.\n    Examples:\n        &gt;&gt;&gt; c = Config(**{\"f.n\": \"chang\"})\n        &gt;&gt;&gt; c.i.d = 1013\n        &gt;&gt;&gt; c.i.d\n        1013\n        &gt;&gt;&gt; c.d.i\n        Config(&lt;class 'chanfig.config.Config'&gt;, )\n        &gt;&gt;&gt; c.freeze().dict()\n        {'f': {'n': 'chang'}, 'i': {'d': 1013}, 'd': {'i': {}}}\n        &gt;&gt;&gt; c.d.i = 1013\n        Traceback (most recent call last):\n        ValueError: Attempting to alter a frozen config. Run config.defrost() to defrost first.\n        &gt;&gt;&gt; c.d.e\n        Traceback (most recent call last):\n        AttributeError: 'Config' object has no attribute 'e'\n        &gt;&gt;&gt; with c.unlocked():\n        ...     del c.d\n        &gt;&gt;&gt; c.dict()\n        {'f': {'n': 'chang'}, 'i': {'d': 1013}}\n    \"\"\"\nparser: ConfigParser\nfrozen: bool = False\ndef __init__(self, *args: Any, default_factory: Callable | None = None, **kwargs: Any):\nif default_factory is None:\ndefault_factory = Config\nsuper().__init__(*args, default_factory=default_factory, **kwargs)\ndef post(self) -&gt; Config:\nr\"\"\"\n        Post process of `Config`.\n        Some `Config` may need to do some post process after `Config` is initialised.\n        `post` is provided for this lazy-initialisation purpose.\n        By default, `post` does nothing and returns `self`.\n        Note that you should always call `boot` to apply `post` rather than calling `post` directly,\n        as `boot` recursively call `post` on sub-configs.\n        See Also: [`boot`][chanfig.Config.boot]\n        Returns:\n            self:\n        Examples:\n            &gt;&gt;&gt; class PostConfig(Config):\n            ...     def post(self):\n            ...         if isinstance(self.data, str):\n            ...             self.data = Config(feature=self.data, label=self.data)\n            ...         return self\n            &gt;&gt;&gt; c = PostConfig(data=\"path\")\n            &gt;&gt;&gt; c.post()\n            PostConfig(&lt;class 'chanfig.config.Config'&gt;,\n              ('data'): Config(&lt;class 'chanfig.config.Config'&gt;,\n                ('feature'): 'path'\n                ('label'): 'path'\n              )\n            )\n        \"\"\"\nreturn self\ndef boot(self) -&gt; Config:\nr\"\"\"\n        Apply `post` recursively.\n        Sub-config may have their own `post` method.\n        `boot` is provided to apply `post` recursively.\n        By default, `boot` is called after `Config` is parsed.\n        If you don't need to parse command-line arguments, you should call `boot` manually.\n        See Also: [`post`][chanfig.Config.post]\n        Returns:\n            self:\n        Examples:\n            &gt;&gt;&gt; class DataConfig(Config):\n            ...     def post(self):\n            ...         if isinstance(self.path, str):\n            ...             self.path = Config(feature=self.path, label=self.path)\n            ...         return self\n            &gt;&gt;&gt; class BootConfig(Config):\n            ...     def __init__(self, *args, **kwargs):\n            ...         super().__init__(*args, **kwargs)\n            ...         self.dataset = DataConfig(path=\"path\")\n            ...     def post(self):\n            ...         if isinstance(self.id, str):\n            ...             self.id += \"_id\"\n            ...         return self\n            &gt;&gt;&gt; c = BootConfig(id=\"boot\")\n            &gt;&gt;&gt; c.boot()\n            BootConfig(&lt;class 'chanfig.config.Config'&gt;,\n              ('id'): 'boot_id'\n              ('dataset'): DataConfig(&lt;class 'chanfig.config.Config'&gt;,\n                ('path'): Config(&lt;class 'chanfig.config.Config'&gt;,\n                  ('feature'): 'path'\n                  ('label'): 'path'\n                )\n              )\n            )\n        \"\"\"\nfor value in self.values():\nif isinstance(value, Config):\nvalue.boot()\nself.post()\nreturn self\ndef parse(\nself,\nargs: Iterable[str] | None = None,\ndefault_config: str | None = None,\nno_default_config_action: str = \"raise\",\n) -&gt; Config:\nr\"\"\"\n        Parse command-line arguments with `ConfigParser`.\n        `parse` will try to parse all command-line arguments,\n        you don't need to pre-define them but typos may cause trouble.\n        This method internally calls `Config.boot()`.\n        See Also:\n            [`chanfig.ConfigParser.parse`][chanfig.ConfigParser.parse]: Implementation of `parse`.\n            [`parse_config`][chanfig.Config.parse_config]: Only parse valid config arguments.\n        Examples:\n            &gt;&gt;&gt; c = Config(a=0)\n            &gt;&gt;&gt; c.dict()\n            {'a': 0}\n            &gt;&gt;&gt; c.parse(['--a', '1', '--b', '2', '--c', '3']).dict()\n            {'a': 1, 'b': 2, 'c': 3}\n        \"\"\"\nif not self.hasattr(\"parser\"):\nself.setattr(\"parser\", ConfigParser())\nself.getattr(\"parser\").parse(args, self, default_config, no_default_config_action)\nself.boot()\nself.interpolate()\nreturn self\ndef parse_config(\nself,\nargs: Iterable[str] | None = None,\ndefault_config: str | None = None,\nno_default_config_action: str = \"raise\",\n) -&gt; Config:\nr\"\"\"\n        Parse command-line arguments with `ConfigParser`.\n        `parse_config` only parse command-line arguments that is in defined in `Config`.\n        This method internally calls `Config.boot()`.\n        See Also:\n            [`chanfig.ConfigParser.parse_config`][chanfig.ConfigParser.parse_config]: Implementation of `parse_config`.\n            [`parse`][chanfig.Config.parse]: Parse all command-line arguments.\n        Examples:\n            &gt;&gt;&gt; c = Config(a=0, b=0, c=0)\n            &gt;&gt;&gt; c.dict()\n            {'a': 0, 'b': 0, 'c': 0}\n            &gt;&gt;&gt; c.parse_config(['--a', '1', '--b', '2', '--c', '3']).dict()\n            {'a': 1, 'b': 2, 'c': 3}\n        \"\"\"\nif not self.hasattr(\"parser\"):\nself.setattr(\"parser\", ConfigParser())\nself.getattr(\"parser\").parse_config(args, self, default_config, no_default_config_action)\nself.boot()\nself.interpolate()\nreturn self\ndef add_argument(self, *args: Any, **kwargs: Any) -&gt; None:\nr\"\"\"\n        Add an argument to `ConfigParser`.\n        Note that value defined in `Config` will override the default value defined in `add_argument`.\n        Examples:\n            &gt;&gt;&gt; c = Config(a=0, c=1)\n            &gt;&gt;&gt; arg = c.add_argument(\"--a\", type=int, default=1)\n            &gt;&gt;&gt; arg = c.add_argument(\"--b\", type=int, default=2)\n            &gt;&gt;&gt; c.parse(['--c', '4']).dict()\n            {'a': 1, 'c': 4, 'b': 2}\n        \"\"\"\nif not self.hasattr(\"parser\"):\nself.setattr(\"parser\", ConfigParser())\nreturn self.getattr(\"parser\").add_argument(*args, **kwargs)\ndef freeze(self, recursive: bool = True) -&gt; Config:\nr\"\"\"\n        Freeze `Config`.\n        Args:\n            recursive:\n        **Alias**:\n        + `lock`\n        Examples:\n            &gt;&gt;&gt; c = Config(**{'i.d': 1013})\n            &gt;&gt;&gt; c.getattr('frozen')\n            False\n            &gt;&gt;&gt; c.freeze(recursive=False).dict()\n            {'i': {'d': 1013}}\n            &gt;&gt;&gt; c.getattr('frozen')\n            True\n            &gt;&gt;&gt; c.i.getattr('frozen')\n            False\n            &gt;&gt;&gt; c.lock().dict()  # alias\n            {'i': {'d': 1013}}\n            &gt;&gt;&gt; c.i.getattr('frozen')\n            True\n        \"\"\"\n@wraps(self.freeze)\ndef freeze(config: Config) -&gt; None:\nif isinstance(config, Config):\nconfig.setattr(\"frozen\", True)\nif recursive:\nself.apply_(freeze)\nelse:\nfreeze(self)\nreturn self\ndef lock(self, recursive: bool = True) -&gt; Config:\nr\"\"\"\n        Alias of [`freeze`][chanfig.Config.freeze].\n        \"\"\"\nreturn self.freeze(recursive=recursive)\n@contextmanager\ndef locked(self):\n\"\"\"\n        Context manager which temporarily locks `Config`.\n        Examples:\n            &gt;&gt;&gt; c = Config()\n            &gt;&gt;&gt; with c.locked():\n            ...     c['i.d'] = 1013\n            Traceback (most recent call last):\n            ValueError: Attempting to alter a frozen config. Run config.defrost() to defrost first.\n            &gt;&gt;&gt; c.i.d = 1013\n            &gt;&gt;&gt; c.dict()\n            {'i': {'d': 1013}}\n        \"\"\"\nwas_frozen = self.getattr(\"frozen\", False)\ntry:\nself.freeze()\nyield self\nfinally:\nif not was_frozen:\nself.defrost()\ndef defrost(self, recursive: bool = True) -&gt; Config:\nr\"\"\"\n        Defrost `Config`.\n        Args:\n            recursive:\n        **Alias**:\n        + `unlock`\n        Examples:\n            &gt;&gt;&gt; c = Config(**{'i.d': 1013})\n            &gt;&gt;&gt; c.getattr('frozen')\n            False\n            &gt;&gt;&gt; c.freeze().dict()\n            {'i': {'d': 1013}}\n            &gt;&gt;&gt; c.getattr('frozen')\n            True\n            &gt;&gt;&gt; c.defrost(recursive=False).dict()\n            {'i': {'d': 1013}}\n            &gt;&gt;&gt; c.getattr('frozen')\n            False\n            &gt;&gt;&gt; c.i.getattr('frozen')\n            True\n            &gt;&gt;&gt; c.unlock().dict()  # alias\n            {'i': {'d': 1013}}\n            &gt;&gt;&gt; c.i.getattr('frozen')\n            False\n        \"\"\"\n@wraps(self.defrost)\ndef defrost(config: Config) -&gt; None:\nif isinstance(config, Config):\nconfig.setattr(\"frozen\", False)\nif recursive:\nself.apply_(defrost)\nelse:\ndefrost(self)\nreturn self\ndef unlock(self, recursive: bool = True) -&gt; Config:\nr\"\"\"\n        Alias of [`defrost`][chanfig.Config.defrost].\n        \"\"\"\nreturn self.defrost(recursive=recursive)\n@contextmanager\ndef unlocked(self):\n\"\"\"\n        Context manager which temporarily unlocks `Config`.\n        Examples:\n            &gt;&gt;&gt; c = Config()\n            &gt;&gt;&gt; c.freeze().dict()\n            {}\n            &gt;&gt;&gt; with c.unlocked():\n            ...     c['i.d'] = 1013\n            &gt;&gt;&gt; c.defrost().dict()\n            {'i': {'d': 1013}}\n        \"\"\"\nwas_frozen = self.getattr(\"frozen\", False)\ntry:\nself.defrost()\nyield self\nfinally:\nif was_frozen:\nself.freeze()\ndef get(self, name: Any, default: Any = Null) -&gt; Any:\nr\"\"\"\n        Get value from `Config`.\n        Note that `default` has higher priority than `default_factory`.\n        Args:\n            name:\n            default:\n        Returns:\n            value:\n                If `Config` does not contain `name`, return `default`.\n                If `default` is not specified, return `default_factory()`.\n        Raises:\n            KeyError: If `Config` does not contain `name` and `default`/`default_factory` is not specified.\n        Examples:\n            &gt;&gt;&gt; d = Config(**{\"i.d\": 1013})\n            &gt;&gt;&gt; d.get('i.d')\n            1013\n            &gt;&gt;&gt; d['i.d']\n            1013\n            &gt;&gt;&gt; d.i.d\n            1013\n            &gt;&gt;&gt; d.get('f', 2)\n            2\n            &gt;&gt;&gt; d.f\n            Config(&lt;class 'chanfig.config.Config'&gt;, )\n            &gt;&gt;&gt; del d.f\n            &gt;&gt;&gt; d.freeze()\n            Config(&lt;class 'chanfig.config.Config'&gt;,\n              ('i'): Config(&lt;class 'chanfig.config.Config'&gt;,\n                ('d'): 1013\n              )\n            )\n            &gt;&gt;&gt; d.f\n            Traceback (most recent call last):\n            AttributeError: 'Config' object has no attribute 'f'\n            &gt;&gt;&gt; d[\"f.n\"]\n            Traceback (most recent call last):\n            KeyError: 'f.n'\n        \"\"\"\nif not self.hasattr(\"default_factory\"):  # did not call super().__init__() in sub-class\nself.setattr(\"default_factory\", Config)\nif name in self or not self.getattr(\"frozen\", False):\nreturn super().get(name, default)\nraise KeyError(name)\n@frozen_check\ndef set(\nself,\nname: Any,\nvalue: Any,\nconvert_mapping: bool | None = None,\n) -&gt; None:\nr\"\"\"\n        Set value of `Config`.\n        Args:\n            name:\n            value:\n            convert_mapping: Whether to convert `Mapping` to `NestedDict`.\n                Defaults to self.convert_mapping.\n        Raises:\n            ValueError: If `Config` is frozen.\n        Examples:\n            &gt;&gt;&gt; c = Config()\n            &gt;&gt;&gt; c['i.d'] = 1013\n            &gt;&gt;&gt; c.i.d\n            1013\n            &gt;&gt;&gt; c.freeze().dict()\n            {'i': {'d': 1013}}\n            &gt;&gt;&gt; c['i.d'] = 1013\n            Traceback (most recent call last):\n            ValueError: Attempting to alter a frozen config. Run config.defrost() to defrost first.\n            &gt;&gt;&gt; c.defrost().dict()\n            {'i': {'d': 1013}}\n            &gt;&gt;&gt; c['i.d'] = 1013\n            &gt;&gt;&gt; c.i.d\n            1013\n        \"\"\"\nreturn super().set(name, value, convert_mapping)\n@frozen_check\ndef delete(self, name: Any) -&gt; None:\nr\"\"\"\n        Delete value from `Config`.\n        Args:\n            name:\n        Examples:\n            &gt;&gt;&gt; d = Config(**{\"i.d\": 1013, \"f.n\": \"chang\"})\n            &gt;&gt;&gt; d.i.d\n            1013\n            &gt;&gt;&gt; d.f.n\n            'chang'\n            &gt;&gt;&gt; d.delete('i.d')\n            &gt;&gt;&gt; \"i.d\" in d\n            False\n            &gt;&gt;&gt; d.i.d\n            Config(&lt;class 'chanfig.config.Config'&gt;, )\n            &gt;&gt;&gt; \"i.d\" in d\n            True\n            &gt;&gt;&gt; del d.f.n\n            &gt;&gt;&gt; d.f.n\n            Config(&lt;class 'chanfig.config.Config'&gt;, )\n            &gt;&gt;&gt; del d.c\n            Traceback (most recent call last):\n            AttributeError: 'Config' object has no attribute 'c'\n        \"\"\"\nsuper().delete(name)\n@frozen_check\ndef pop(self, name: Any, default: Any = Null) -&gt; Any:\nr\"\"\"\n        Pop value from `Config`.\n        Args:\n            name:\n            default:\n        Returns:\n            value: If `Config` does not contain `name`, return `default`.\n        Examples:\n            &gt;&gt;&gt; c = Config()\n            &gt;&gt;&gt; c['i.d'] = 1013\n            &gt;&gt;&gt; c.pop('i.d')\n            1013\n            &gt;&gt;&gt; c.pop('i.d', True)\n            True\n            &gt;&gt;&gt; c.freeze().dict()\n            {'i': {}}\n            &gt;&gt;&gt; c['i.d'] = 1013\n            Traceback (most recent call last):\n            ValueError: Attempting to alter a frozen config. Run config.defrost() to defrost first.\n            &gt;&gt;&gt; c.defrost().dict()\n            {'i': {}}\n            &gt;&gt;&gt; c['i.d'] = 1013\n            &gt;&gt;&gt; c.pop('i.d')\n            1013\n        \"\"\"\nreturn super().pop(name, default)\n</code></pre>"},{"location":"config/#chanfig.config.Config.post","title":"<code>post()</code>","text":"<p>Post process of <code>Config</code>.</p> <p>Some <code>Config</code> may need to do some post process after <code>Config</code> is initialised. <code>post</code> is provided for this lazy-initialisation purpose.</p> <p>By default, <code>post</code> does nothing and returns <code>self</code>.</p> <p>Note that you should always call <code>boot</code> to apply <code>post</code> rather than calling <code>post</code> directly, as <code>boot</code> recursively call <code>post</code> on sub-configs.</p> <p>See Also: <code>boot</code></p> <p>Returns:</p> Name Type Description <code>self</code> <code>Config</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; class PostConfig(Config):\n...     def post(self):\n...         if isinstance(self.data, str):\n...             self.data = Config(feature=self.data, label=self.data)\n...         return self\n&gt;&gt;&gt; c = PostConfig(data=\"path\")\n&gt;&gt;&gt; c.post()\nPostConfig(&lt;class 'chanfig.config.Config'&gt;,\n  ('data'): Config(&lt;class 'chanfig.config.Config'&gt;,\n    ('feature'): 'path'\n    ('label'): 'path'\n  )\n)\n</code></pre> Source code in <code>chanfig/config.py</code> Python<pre><code>def post(self) -&gt; Config:\nr\"\"\"\n    Post process of `Config`.\n    Some `Config` may need to do some post process after `Config` is initialised.\n    `post` is provided for this lazy-initialisation purpose.\n    By default, `post` does nothing and returns `self`.\n    Note that you should always call `boot` to apply `post` rather than calling `post` directly,\n    as `boot` recursively call `post` on sub-configs.\n    See Also: [`boot`][chanfig.Config.boot]\n    Returns:\n        self:\n    Examples:\n        &gt;&gt;&gt; class PostConfig(Config):\n        ...     def post(self):\n        ...         if isinstance(self.data, str):\n        ...             self.data = Config(feature=self.data, label=self.data)\n        ...         return self\n        &gt;&gt;&gt; c = PostConfig(data=\"path\")\n        &gt;&gt;&gt; c.post()\n        PostConfig(&lt;class 'chanfig.config.Config'&gt;,\n          ('data'): Config(&lt;class 'chanfig.config.Config'&gt;,\n            ('feature'): 'path'\n            ('label'): 'path'\n          )\n        )\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"config/#chanfig.config.Config.boot","title":"<code>boot()</code>","text":"<p>Apply <code>post</code> recursively.</p> <p>Sub-config may have their own <code>post</code> method. <code>boot</code> is provided to apply <code>post</code> recursively.</p> <p>By default, <code>boot</code> is called after <code>Config</code> is parsed. If you don\u2019t need to parse command-line arguments, you should call <code>boot</code> manually.</p> <p>See Also: <code>post</code></p> <p>Returns:</p> Name Type Description <code>self</code> <code>Config</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; class DataConfig(Config):\n...     def post(self):\n...         if isinstance(self.path, str):\n...             self.path = Config(feature=self.path, label=self.path)\n...         return self\n&gt;&gt;&gt; class BootConfig(Config):\n...     def __init__(self, *args, **kwargs):\n...         super().__init__(*args, **kwargs)\n...         self.dataset = DataConfig(path=\"path\")\n...     def post(self):\n...         if isinstance(self.id, str):\n...             self.id += \"_id\"\n...         return self\n&gt;&gt;&gt; c = BootConfig(id=\"boot\")\n&gt;&gt;&gt; c.boot()\nBootConfig(&lt;class 'chanfig.config.Config'&gt;,\n  ('id'): 'boot_id'\n  ('dataset'): DataConfig(&lt;class 'chanfig.config.Config'&gt;,\n    ('path'): Config(&lt;class 'chanfig.config.Config'&gt;,\n      ('feature'): 'path'\n      ('label'): 'path'\n    )\n  )\n)\n</code></pre> Source code in <code>chanfig/config.py</code> Python<pre><code>def boot(self) -&gt; Config:\nr\"\"\"\n    Apply `post` recursively.\n    Sub-config may have their own `post` method.\n    `boot` is provided to apply `post` recursively.\n    By default, `boot` is called after `Config` is parsed.\n    If you don't need to parse command-line arguments, you should call `boot` manually.\n    See Also: [`post`][chanfig.Config.post]\n    Returns:\n        self:\n    Examples:\n        &gt;&gt;&gt; class DataConfig(Config):\n        ...     def post(self):\n        ...         if isinstance(self.path, str):\n        ...             self.path = Config(feature=self.path, label=self.path)\n        ...         return self\n        &gt;&gt;&gt; class BootConfig(Config):\n        ...     def __init__(self, *args, **kwargs):\n        ...         super().__init__(*args, **kwargs)\n        ...         self.dataset = DataConfig(path=\"path\")\n        ...     def post(self):\n        ...         if isinstance(self.id, str):\n        ...             self.id += \"_id\"\n        ...         return self\n        &gt;&gt;&gt; c = BootConfig(id=\"boot\")\n        &gt;&gt;&gt; c.boot()\n        BootConfig(&lt;class 'chanfig.config.Config'&gt;,\n          ('id'): 'boot_id'\n          ('dataset'): DataConfig(&lt;class 'chanfig.config.Config'&gt;,\n            ('path'): Config(&lt;class 'chanfig.config.Config'&gt;,\n              ('feature'): 'path'\n              ('label'): 'path'\n            )\n          )\n        )\n    \"\"\"\nfor value in self.values():\nif isinstance(value, Config):\nvalue.boot()\nself.post()\nreturn self\n</code></pre>"},{"location":"config/#chanfig.config.Config.parse","title":"<code>parse(args=None, default_config=None, no_default_config_action='raise')</code>","text":"<p>Parse command-line arguments with <code>ConfigParser</code>.</p> <p><code>parse</code> will try to parse all command-line arguments, you don\u2019t need to pre-define them but typos may cause trouble.</p> <p>This method internally calls <code>Config.boot()</code>.</p> See Also <p><code>chanfig.ConfigParser.parse</code>: Implementation of <code>parse</code>. <code>parse_config</code>: Only parse valid config arguments.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; c = Config(a=0)\n&gt;&gt;&gt; c.dict()\n{'a': 0}\n&gt;&gt;&gt; c.parse(['--a', '1', '--b', '2', '--c', '3']).dict()\n{'a': 1, 'b': 2, 'c': 3}\n</code></pre> Source code in <code>chanfig/config.py</code> Python<pre><code>def parse(\nself,\nargs: Iterable[str] | None = None,\ndefault_config: str | None = None,\nno_default_config_action: str = \"raise\",\n) -&gt; Config:\nr\"\"\"\n    Parse command-line arguments with `ConfigParser`.\n    `parse` will try to parse all command-line arguments,\n    you don't need to pre-define them but typos may cause trouble.\n    This method internally calls `Config.boot()`.\n    See Also:\n        [`chanfig.ConfigParser.parse`][chanfig.ConfigParser.parse]: Implementation of `parse`.\n        [`parse_config`][chanfig.Config.parse_config]: Only parse valid config arguments.\n    Examples:\n        &gt;&gt;&gt; c = Config(a=0)\n        &gt;&gt;&gt; c.dict()\n        {'a': 0}\n        &gt;&gt;&gt; c.parse(['--a', '1', '--b', '2', '--c', '3']).dict()\n        {'a': 1, 'b': 2, 'c': 3}\n    \"\"\"\nif not self.hasattr(\"parser\"):\nself.setattr(\"parser\", ConfigParser())\nself.getattr(\"parser\").parse(args, self, default_config, no_default_config_action)\nself.boot()\nself.interpolate()\nreturn self\n</code></pre>"},{"location":"config/#chanfig.config.Config.parse_config","title":"<code>parse_config(args=None, default_config=None, no_default_config_action='raise')</code>","text":"<p>Parse command-line arguments with <code>ConfigParser</code>.</p> <p><code>parse_config</code> only parse command-line arguments that is in defined in <code>Config</code>.</p> <p>This method internally calls <code>Config.boot()</code>.</p> See Also <p><code>chanfig.ConfigParser.parse_config</code>: Implementation of <code>parse_config</code>. <code>parse</code>: Parse all command-line arguments.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; c = Config(a=0, b=0, c=0)\n&gt;&gt;&gt; c.dict()\n{'a': 0, 'b': 0, 'c': 0}\n&gt;&gt;&gt; c.parse_config(['--a', '1', '--b', '2', '--c', '3']).dict()\n{'a': 1, 'b': 2, 'c': 3}\n</code></pre> Source code in <code>chanfig/config.py</code> Python<pre><code>def parse_config(\nself,\nargs: Iterable[str] | None = None,\ndefault_config: str | None = None,\nno_default_config_action: str = \"raise\",\n) -&gt; Config:\nr\"\"\"\n    Parse command-line arguments with `ConfigParser`.\n    `parse_config` only parse command-line arguments that is in defined in `Config`.\n    This method internally calls `Config.boot()`.\n    See Also:\n        [`chanfig.ConfigParser.parse_config`][chanfig.ConfigParser.parse_config]: Implementation of `parse_config`.\n        [`parse`][chanfig.Config.parse]: Parse all command-line arguments.\n    Examples:\n        &gt;&gt;&gt; c = Config(a=0, b=0, c=0)\n        &gt;&gt;&gt; c.dict()\n        {'a': 0, 'b': 0, 'c': 0}\n        &gt;&gt;&gt; c.parse_config(['--a', '1', '--b', '2', '--c', '3']).dict()\n        {'a': 1, 'b': 2, 'c': 3}\n    \"\"\"\nif not self.hasattr(\"parser\"):\nself.setattr(\"parser\", ConfigParser())\nself.getattr(\"parser\").parse_config(args, self, default_config, no_default_config_action)\nself.boot()\nself.interpolate()\nreturn self\n</code></pre>"},{"location":"config/#chanfig.config.Config.add_argument","title":"<code>add_argument(*args, **kwargs)</code>","text":"<p>Add an argument to <code>ConfigParser</code>.</p> <p>Note that value defined in <code>Config</code> will override the default value defined in <code>add_argument</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; c = Config(a=0, c=1)\n&gt;&gt;&gt; arg = c.add_argument(\"--a\", type=int, default=1)\n&gt;&gt;&gt; arg = c.add_argument(\"--b\", type=int, default=2)\n&gt;&gt;&gt; c.parse(['--c', '4']).dict()\n{'a': 1, 'c': 4, 'b': 2}\n</code></pre> Source code in <code>chanfig/config.py</code> Python<pre><code>def add_argument(self, *args: Any, **kwargs: Any) -&gt; None:\nr\"\"\"\n    Add an argument to `ConfigParser`.\n    Note that value defined in `Config` will override the default value defined in `add_argument`.\n    Examples:\n        &gt;&gt;&gt; c = Config(a=0, c=1)\n        &gt;&gt;&gt; arg = c.add_argument(\"--a\", type=int, default=1)\n        &gt;&gt;&gt; arg = c.add_argument(\"--b\", type=int, default=2)\n        &gt;&gt;&gt; c.parse(['--c', '4']).dict()\n        {'a': 1, 'c': 4, 'b': 2}\n    \"\"\"\nif not self.hasattr(\"parser\"):\nself.setattr(\"parser\", ConfigParser())\nreturn self.getattr(\"parser\").add_argument(*args, **kwargs)\n</code></pre>"},{"location":"config/#chanfig.config.Config.freeze","title":"<code>freeze(recursive=True)</code>","text":"<p>Freeze <code>Config</code>.</p> <p>Parameters:</p> Name Type Description Default <code>recursive</code> <code>bool</code> <code>True</code> <p>Alias:</p> <ul> <li><code>lock</code></li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; c = Config(**{'i.d': 1013})\n&gt;&gt;&gt; c.getattr('frozen')\nFalse\n&gt;&gt;&gt; c.freeze(recursive=False).dict()\n{'i': {'d': 1013}}\n&gt;&gt;&gt; c.getattr('frozen')\nTrue\n&gt;&gt;&gt; c.i.getattr('frozen')\nFalse\n&gt;&gt;&gt; c.lock().dict()  # alias\n{'i': {'d': 1013}}\n&gt;&gt;&gt; c.i.getattr('frozen')\nTrue\n</code></pre> Source code in <code>chanfig/config.py</code> Python<pre><code>def freeze(self, recursive: bool = True) -&gt; Config:\nr\"\"\"\n    Freeze `Config`.\n    Args:\n        recursive:\n    **Alias**:\n    + `lock`\n    Examples:\n        &gt;&gt;&gt; c = Config(**{'i.d': 1013})\n        &gt;&gt;&gt; c.getattr('frozen')\n        False\n        &gt;&gt;&gt; c.freeze(recursive=False).dict()\n        {'i': {'d': 1013}}\n        &gt;&gt;&gt; c.getattr('frozen')\n        True\n        &gt;&gt;&gt; c.i.getattr('frozen')\n        False\n        &gt;&gt;&gt; c.lock().dict()  # alias\n        {'i': {'d': 1013}}\n        &gt;&gt;&gt; c.i.getattr('frozen')\n        True\n    \"\"\"\n@wraps(self.freeze)\ndef freeze(config: Config) -&gt; None:\nif isinstance(config, Config):\nconfig.setattr(\"frozen\", True)\nif recursive:\nself.apply_(freeze)\nelse:\nfreeze(self)\nreturn self\n</code></pre>"},{"location":"config/#chanfig.config.Config.lock","title":"<code>lock(recursive=True)</code>","text":"<p>Alias of <code>freeze</code>.</p> Source code in <code>chanfig/config.py</code> Python<pre><code>def lock(self, recursive: bool = True) -&gt; Config:\nr\"\"\"\n    Alias of [`freeze`][chanfig.Config.freeze].\n    \"\"\"\nreturn self.freeze(recursive=recursive)\n</code></pre>"},{"location":"config/#chanfig.config.Config.locked","title":"<code>locked()</code>","text":"<p>Context manager which temporarily locks <code>Config</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; c = Config()\n&gt;&gt;&gt; with c.locked():\n...     c['i.d'] = 1013\nTraceback (most recent call last):\nValueError: Attempting to alter a frozen config. Run config.defrost() to defrost first.\n&gt;&gt;&gt; c.i.d = 1013\n&gt;&gt;&gt; c.dict()\n{'i': {'d': 1013}}\n</code></pre> Source code in <code>chanfig/config.py</code> Python<pre><code>@contextmanager\ndef locked(self):\n\"\"\"\n    Context manager which temporarily locks `Config`.\n    Examples:\n        &gt;&gt;&gt; c = Config()\n        &gt;&gt;&gt; with c.locked():\n        ...     c['i.d'] = 1013\n        Traceback (most recent call last):\n        ValueError: Attempting to alter a frozen config. Run config.defrost() to defrost first.\n        &gt;&gt;&gt; c.i.d = 1013\n        &gt;&gt;&gt; c.dict()\n        {'i': {'d': 1013}}\n    \"\"\"\nwas_frozen = self.getattr(\"frozen\", False)\ntry:\nself.freeze()\nyield self\nfinally:\nif not was_frozen:\nself.defrost()\n</code></pre>"},{"location":"config/#chanfig.config.Config.defrost","title":"<code>defrost(recursive=True)</code>","text":"<p>Defrost <code>Config</code>.</p> <p>Parameters:</p> Name Type Description Default <code>recursive</code> <code>bool</code> <code>True</code> <p>Alias:</p> <ul> <li><code>unlock</code></li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; c = Config(**{'i.d': 1013})\n&gt;&gt;&gt; c.getattr('frozen')\nFalse\n&gt;&gt;&gt; c.freeze().dict()\n{'i': {'d': 1013}}\n&gt;&gt;&gt; c.getattr('frozen')\nTrue\n&gt;&gt;&gt; c.defrost(recursive=False).dict()\n{'i': {'d': 1013}}\n&gt;&gt;&gt; c.getattr('frozen')\nFalse\n&gt;&gt;&gt; c.i.getattr('frozen')\nTrue\n&gt;&gt;&gt; c.unlock().dict()  # alias\n{'i': {'d': 1013}}\n&gt;&gt;&gt; c.i.getattr('frozen')\nFalse\n</code></pre> Source code in <code>chanfig/config.py</code> Python<pre><code>def defrost(self, recursive: bool = True) -&gt; Config:\nr\"\"\"\n    Defrost `Config`.\n    Args:\n        recursive:\n    **Alias**:\n    + `unlock`\n    Examples:\n        &gt;&gt;&gt; c = Config(**{'i.d': 1013})\n        &gt;&gt;&gt; c.getattr('frozen')\n        False\n        &gt;&gt;&gt; c.freeze().dict()\n        {'i': {'d': 1013}}\n        &gt;&gt;&gt; c.getattr('frozen')\n        True\n        &gt;&gt;&gt; c.defrost(recursive=False).dict()\n        {'i': {'d': 1013}}\n        &gt;&gt;&gt; c.getattr('frozen')\n        False\n        &gt;&gt;&gt; c.i.getattr('frozen')\n        True\n        &gt;&gt;&gt; c.unlock().dict()  # alias\n        {'i': {'d': 1013}}\n        &gt;&gt;&gt; c.i.getattr('frozen')\n        False\n    \"\"\"\n@wraps(self.defrost)\ndef defrost(config: Config) -&gt; None:\nif isinstance(config, Config):\nconfig.setattr(\"frozen\", False)\nif recursive:\nself.apply_(defrost)\nelse:\ndefrost(self)\nreturn self\n</code></pre>"},{"location":"config/#chanfig.config.Config.unlock","title":"<code>unlock(recursive=True)</code>","text":"<p>Alias of <code>defrost</code>.</p> Source code in <code>chanfig/config.py</code> Python<pre><code>def unlock(self, recursive: bool = True) -&gt; Config:\nr\"\"\"\n    Alias of [`defrost`][chanfig.Config.defrost].\n    \"\"\"\nreturn self.defrost(recursive=recursive)\n</code></pre>"},{"location":"config/#chanfig.config.Config.unlocked","title":"<code>unlocked()</code>","text":"<p>Context manager which temporarily unlocks <code>Config</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; c = Config()\n&gt;&gt;&gt; c.freeze().dict()\n{}\n&gt;&gt;&gt; with c.unlocked():\n...     c['i.d'] = 1013\n&gt;&gt;&gt; c.defrost().dict()\n{'i': {'d': 1013}}\n</code></pre> Source code in <code>chanfig/config.py</code> Python<pre><code>@contextmanager\ndef unlocked(self):\n\"\"\"\n    Context manager which temporarily unlocks `Config`.\n    Examples:\n        &gt;&gt;&gt; c = Config()\n        &gt;&gt;&gt; c.freeze().dict()\n        {}\n        &gt;&gt;&gt; with c.unlocked():\n        ...     c['i.d'] = 1013\n        &gt;&gt;&gt; c.defrost().dict()\n        {'i': {'d': 1013}}\n    \"\"\"\nwas_frozen = self.getattr(\"frozen\", False)\ntry:\nself.defrost()\nyield self\nfinally:\nif was_frozen:\nself.freeze()\n</code></pre>"},{"location":"config/#chanfig.config.Config.get","title":"<code>get(name, default=Null)</code>","text":"<p>Get value from <code>Config</code>.</p> <p>Note that <code>default</code> has higher priority than <code>default_factory</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Any</code> required <code>default</code> <code>Any</code> <code>Null</code> <p>Returns:</p> Name Type Description <code>value</code> <code>Any</code> <p>If <code>Config</code> does not contain <code>name</code>, return <code>default</code>. If <code>default</code> is not specified, return <code>default_factory()</code>.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If <code>Config</code> does not contain <code>name</code> and <code>default</code>/<code>default_factory</code> is not specified.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = Config(**{\"i.d\": 1013})\n&gt;&gt;&gt; d.get('i.d')\n1013\n&gt;&gt;&gt; d['i.d']\n1013\n&gt;&gt;&gt; d.i.d\n1013\n&gt;&gt;&gt; d.get('f', 2)\n2\n&gt;&gt;&gt; d.f\nConfig(&lt;class 'chanfig.config.Config'&gt;, )\n&gt;&gt;&gt; del d.f\n&gt;&gt;&gt; d.freeze()\nConfig(&lt;class 'chanfig.config.Config'&gt;,\n  ('i'): Config(&lt;class 'chanfig.config.Config'&gt;,\n    ('d'): 1013\n  )\n)\n&gt;&gt;&gt; d.f\nTraceback (most recent call last):\nAttributeError: 'Config' object has no attribute 'f'\n&gt;&gt;&gt; d[\"f.n\"]\nTraceback (most recent call last):\nKeyError: 'f.n'\n</code></pre> Source code in <code>chanfig/config.py</code> Python<pre><code>def get(self, name: Any, default: Any = Null) -&gt; Any:\nr\"\"\"\n    Get value from `Config`.\n    Note that `default` has higher priority than `default_factory`.\n    Args:\n        name:\n        default:\n    Returns:\n        value:\n            If `Config` does not contain `name`, return `default`.\n            If `default` is not specified, return `default_factory()`.\n    Raises:\n        KeyError: If `Config` does not contain `name` and `default`/`default_factory` is not specified.\n    Examples:\n        &gt;&gt;&gt; d = Config(**{\"i.d\": 1013})\n        &gt;&gt;&gt; d.get('i.d')\n        1013\n        &gt;&gt;&gt; d['i.d']\n        1013\n        &gt;&gt;&gt; d.i.d\n        1013\n        &gt;&gt;&gt; d.get('f', 2)\n        2\n        &gt;&gt;&gt; d.f\n        Config(&lt;class 'chanfig.config.Config'&gt;, )\n        &gt;&gt;&gt; del d.f\n        &gt;&gt;&gt; d.freeze()\n        Config(&lt;class 'chanfig.config.Config'&gt;,\n          ('i'): Config(&lt;class 'chanfig.config.Config'&gt;,\n            ('d'): 1013\n          )\n        )\n        &gt;&gt;&gt; d.f\n        Traceback (most recent call last):\n        AttributeError: 'Config' object has no attribute 'f'\n        &gt;&gt;&gt; d[\"f.n\"]\n        Traceback (most recent call last):\n        KeyError: 'f.n'\n    \"\"\"\nif not self.hasattr(\"default_factory\"):  # did not call super().__init__() in sub-class\nself.setattr(\"default_factory\", Config)\nif name in self or not self.getattr(\"frozen\", False):\nreturn super().get(name, default)\nraise KeyError(name)\n</code></pre>"},{"location":"config/#chanfig.config.Config.set","title":"<code>set(name, value, convert_mapping=None)</code>","text":"<p>Set value of <code>Config</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Any</code> required <code>value</code> <code>Any</code> required <code>convert_mapping</code> <code>bool | None</code> <p>Whether to convert <code>Mapping</code> to <code>NestedDict</code>. Defaults to self.convert_mapping.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>Config</code> is frozen.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; c = Config()\n&gt;&gt;&gt; c['i.d'] = 1013\n&gt;&gt;&gt; c.i.d\n1013\n&gt;&gt;&gt; c.freeze().dict()\n{'i': {'d': 1013}}\n&gt;&gt;&gt; c['i.d'] = 1013\nTraceback (most recent call last):\nValueError: Attempting to alter a frozen config. Run config.defrost() to defrost first.\n&gt;&gt;&gt; c.defrost().dict()\n{'i': {'d': 1013}}\n&gt;&gt;&gt; c['i.d'] = 1013\n&gt;&gt;&gt; c.i.d\n1013\n</code></pre> Source code in <code>chanfig/config.py</code> Python<pre><code>@frozen_check\ndef set(\nself,\nname: Any,\nvalue: Any,\nconvert_mapping: bool | None = None,\n) -&gt; None:\nr\"\"\"\n    Set value of `Config`.\n    Args:\n        name:\n        value:\n        convert_mapping: Whether to convert `Mapping` to `NestedDict`.\n            Defaults to self.convert_mapping.\n    Raises:\n        ValueError: If `Config` is frozen.\n    Examples:\n        &gt;&gt;&gt; c = Config()\n        &gt;&gt;&gt; c['i.d'] = 1013\n        &gt;&gt;&gt; c.i.d\n        1013\n        &gt;&gt;&gt; c.freeze().dict()\n        {'i': {'d': 1013}}\n        &gt;&gt;&gt; c['i.d'] = 1013\n        Traceback (most recent call last):\n        ValueError: Attempting to alter a frozen config. Run config.defrost() to defrost first.\n        &gt;&gt;&gt; c.defrost().dict()\n        {'i': {'d': 1013}}\n        &gt;&gt;&gt; c['i.d'] = 1013\n        &gt;&gt;&gt; c.i.d\n        1013\n    \"\"\"\nreturn super().set(name, value, convert_mapping)\n</code></pre>"},{"location":"config/#chanfig.config.Config.delete","title":"<code>delete(name)</code>","text":"<p>Delete value from <code>Config</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Any</code> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = Config(**{\"i.d\": 1013, \"f.n\": \"chang\"})\n&gt;&gt;&gt; d.i.d\n1013\n&gt;&gt;&gt; d.f.n\n'chang'\n&gt;&gt;&gt; d.delete('i.d')\n&gt;&gt;&gt; \"i.d\" in d\nFalse\n&gt;&gt;&gt; d.i.d\nConfig(&lt;class 'chanfig.config.Config'&gt;, )\n&gt;&gt;&gt; \"i.d\" in d\nTrue\n&gt;&gt;&gt; del d.f.n\n&gt;&gt;&gt; d.f.n\nConfig(&lt;class 'chanfig.config.Config'&gt;, )\n&gt;&gt;&gt; del d.c\nTraceback (most recent call last):\nAttributeError: 'Config' object has no attribute 'c'\n</code></pre> Source code in <code>chanfig/config.py</code> Python<pre><code>@frozen_check\ndef delete(self, name: Any) -&gt; None:\nr\"\"\"\n    Delete value from `Config`.\n    Args:\n        name:\n    Examples:\n        &gt;&gt;&gt; d = Config(**{\"i.d\": 1013, \"f.n\": \"chang\"})\n        &gt;&gt;&gt; d.i.d\n        1013\n        &gt;&gt;&gt; d.f.n\n        'chang'\n        &gt;&gt;&gt; d.delete('i.d')\n        &gt;&gt;&gt; \"i.d\" in d\n        False\n        &gt;&gt;&gt; d.i.d\n        Config(&lt;class 'chanfig.config.Config'&gt;, )\n        &gt;&gt;&gt; \"i.d\" in d\n        True\n        &gt;&gt;&gt; del d.f.n\n        &gt;&gt;&gt; d.f.n\n        Config(&lt;class 'chanfig.config.Config'&gt;, )\n        &gt;&gt;&gt; del d.c\n        Traceback (most recent call last):\n        AttributeError: 'Config' object has no attribute 'c'\n    \"\"\"\nsuper().delete(name)\n</code></pre>"},{"location":"config/#chanfig.config.Config.pop","title":"<code>pop(name, default=Null)</code>","text":"<p>Pop value from <code>Config</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Any</code> required <code>default</code> <code>Any</code> <code>Null</code> <p>Returns:</p> Name Type Description <code>value</code> <code>Any</code> <p>If <code>Config</code> does not contain <code>name</code>, return <code>default</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; c = Config()\n&gt;&gt;&gt; c['i.d'] = 1013\n&gt;&gt;&gt; c.pop('i.d')\n1013\n&gt;&gt;&gt; c.pop('i.d', True)\nTrue\n&gt;&gt;&gt; c.freeze().dict()\n{'i': {}}\n&gt;&gt;&gt; c['i.d'] = 1013\nTraceback (most recent call last):\nValueError: Attempting to alter a frozen config. Run config.defrost() to defrost first.\n&gt;&gt;&gt; c.defrost().dict()\n{'i': {}}\n&gt;&gt;&gt; c['i.d'] = 1013\n&gt;&gt;&gt; c.pop('i.d')\n1013\n</code></pre> Source code in <code>chanfig/config.py</code> Python<pre><code>@frozen_check\ndef pop(self, name: Any, default: Any = Null) -&gt; Any:\nr\"\"\"\n    Pop value from `Config`.\n    Args:\n        name:\n        default:\n    Returns:\n        value: If `Config` does not contain `name`, return `default`.\n    Examples:\n        &gt;&gt;&gt; c = Config()\n        &gt;&gt;&gt; c['i.d'] = 1013\n        &gt;&gt;&gt; c.pop('i.d')\n        1013\n        &gt;&gt;&gt; c.pop('i.d', True)\n        True\n        &gt;&gt;&gt; c.freeze().dict()\n        {'i': {}}\n        &gt;&gt;&gt; c['i.d'] = 1013\n        Traceback (most recent call last):\n        ValueError: Attempting to alter a frozen config. Run config.defrost() to defrost first.\n        &gt;&gt;&gt; c.defrost().dict()\n        {'i': {}}\n        &gt;&gt;&gt; c['i.d'] = 1013\n        &gt;&gt;&gt; c.pop('i.d')\n        1013\n    \"\"\"\nreturn super().pop(name, default)\n</code></pre>"},{"location":"config/#chanfig.config.frozen_check","title":"<code>frozen_check(func)</code>","text":"<p>Decorator check if the object is frozen.</p> Source code in <code>chanfig/config.py</code> Python<pre><code>def frozen_check(func: Callable):\nr\"\"\"\n    Decorator check if the object is frozen.\n    \"\"\"\n@wraps(func)\ndef decorator(self, *args: Any, **kwargs: Any):\nif self.getattr(\"frozen\", False):\nraise ValueError(\"Attempting to alter a frozen config. Run config.defrost() to defrost first.\")\nreturn func(self, *args, **kwargs)\nreturn decorator\n</code></pre>"},{"location":"default_dict/","title":"DefaultDict","text":"<p>             Bases: <code>FlatDict[_K, _V]</code></p> <p><code>DefaultDict</code> inherits from <code>FlatDict</code> and incorporates support of <code>default_factory</code> in the same manner as <code>collections.defaultdict</code>. If <code>default_factory is not None</code>, the value will be set to <code>default_factory()</code> when you access a key that does not exist in <code>DefaultDict</code>.</p> <p>You may specify <code>DefaultDict(default_factory=FlatDict)</code> when creating <code>DefaultDict</code> or by calling <code>dict.setattr('default_factory', FlatDict)</code> for existing <code>DefaultDict</code> objects.</p> <p>Note that just like <code>collections.defaultdict</code>, <code>default_factory()</code> is called without any arguments.</p> <p>Attributes:</p> Name Type Description <code>default_factory</code> <code>Optional[Callable]</code> <p>Default factory for defaultdict behavior.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>default_factory</code> is not callable.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = DefaultDict(list)\n&gt;&gt;&gt; d.a.append(1)\n&gt;&gt;&gt; d.a\n[1]\n&gt;&gt;&gt; d = DefaultDict([])\nTraceback (most recent call last):\nTypeError: `default_factory=[]` must be Callable, but got &lt;class 'list'&gt;.\n</code></pre> Source code in <code>chanfig/default_dict.py</code> Python<pre><code>class DefaultDict(FlatDict[_K, _V]):\nr\"\"\"\n    `DefaultDict` inherits from `FlatDict` and incorporates support of `default_factory`\n    in the same manner as `collections.defaultdict`.\n    If `default_factory is not None`, the value will be set to `default_factory()`\n    when you access a key that does not exist in `DefaultDict`.\n    You may specify `DefaultDict(default_factory=FlatDict)` when creating `DefaultDict` or\n    by calling `dict.setattr('default_factory', FlatDict)` for existing `DefaultDict` objects.\n    Note that just like `collections.defaultdict`, `default_factory()` is called without any arguments.\n    Attributes:\n        default_factory: Default factory for defaultdict behavior.\n    Raises:\n        TypeError: If `default_factory` is not callable.\n    Examples:\n        &gt;&gt;&gt; d = DefaultDict(list)\n        &gt;&gt;&gt; d.a.append(1)\n        &gt;&gt;&gt; d.a\n        [1]\n        &gt;&gt;&gt; d = DefaultDict([])\n        Traceback (most recent call last):\n        TypeError: `default_factory=[]` must be Callable, but got &lt;class 'list'&gt;.\n    \"\"\"\ndefault_factory: Optional[Callable] = None\ndef __init__(  # pylint: disable=W1113\nself, default_factory: Optional[Callable] = None, *args: Any, **kwargs: Any\n) -&gt; None:\nsuper().__init__(*args, **kwargs)\nif default_factory is not None:\nif callable(default_factory):\nself.setattr(\"default_factory\", default_factory)\nelse:\nraise TypeError(\nf\"`default_factory={default_factory}` must be Callable, but got {type(default_factory)}.\"\n)\ndef __missing__(self, name: Any, default=Null) -&gt; Any:  # pylint: disable=R1710\nif default is Null:\nif not self.hasattr(\"default_factory\") or self.getattr(\"default_factory\") in (None, Null):\nraise KeyError(name) from None\ndefault = self.getattr(\"default_factory\")()\nif isinstance(default, FlatDict):\ndefault.__dict__.update(self.__dict__)\nsuper().set(name, default)\nreturn default\ndef __repr__(self) -&gt; str:\nif self.default_factory is None:\nreturn super().__repr__()\nsuper_repr = super().__repr__()[len(self.__class__.__name__) :]  # noqa: E203\nif len(super_repr) == 2:\nreturn f\"{self.__class__.__name__}({self.default_factory}, )\"\nreturn f\"{self.__class__.__name__}({self.default_factory},\" + super_repr[1:]\ndef add(self, name: Any):\nr\"\"\"\n        Add a new default factory to the dictionary.\n        Args:\n            name:\n        Raises:\n            ValueError: If `default_factory` is None.\n        Examples:\n            &gt;&gt;&gt; d = DefaultDict(default_factory=DefaultDict)\n            &gt;&gt;&gt; d.add('d')\n            DefaultDict()\n            &gt;&gt;&gt; d.get('d')\n            DefaultDict()\n            &gt;&gt;&gt; d['n'] = 'chang'\n            &gt;&gt;&gt; d.n\n            'chang'\n            &gt;&gt;&gt; d.n = 'liu'\n            &gt;&gt;&gt; d['n']\n            'liu'\n            &gt;&gt;&gt; d = DefaultDict()\n            &gt;&gt;&gt; d.add('a')\n            Traceback (most recent call last):\n            ValueError: Cannot add to a DefaultDict with no default_factory\n        \"\"\"\nif self.default_factory is None:\nraise ValueError(\"Cannot add to a DefaultDict with no default_factory\")\nself.set(name, self.default_factory())  # pylint: disable=E1102\nreturn self.get(name)\n</code></pre>"},{"location":"default_dict/#chanfig.default_dict.DefaultDict.add","title":"<code>add(name)</code>","text":"<p>Add a new default factory to the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Any</code> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>default_factory</code> is None.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = DefaultDict(default_factory=DefaultDict)\n&gt;&gt;&gt; d.add('d')\nDefaultDict()\n&gt;&gt;&gt; d.get('d')\nDefaultDict()\n&gt;&gt;&gt; d['n'] = 'chang'\n&gt;&gt;&gt; d.n\n'chang'\n&gt;&gt;&gt; d.n = 'liu'\n&gt;&gt;&gt; d['n']\n'liu'\n&gt;&gt;&gt; d = DefaultDict()\n&gt;&gt;&gt; d.add('a')\nTraceback (most recent call last):\nValueError: Cannot add to a DefaultDict with no default_factory\n</code></pre> Source code in <code>chanfig/default_dict.py</code> Python<pre><code>def add(self, name: Any):\nr\"\"\"\n    Add a new default factory to the dictionary.\n    Args:\n        name:\n    Raises:\n        ValueError: If `default_factory` is None.\n    Examples:\n        &gt;&gt;&gt; d = DefaultDict(default_factory=DefaultDict)\n        &gt;&gt;&gt; d.add('d')\n        DefaultDict()\n        &gt;&gt;&gt; d.get('d')\n        DefaultDict()\n        &gt;&gt;&gt; d['n'] = 'chang'\n        &gt;&gt;&gt; d.n\n        'chang'\n        &gt;&gt;&gt; d.n = 'liu'\n        &gt;&gt;&gt; d['n']\n        'liu'\n        &gt;&gt;&gt; d = DefaultDict()\n        &gt;&gt;&gt; d.add('a')\n        Traceback (most recent call last):\n        ValueError: Cannot add to a DefaultDict with no default_factory\n    \"\"\"\nif self.default_factory is None:\nraise ValueError(\"Cannot add to a DefaultDict with no default_factory\")\nself.set(name, self.default_factory())  # pylint: disable=E1102\nreturn self.get(name)\n</code></pre>"},{"location":"flat_dict/","title":"FlatDict","text":"<p>             Bases: <code>dict</code>, <code>Mapping[_K, _V]</code></p> <p><code>FlatDict</code> with attribute-style access.</p> <p><code>FlatDict</code> inherits from built-in <code>dict</code>.</p> <p><code>FlatDict</code> works best with <code>Variable</code> objects. Simply call <code>flat_dict.a = Variable(1); flat_dict.b = flat_dict.a</code>, and their values will be synced.</p> <p>Even better, <code>FlatDict</code> support variable interpolation. Just set the value of one key to another key (surrounded by braces with $ at the begin, like ${xxx}), and calls <code>flat_dict.interpolate()</code>, <code>FlatDict</code> will interpolate their values and create <code>Variable</code> automatically.</p> <p><code>FlatDict</code> has many other easy to use helper methods, such as <code>difference</code>, <code>intersect</code>. And has full support for IO operations, such as <code>json</code> and <code>yaml</code>.</p> <p><code>FlatDict</code> also has pytorch support built-in. You can directly call <code>flat_dict.cpu()</code> or <code>flat_dict.to(\"cpu\")</code> to move all <code>torch.Tensor</code> objects across devices.</p> <p>Attributes:</p> Name Type Description <code>indent</code> <code>int</code> <p>Indentation level in printing and dumping to json or yaml.</p> Notes <p><code>FlatDict</code> rewrite <code>__getattribute__</code> and <code>__getattr__</code> to supports attribute-style access to its members. Therefore, all internal attributes should be set and get through <code>flat_dict.setattr</code> and <code>flat_dict.getattr</code>.</p> <p>Although it is possible to override other internal methods, it is not recommended to do so.</p> <p><code>__class__</code>, <code>__dict__</code>, and <code>getattr</code> are reserved and cannot be overrode in any manner.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict()\n&gt;&gt;&gt; d.d = 1013\n&gt;&gt;&gt; d['d']\n1013\n&gt;&gt;&gt; d['i'] = 1013\n&gt;&gt;&gt; d.i\n1013\n&gt;&gt;&gt; d.a = Variable(1)\n&gt;&gt;&gt; d.b = d.a\n&gt;&gt;&gt; d.a, d.b\n(1, 1)\n&gt;&gt;&gt; d.a += 1\n&gt;&gt;&gt; d.a, d.b\n(2, 2)\n&gt;&gt;&gt; d.a = 3\n&gt;&gt;&gt; d.a, d.b\n(3, 3)\n&gt;&gt;&gt; d.a = Variable('hello')\n&gt;&gt;&gt; f\"{d.a}, world!\"\n'hello, world!'\n&gt;&gt;&gt; d.a = d.a + ', world!'\n&gt;&gt;&gt; d.b\n'hello, world!'\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>class FlatDict(dict, Mapping[_K, _V]):  # for python 3.7 compatible\nr\"\"\"\n    `FlatDict` with attribute-style access.\n    `FlatDict` inherits from built-in `dict`.\n    `FlatDict` works best with `Variable` objects.\n    Simply call `flat_dict.a = Variable(1); flat_dict.b = flat_dict.a`, and their values will be synced.\n    Even better, `FlatDict` support variable interpolation.\n    Just set the value of one key to another key (surrounded by braces with $ at the begin, like ${xxx}),\n    and calls `flat_dict.interpolate()`, `FlatDict` will interpolate their values and create `Variable` automatically.\n    `FlatDict` has many other easy to use helper methods, such as `difference`, `intersect`.\n    And has full support for IO operations, such as `json` and `yaml`.\n    `FlatDict` also has pytorch support built-in.\n    You can directly call `flat_dict.cpu()` or `flat_dict.to(\"cpu\")` to move all `torch.Tensor` objects across devices.\n    Attributes:\n        indent: Indentation level in printing and dumping to json or yaml.\n    Notes:\n        `FlatDict` rewrite `__getattribute__` and `__getattr__` to supports attribute-style access to its members.\n        Therefore, all internal attributes should be set and get through `flat_dict.setattr` and `flat_dict.getattr`.\n        Although it is possible to override other internal methods, it is not recommended to do so.\n        `__class__`, `__dict__`, and `getattr` are reserved and cannot be overrode in any manner.\n    Examples:\n        &gt;&gt;&gt; d = FlatDict()\n        &gt;&gt;&gt; d.d = 1013\n        &gt;&gt;&gt; d['d']\n        1013\n        &gt;&gt;&gt; d['i'] = 1013\n        &gt;&gt;&gt; d.i\n        1013\n        &gt;&gt;&gt; d.a = Variable(1)\n        &gt;&gt;&gt; d.b = d.a\n        &gt;&gt;&gt; d.a, d.b\n        (1, 1)\n        &gt;&gt;&gt; d.a += 1\n        &gt;&gt;&gt; d.a, d.b\n        (2, 2)\n        &gt;&gt;&gt; d.a = 3\n        &gt;&gt;&gt; d.a, d.b\n        (3, 3)\n        &gt;&gt;&gt; d.a = Variable('hello')\n        &gt;&gt;&gt; f\"{d.a}, world!\"\n        'hello, world!'\n        &gt;&gt;&gt; d.a = d.a + ', world!'\n        &gt;&gt;&gt; d.b\n        'hello, world!'\n    \"\"\"\n# pylint: disable=R0904\nindent: int = 2\ndef __getattribute__(self, name: Any) -&gt; Any:\nif name not in (\"__class__\", \"__dict__\", \"getattr\") and name in self:\nreturn self.get(name)\nreturn super().__getattribute__(name)\ndef get(self, name: Any, default: Any = None) -&gt; Any:\nr\"\"\"\n        Get value from `FlatDict`.\n        Args:\n            name:\n            default:\n        Returns:\n            value:\n                If `FlatDict` does not contain `name`, return `default`.\n        Raises:\n            KeyError: If `FlatDict` does not contain `name` and `default` is not specified.\n        Examples:\n            &gt;&gt;&gt; d = FlatDict(d=1013)\n            &gt;&gt;&gt; d.get('d')\n            1013\n            &gt;&gt;&gt; d['d']\n            1013\n            &gt;&gt;&gt; d.d\n            1013\n            &gt;&gt;&gt; d.get('d', None)\n            1013\n            &gt;&gt;&gt; d.get('f', 2)\n            2\n            &gt;&gt;&gt; d.get('f')\n            &gt;&gt;&gt; d.get('f', Null)\n            Traceback (most recent call last):\n            KeyError: 'f'\n        \"\"\"\nif name in self:\nreturn dict.__getitem__(self, name)\nif default is not Null:\nreturn default\nreturn self.__missing__(name)\ndef __getitem__(self, name: Any) -&gt; Any:\nreturn self.get(name, default=Null)\ndef __getattr__(self, name: Any) -&gt; Any:\ntry:\nreturn self.get(name, default=Null)\nexcept KeyError:\nraise AttributeError(f\"'{self.__class__.__name__}' object has no attribute '{name}'\") from None\ndef set(self, name: Any, value: Any) -&gt; None:\nr\"\"\"\n        Set value of `FlatDict`.\n        Args:\n            name:\n            value:\n        Examples:\n            &gt;&gt;&gt; d = FlatDict()\n            &gt;&gt;&gt; d.set('d', 1013)\n            &gt;&gt;&gt; d.get('d')\n            1013\n            &gt;&gt;&gt; d['n'] = 'chang'\n            &gt;&gt;&gt; d.n\n            'chang'\n            &gt;&gt;&gt; d.n = 'liu'\n            &gt;&gt;&gt; d['n']\n            'liu'\n        \"\"\"\nif name in self and isinstance(self.get(name), Variable):\nself.get(name).set(value)\nelse:\ndict.__setitem__(self, name, value)\ndef __setitem__(self, name: Any, value: Any) -&gt; None:\nself.set(name, value)\ndef __setattr__(self, name: Any, value: Any) -&gt; None:\nself.set(name, value)\ndef delete(self, name: Any) -&gt; None:\nr\"\"\"\n        Delete value from `FlatDict`.\n        Args:\n            name:\n        Examples:\n            &gt;&gt;&gt; d = FlatDict(d=1016, n='chang')\n            &gt;&gt;&gt; d.d\n            1016\n            &gt;&gt;&gt; d.n\n            'chang'\n            &gt;&gt;&gt; d.delete('d')\n            &gt;&gt;&gt; d.d\n            Traceback (most recent call last):\n            AttributeError: 'FlatDict' object has no attribute 'd'\n            &gt;&gt;&gt; del d.n\n            &gt;&gt;&gt; d.n\n            Traceback (most recent call last):\n            AttributeError: 'FlatDict' object has no attribute 'n'\n            &gt;&gt;&gt; del d.f\n            Traceback (most recent call last):\n            AttributeError: 'FlatDict' object has no attribute 'f'\n        \"\"\"\ndict.__delitem__(self, name)\ndef __delitem__(self, name: Any) -&gt; None:\nreturn self.delete(name)\ndef __delattr__(self, name: Any) -&gt; None:\ntry:\nself.delete(name)\nexcept KeyError:\nraise AttributeError(f\"'{self.__class__.__name__}' object has no attribute '{name}'\") from None\ndef __missing__(self, name: Any) -&gt; Any:  # pylint: disable=R1710\nraise KeyError(name)\ndef validate(self) -&gt; None:\nr\"\"\"\n        Validate if all `Variable` in `FlatDict` are valid.\n        Raises:\n            TypeError: If `Variable` has invalid type.\n            ValueError: If `Variable` has invalid value.\n        Examples:\n            &gt;&gt;&gt; d = FlatDict(d=Variable(1016, type=int), n=Variable('chang', validator=lambda x: x.islower()))\n            &gt;&gt;&gt; d.validate()\n            &gt;&gt;&gt; d = FlatDict(d=Variable(1016, type=str), n=Variable('chang', validator=lambda x: x.islower()))\n            &gt;&gt;&gt; d.validate()\n            Traceback (most recent call last):\n            TypeError: 'd' has invalid type. Value 1016 is not of type &lt;class 'str'&gt;.\n            &gt;&gt;&gt; d = FlatDict(d=Variable(1016, type=int), n=Variable('chang', validator=lambda x: x.isupper()))\n            &gt;&gt;&gt; d.validate()\n            Traceback (most recent call last):\n            ValueError: 'n' has invalid value. Value chang is not valid.\n        \"\"\"\nfor name, value in self.all_items():\nif isinstance(value, Variable):\ntry:\nvalue.validate()\nexcept TypeError as exc:\nraise TypeError(f\"'{name}' has invalid type. {exc}\") from None\nexcept ValueError as exc:\nraise ValueError(f\"'{name}' has invalid value. {exc}\") from None\ndef getattr(self, name: str, default: Any = Null) -&gt; Any:\nr\"\"\"\n        Get attribute of `FlatDict`.\n        Note that it won't retrieve value in `FlatDict`,\n        Args:\n            name:\n            default:\n        Returns:\n            value: If `FlatDict` does not contain `name`, return `default`.\n        Raises:\n            AttributeError: If `FlatDict` does not contain `name` and `default` is not specified.\n        Examples:\n            &gt;&gt;&gt; d = FlatDict(a=1)\n            &gt;&gt;&gt; d.get('a')\n            1\n            &gt;&gt;&gt; d.getattr('a')\n            Traceback (most recent call last):\n            AttributeError: 'FlatDict' object has no attribute 'a'\n            &gt;&gt;&gt; d.getattr('b', 2)\n            2\n            &gt;&gt;&gt; d.setattr('b', 3)\n            &gt;&gt;&gt; d.getattr('b')\n            3\n        \"\"\"\ntry:\nif name in self.__dict__:\nreturn self.__dict__[name]\nif name in self.__class__.__dict__:\nreturn self.__class__.__dict__[name]\nreturn super().getattr(name, default)  # type: ignore\nexcept AttributeError:\nif default is not Null:\nreturn default\nraise AttributeError(f\"'{self.__class__.__name__}' object has no attribute '{name}'\") from None\ndef setattr(self, name: str, value: Any) -&gt; None:\nr\"\"\"\n        Set attribute of `FlatDict`.\n        Note that it won't alter values in `FlatDict`.\n        Args:\n            name:\n            value:\n        Warns:\n            RuntimeWarning: If name already exists in `FlatDict`.\n        Examples:\n            &gt;&gt;&gt; d = FlatDict()\n            &gt;&gt;&gt; d.setattr('attr', 'value')\n            &gt;&gt;&gt; d.getattr('attr')\n            'value'\n            &gt;&gt;&gt; d.set('d', 1013)\n            &gt;&gt;&gt; d.setattr('d', 1031)  # RuntimeWarning: d already exists in FlatDict.\n            &gt;&gt;&gt; d.get('d')\n            1013\n            &gt;&gt;&gt; d.d\n            1013\n            &gt;&gt;&gt; d.getattr('d')\n            1031\n        \"\"\"\nif name in self:\nwarn(\nf\"{name} already exists in {self.__class__.__name__}.\\n\"\nf\"Users must call `{self.__class__.__name__}.getattr()` to retrieve conflicting attribute value.\",\nRuntimeWarning,\n)\nself.__dict__[name] = value\ndef delattr(self, name: str) -&gt; None:\nr\"\"\"\n        Delete attribute of `FlatDict`.\n        Note that it won't delete values in `FlatDict`.\n        Args:\n            name:\n        Examples:\n            &gt;&gt;&gt; d = FlatDict()\n            &gt;&gt;&gt; d.setattr('name', 'chang')\n            &gt;&gt;&gt; d.getattr('name')\n            'chang'\n            &gt;&gt;&gt; d.delattr('name')\n            &gt;&gt;&gt; d.getattr('name')\n            Traceback (most recent call last):\n            AttributeError: 'FlatDict' object has no attribute 'name'\n        \"\"\"\ndel self.__dict__[name]\ndef hasattr(self, name: str) -&gt; bool:\nr\"\"\"\n        Determine if an attribute exists in `FlatDict`.\n        Args:\n            name:\n        Returns:\n            (bool):\n        Examples:\n            &gt;&gt;&gt; d = FlatDict()\n            &gt;&gt;&gt; d.setattr('name', 'chang')\n            &gt;&gt;&gt; d.hasattr('name')\n            True\n            &gt;&gt;&gt; d.delattr('name')\n            &gt;&gt;&gt; d.hasattr('name')\n            False\n        \"\"\"\ntry:\nif name in self.__dict__ or name in self.__class__.__dict__:\nreturn True\nreturn super().hasattr(name)  # type: ignore\nexcept AttributeError:\nreturn False\ndef dict(self, cls: Callable = dict) -&gt; Mapping:\nr\"\"\"\n        Convert `FlatDict` to other `Mapping`.\n        Args:\n            cls: Target class to be converted to.\n        Returns:\n            (Mapping):\n        See Also:\n            [`to_dict`][chanfig.flat_dict.to_dict]: Implementation of `dict`.\n        Examples:\n            &gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n            &gt;&gt;&gt; d.dict()\n            {'a': 1, 'b': 2, 'c': 3}\n        \"\"\"\nreturn cls(to_dict(self))\n@classmethod\ndef from_dict(cls, obj: Mapping | Sequence) -&gt; Any:  # pylint: disable=R0911\nr\"\"\"\n        Convert `Mapping` or `Sequence` to `FlatDict`.\n        Examples:\n            &gt;&gt;&gt; FlatDict.from_dict({'a': 1, 'b': 2, 'c': 3})\n            FlatDict(\n              ('a'): 1\n              ('b'): 2\n              ('c'): 3\n            )\n            &gt;&gt;&gt; FlatDict.from_dict([('a', 1), ('b', 2), ('c', 3)])\n            FlatDict(\n              ('a'): 1\n              ('b'): 2\n              ('c'): 3\n            )\n            &gt;&gt;&gt; FlatDict.from_dict([{'a': 1}, {'b': 2}, {'c': 3}])\n            [FlatDict(('a'): 1), FlatDict(('b'): 2), FlatDict(('c'): 3)]\n            &gt;&gt;&gt; FlatDict.from_dict({1, 2, 3})\n            Traceback (most recent call last):\n            TypeError: Expected Mapping or Sequence, but got &lt;class 'set'&gt;.\n        \"\"\"\nif isinstance(obj, Mapping):\nreturn cls(obj)\nif isinstance(obj, Sequence):\ntry:\nreturn cls(obj)\nexcept ValueError:\nreturn [cls(json) for json in obj]\nraise TypeError(f\"Expected Mapping or Sequence, but got {type(obj)}.\")\ndef interpolate(self, use_variable: bool = True, interpolators: MutableMapping | None = None) -&gt; FlatDict:\nr\"\"\"\n        Perform Variable interpolation.\n        Variable interpolation allows you to set the value of one key to be the value of another key easily.\n        Args:\n            use_variable: Whether to convert values to `Variable` objects.\n            interpolators: Mapping contains values for interpolation. Defaults to `self`.\n        See Also:\n            [Variable][`chanfig.Variable`]: Mutable wrapper of immutable objects.\n        Examples:\n            &gt;&gt;&gt; d = FlatDict(a=1, b=\"${a}\", c=\"${b}\")\n            &gt;&gt;&gt; d.dict()\n            {'a': 1, 'b': '${a}', 'c': '${b}'}\n            &gt;&gt;&gt; d.interpolate().dict()\n            {'a': 1, 'b': 1, 'c': 1}\n            &gt;&gt;&gt; isinstance(d.a, Variable)\n            True\n            &gt;&gt;&gt; d.a += 1\n            &gt;&gt;&gt; d.dict()\n            {'a': 2, 'b': 2, 'c': 2}\n            &gt;&gt;&gt; d.a is d.b and d.b is d.c\n            True\n            &gt;&gt;&gt; d = FlatDict(a=1, b=\"${a}\", c=\"${b}\")\n            &gt;&gt;&gt; d.dict()\n            {'a': 1, 'b': '${a}', 'c': '${b}'}\n            &gt;&gt;&gt; d.interpolate(False).dict()\n            {'a': 1, 'b': 1, 'c': 1}\n            &gt;&gt;&gt; isinstance(d.a, Variable)\n            False\n            &gt;&gt;&gt; d.a += 1\n            &gt;&gt;&gt; d.dict()\n            {'a': 2, 'b': 1, 'c': 1}\n            &gt;&gt;&gt; d = FlatDict(a=1, b=\"${b}\", c=\"${b}\")\n            &gt;&gt;&gt; d.interpolate().dict()\n            Traceback (most recent call last):\n            ValueError: Invalid values: {'b': '${b}'}.\n        \"\"\"\ninterpolators = interpolators or self\ninterpolatees = {\nk: v[2:-1] for k, v in self.all_items() if isinstance(v, str) and v.startswith(\"${\") and v.endswith(\"}\")\n}\ninvalid_variables = {k: f\"${{{v}}}\" for k, v in interpolatees.items() if k == v}\nif invalid_variables:\nraise ValueError(f\"Invalid values: {invalid_variables}.\")\nif use_variable:\nfor value in list(set(interpolatees.values()).difference(interpolatees.keys())):\nif not isinstance(interpolators[value], Variable):\ninterpolators[value] = Variable(interpolators[value])\nfor key, value in interpolatees.items():\nself[key] = interpolators[value]\nreturn self\ndef merge(self, *args: Any, overwrite: bool = True, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n        Merge `other` into `FlatDict`.\n        Args:\n            *args: `Mapping` or `Sequence` to be merged.\n            overwrite: Whether to overwrite existing values.\n            **kwargs: `Mapping` to be merged.\n        Returns:\n            self:\n        **Alias**:\n        + `union`\n        Examples:\n            &gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n            &gt;&gt;&gt; n = {'b': 'b', 'c': 'c', 'd': 'd'}\n            &gt;&gt;&gt; d.merge(n).dict()\n            {'a': 1, 'b': 'b', 'c': 'c', 'd': 'd'}\n            &gt;&gt;&gt; l = [('c', 3), ('d', 4)]\n            &gt;&gt;&gt; d.merge(l).dict()\n            {'a': 1, 'b': 'b', 'c': 3, 'd': 4}\n            &gt;&gt;&gt; FlatDict(a=1, b=1, c=1).union(FlatDict(b='b', c='c', d='d')).dict()  # alias\n            {'a': 1, 'b': 'b', 'c': 'c', 'd': 'd'}\n            &gt;&gt;&gt; d = FlatDict()\n            &gt;&gt;&gt; d.merge({1: 1, 2: 2, 3:3}).dict()\n            {1: 1, 2: 2, 3: 3}\n            &gt;&gt;&gt; d.merge(d.clone()).dict()\n            {1: 1, 2: 2, 3: 3}\n            &gt;&gt;&gt; d.merge({1:3, 2:1, 3: 2, 4: 4, 5: 5}, overwrite=False).dict()\n            {1: 1, 2: 2, 3: 3, 4: 4, 5: 5}\n        \"\"\"\nif not args and not kwargs:\nreturn self\nif len(args) == 1:\nargs = args[0]\nif isinstance(args, (PathLike, str, bytes)):\nargs = self.load(args)  # type: ignore\nwarn(\n\"merge file is deprecated and maybe removed in a future release. Use `merge_from_file` instead.\",\nPendingDeprecationWarning,\n)\nself._merge(self, args, overwrite=overwrite)\nelse:\nself._merge(self, args, overwrite=overwrite)\nself._merge(self, kwargs, overwrite=overwrite)\nreturn self\n@staticmethod\ndef _merge(this: FlatDict, that: Iterable, overwrite: bool = True) -&gt; Mapping:\nif isinstance(that, Mapping):\nthat = that.items()\nfor key, value in that:\nif key in this and isinstance(this[key], Mapping):\nif isinstance(value, Mapping):\nFlatDict._merge(this[key], value)\nelif overwrite:\nif isinstance(value, FlatDict):\nthis.set(key, value)\nelse:\nthis[key] = value\nelif overwrite or key not in this:\nthis.set(key, value)\nreturn this\ndef union(self, *args: Any, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n        Alias of [`merge`][chanfig.FlatDict.merge].\n        \"\"\"\nreturn self.merge(*args, **kwargs)\ndef merge_from_file(self, file: File, *args: Any, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n        Merge content of `file` into `FlatDict`.\n        Args:\n            file (File):\n            *args: Passed to [`load`][chanfig.FlatDict.load].\n            **kwargs: Passed to [`load`][chanfig.FlatDict.load].\n        Returns:\n            self:\n        Examples:\n            &gt;&gt;&gt; d = FlatDict(a=1, b=1)\n            &gt;&gt;&gt; d.merge_from_file(\"tests/test.yaml\").dict()\n            {'a': 1, 'b': 2, 'c': 3}\n        \"\"\"\nreturn self.merge(self.load(file, *args, **kwargs))\ndef intersect(self, other: Mapping | Iterable | PathStr) -&gt; FlatDict:\nr\"\"\"\n        Intersection of `FlatDict` and `other`.\n        Args:\n            other (Mapping | Iterable | PathStr):\n        Returns:\n            (FlatDict):\n        **Alias**:\n        + `inter`\n        Examples:\n            &gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n            &gt;&gt;&gt; n = {'b': 'b', 'c': 'c', 'd': 'd'}\n            &gt;&gt;&gt; d.intersect(n).dict()\n            {}\n            &gt;&gt;&gt; l = [('c', 3), ('d', 4)]\n            &gt;&gt;&gt; d.intersect(l).dict()\n            {'c': 3}\n            &gt;&gt;&gt; d.merge(l).intersect(\"tests/test.yaml\").dict()\n            {'a': 1, 'b': 2, 'c': 3}\n            &gt;&gt;&gt; d.intersect(1)\n            Traceback (most recent call last):\n            TypeError: `other=1` should be of type Mapping, Iterable or PathStr, but got &lt;class 'int'&gt;.\n            &gt;&gt;&gt; d.inter(FlatDict(b='b', c='c', d='d')).dict()  # alias\n            {}\n        \"\"\"\nif isinstance(other, (PathLike, str, bytes)):\nother = self.load(other)\nif isinstance(other, (Mapping,)):\nother = self.empty_like(other).items()\nif not isinstance(other, Iterable):\nraise TypeError(f\"`other={other}` should be of type Mapping, Iterable or PathStr, but got {type(other)}.\")\nreturn self.empty_like(\n**{key: value for key, value in other if key in self and self[key] == value}  # type: ignore\n)\ndef inter(self, other: Mapping | Iterable | PathStr, *args: Any, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n        Alias of [`intersect`][chanfig.FlatDict.intersect].\n        \"\"\"\nreturn self.intersect(other, *args, **kwargs)\ndef difference(self, other: Mapping | Iterable | PathStr) -&gt; FlatDict:\nr\"\"\"\n        Difference between `FlatDict` and `other`.\n        Args:\n            other:\n        Returns:\n            (FlatDict):\n        **Alias**:\n        + `diff`\n        Examples:\n            &gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n            &gt;&gt;&gt; n = {'b': 'b', 'c': 'c', 'd': 'd'}\n            &gt;&gt;&gt; d.difference(n).dict()\n            {'b': 'b', 'c': 'c', 'd': 'd'}\n            &gt;&gt;&gt; l = [('c', 3), ('d', 4)]\n            &gt;&gt;&gt; d.difference(l).dict()\n            {'d': 4}\n            &gt;&gt;&gt; d.merge(l).difference(\"tests/test.yaml\").dict()\n            {}\n            &gt;&gt;&gt; d.difference(1)\n            Traceback (most recent call last):\n            TypeError: `other=1` should be of type Mapping, Iterable or PathStr, but got &lt;class 'int'&gt;.\n            &gt;&gt;&gt; FlatDict(a=1, b=1, c=1).diff(FlatDict(b='b', c='c', d='d')).dict()  # alias\n            {'b': 'b', 'c': 'c', 'd': 'd'}\n        \"\"\"\nif isinstance(other, (PathLike, str, bytes)):\nother = self.load(other)\nif isinstance(other, (Mapping,)):\nother = self.empty_like(other).items()\nif not isinstance(other, Iterable):\nraise TypeError(f\"`other={other}` should be of type Mapping, Iterable or PathStr, but got {type(other)}.\")\nreturn self.empty_like(\n**{key: value for key, value in other if key not in self or self[key] != value}  # type: ignore\n)\ndef diff(self, other: Mapping | Iterable | PathStr, *args: Any, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n        Alias of [`difference`][chanfig.FlatDict.difference].\n        \"\"\"\nreturn self.difference(other, *args, **kwargs)\ndef to(self, cls: str | TorchDevice | TorchDType) -&gt; FlatDict:  # pragma: no cover\nr\"\"\"\n        Convert values of `FlatDict` to target `cls`.\n        Args:\n            cls (str | torch.device | torch.dtype):\n        Returns:\n            self:\n        Examples:\n            &gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n            &gt;&gt;&gt; d.to(int)\n            Traceback (most recent call last):\n            TypeError: to() only support torch.dtype and torch.device, but got &lt;class 'int'&gt;.\n        \"\"\"\n# pylint: disable=C0103\nif isinstance(cls, (str, TorchDevice, TorchDType)):\nfor k, v in self.all_items():\nif hasattr(v, \"to\"):\nself[k] = v.to(cls)\nreturn self\nraise TypeError(f\"to() only support torch.dtype and torch.device, but got {cls}.\")\ndef cpu(self) -&gt; FlatDict:  # pragma: no cover\nr\"\"\"\n        Move all tensors to cpu.\n        Returns:\n            self:\n        Examples:\n            &gt;&gt;&gt; import torch\n            &gt;&gt;&gt; d = FlatDict(a=torch.tensor(1))\n            &gt;&gt;&gt; d.cpu().dict()  # doctest: +SKIP\n            {'a': tensor(1, device='cpu')}\n        \"\"\"\nreturn self.to(TorchDevice(\"cpu\"))\ndef gpu(self) -&gt; FlatDict:  # pragma: no cover\nr\"\"\"\n        Move all tensors to gpu.\n        Returns:\n            self:\n        **Alias**:\n        + `cuda`\n        Examples:\n            &gt;&gt;&gt; import torch\n            &gt;&gt;&gt; d = FlatDict(a=torch.tensor(1))\n            &gt;&gt;&gt; d.gpu().dict()  # doctest: +SKIP\n            {'a': tensor(1, device='cuda:0')}\n            &gt;&gt;&gt; d.cuda().dict()  # alias  # doctest: +SKIP\n            {'a': tensor(1, device='cuda:0')}\n        \"\"\"\nreturn self.to(TorchDevice(\"cuda\"))\ndef cuda(self) -&gt; FlatDict:  # pragma: no cover\nr\"\"\"\n        Alias of [`gpu`][chanfig.FlatDict.gpu].\n        \"\"\"\nreturn self.gpu()\ndef tpu(self) -&gt; FlatDict:  # pragma: no cover\nr\"\"\"\n        Move all tensors to tpu.\n        Returns:\n            self:\n        **Alias**:\n        + `xla`\n        Examples:\n            &gt;&gt;&gt; import torch\n            &gt;&gt;&gt; d = FlatDict(a=torch.tensor(1))\n            &gt;&gt;&gt; d.tpu().dict()  # doctest: +SKIP\n            {'a': tensor(1, device='xla:0')}\n            &gt;&gt;&gt; d.xla().dict()  # alias  # doctest: +SKIP\n            {'a': tensor(1, device='xla:0')}\n        \"\"\"\nreturn self.to(TorchDevice(\"xla\"))\ndef xla(self) -&gt; FlatDict:  # pragma: no cover\nr\"\"\"\n        Alias of [`tpu`][chanfig.FlatDict.tpu].\n        \"\"\"\nreturn self.tpu()\ndef copy(self) -&gt; FlatDict:\nr\"\"\"\n        Create a shallow copy of `FlatDict`.\n        Returns:\n            (FlatDict):\n        Examples:\n            &gt;&gt;&gt; d = FlatDict(a=[])\n            &gt;&gt;&gt; d.setattr(\"name\", \"Chang\")\n            &gt;&gt;&gt; c = d.copy()\n            &gt;&gt;&gt; c.dict()\n            {'a': []}\n            &gt;&gt;&gt; d.a.append(1)\n            &gt;&gt;&gt; c.dict()\n            {'a': [1]}\n            &gt;&gt;&gt; c.getattr(\"name\")\n            'Chang'\n        \"\"\"\nreturn copy(self)\ndef __deepcopy__(self, memo: Mapping | None = None) -&gt; FlatDict:\n# pylint: disable=C0103\nif memo is not None and id(self) in memo:\nreturn memo[id(self)]\nret = self.empty_like()\nfor k, v in self.items():\nif isinstance(v, FlatDict):\nret[k] = v.deepcopy(memo=memo)\nelse:\nret[k] = deepcopy(v)\nreturn ret\ndef deepcopy(self, memo: Mapping | None = None) -&gt; FlatDict:  # pylint: disable=W0613\nr\"\"\"\n        Create a deep copy of `FlatDict`.\n        Returns:\n            (FlatDict):\n        **Alias**:\n        + `clone`\n        Examples:\n            &gt;&gt;&gt; d = FlatDict(a=[])\n            &gt;&gt;&gt; d.setattr(\"name\", \"Chang\")\n            &gt;&gt;&gt; c = d.deepcopy()\n            &gt;&gt;&gt; c.dict()\n            {'a': []}\n            &gt;&gt;&gt; d.a.append(1)\n            &gt;&gt;&gt; c.dict()\n            {'a': []}\n            &gt;&gt;&gt; c.getattr(\"name\")\n            'Chang'\n            &gt;&gt;&gt; d == d.clone()  # alias\n            True\n        \"\"\"\nreturn deepcopy(self)\ndef clone(self, memo: Mapping | None = None) -&gt; FlatDict:\nr\"\"\"\n        Alias of [`deepcopy`][chanfig.FlatDict.deepcopy].\n        \"\"\"\nreturn self.deepcopy(memo=memo)\ndef save(self, file: File, method: str | None = None, *args: Any, **kwargs: Any) -&gt; None:  # pylint: disable=W1113\nr\"\"\"\n        Save `FlatDict` to file.\n        Raises:\n            ValueError: If save to `IO` and `method` is not specified.\n            TypeError: If save to unsupported extension.\n        **Alias**:\n        + `save`\n        Examples:\n            &gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n            &gt;&gt;&gt; d.save(\"tests/test.yaml\")\n            &gt;&gt;&gt; d.save(\"test.conf\")\n            Traceback (most recent call last):\n            TypeError: `file='test.conf'` should be in ('json',) or ('yml', 'yaml'), but got conf.\n            &gt;&gt;&gt; with open(\"test.yaml\", \"w\") as f:\n            ...     d.save(f)\n            Traceback (most recent call last):\n            ValueError: `method` must be specified when saving to IO.\n        \"\"\"\nif method is None:\nif isinstance(file, (IOBase, IO)):\nraise ValueError(\"`method` must be specified when saving to IO.\")\nmethod = splitext(file)[-1][1:]  # type: ignore\nextension = method.lower()  # type: ignore\nif extension in YAML:\nreturn self.yaml(file=file, *args, **kwargs)  # type: ignore\nif extension in JSON:\nreturn self.json(file=file, *args, **kwargs)  # type: ignore\nraise TypeError(f\"`file={file!r}` should be in {JSON} or {YAML}, but got {extension}.\")\ndef dump(self, file: File, method: str | None = None, *args: Any, **kwargs: Any) -&gt; None:  # pylint: disable=W1113\nr\"\"\"\n        Alias of [`save`][chanfig.FlatDict.save].\n        \"\"\"\nreturn self.save(file, method, *args, **kwargs)\n@classmethod\ndef load(  # pylint: disable=W1113\ncls, file: File, method: str | None = None, *args: Any, **kwargs: Any\n) -&gt; FlatDict:\n\"\"\"\n        Load `FlatDict` from file.\n        Args:\n            file: File to load from.\n            method: File type, should be in `JSON` or `YAML`.\n        Returns:\n            (FlatDict):\n        Raises:\n            ValueError: If load from `IO` and `method` is not specified.\n            TypeError: If dump to unsupported extension.\n        Examples:\n            &gt;&gt;&gt; d = FlatDict.load(\"tests/test.yaml\")\n            &gt;&gt;&gt; d.dict()\n            {'a': 1, 'b': 2, 'c': 3}\n            &gt;&gt;&gt; d.load(\"tests/test.conf\")\n            Traceback (most recent call last):\n            TypeError: `file='tests/test.conf'` should be in ('json',) or ('yml', 'yaml'), but got conf.\n            &gt;&gt;&gt; with open(\"tests/test.yaml\") as f:\n            ...     d.load(f)\n            Traceback (most recent call last):\n            ValueError: `method` must be specified when loading from IO.\n        \"\"\"\nif method is None:\nif isinstance(file, (IOBase, IO)):\nraise ValueError(\"`method` must be specified when loading from IO.\")\nmethod = splitext(file)[-1][1:]  # type: ignore\nextension = method.lower()  # type: ignore\nif extension in JSON:\nreturn cls.from_json(file, *args, **kwargs)\nif extension in YAML:\nreturn cls.from_yaml(file, *args, **kwargs)\nraise TypeError(f\"`file={file!r}` should be in {JSON} or {YAML}, but got {extension}.\")\ndef json(self, file: File, *args: Any, **kwargs: Any) -&gt; None:\nr\"\"\"\n        Dump `FlatDict` to json file.\n        This method internally calls `self.jsons()` to generate json string.\n        You may overwrite `jsons` in case something is not json serializable.\n        Examples:\n            &gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n            &gt;&gt;&gt; d.json(\"tests/test.json\")\n        \"\"\"\nwith self.open(file, mode=\"w\") as fp:  # pylint: disable=C0103\nfp.write(self.jsons(*args, **kwargs))\n@classmethod\ndef from_json(cls, file: File, *args: Any, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n        Construct `FlatDict` from json file.\n        This method internally calls `self.from_jsons()` to construct object from json string.\n        You may overwrite `from_jsons` in case something is not json serializable.\n        Returns:\n            (FlatDict):\n        Examples:\n            &gt;&gt;&gt; d = FlatDict.from_json('tests/test.json')\n            &gt;&gt;&gt; d.dict()\n            {'a': 1, 'b': 2, 'c': 3}\n        \"\"\"\nwith cls.open(file) as fp:  # pylint: disable=C0103\nif isinstance(file, (IOBase, IO)):\nreturn cls.from_jsons(fp.getvalue(), *args, **kwargs)  # type: ignore\nreturn cls.from_jsons(fp.read(), *args, **kwargs)\ndef jsons(self, *args: Any, **kwargs: Any) -&gt; str:\nr\"\"\"\n        Dump `FlatDict` to json string.\n        Returns:\n            (str):\n        Examples:\n            &gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n            &gt;&gt;&gt; d.jsons()\n            '{\\n  \"a\": 1,\\n  \"b\": 2,\\n  \"c\": 3\\n}'\n        \"\"\"\nkwargs.setdefault(\"cls\", JsonEncoder)\nkwargs.setdefault(\"indent\", self.getattr(\"indent\", 2))\nreturn json_dumps(self.dict(), *args, **kwargs)\n@classmethod\ndef from_jsons(cls, string: str, *args: Any, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n        Construct `FlatDict` from json string.\n        Returns:\n            (FlatDict):\n        Examples:\n            &gt;&gt;&gt; FlatDict.from_jsons('{\\n  \"a\": 1,\\n  \"b\": 2,\\n  \"c\": 3\\n}').dict()\n            {'a': 1, 'b': 2, 'c': 3}\n            &gt;&gt;&gt; FlatDict.from_jsons('[[\"a\", 1], [\"b\", 2], [\"c\", 3]]').dict()\n            {'a': 1, 'b': 2, 'c': 3}\n            &gt;&gt;&gt; FlatDict.from_jsons('[{\"a\": 1}, {\"b\": 2}, {\"c\": 3}]')\n            [FlatDict(('a'): 1), FlatDict(('b'): 2), FlatDict(('c'): 3)]\n        \"\"\"\nreturn cls.from_dict(json_loads(string, *args, **kwargs))\ndef yaml(self, file: File, *args: Any, **kwargs: Any) -&gt; None:\nr\"\"\"\n        Dump `FlatDict` to yaml file.\n        This method internally calls `self.yamls()` to generate yaml string.\n        You may overwrite `yamls` in case something is not yaml serializable.\n        Examples:\n            &gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n            &gt;&gt;&gt; d.yaml(\"tests/test.yaml\")\n        \"\"\"\nwith self.open(file, mode=\"w\") as fp:  # pylint: disable=C0103\nself.yamls(fp, *args, **kwargs)\n@classmethod\ndef from_yaml(cls, file: File, *args: Any, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n        Construct `FlatDict` from yaml file.\n        This method internally calls `self.from_yamls()` to construct object from yaml string.\n        You may overwrite `from_yamls` in case something is not yaml serializable.\n        Returns:\n            (FlatDict):\n        Examples:\n            &gt;&gt;&gt; FlatDict.from_yaml('tests/test.yaml').dict()\n            {'a': 1, 'b': 2, 'c': 3}\n        \"\"\"\nwith cls.open(file) as fp:  # pylint: disable=C0103\nif isinstance(file, (IOBase, IO)):\nreturn cls.from_yamls(fp.getvalue(), *args, **kwargs)  # type: ignore\nreturn cls.from_yamls(fp.read(), *args, **kwargs)\ndef yamls(self, *args: Any, **kwargs: Any) -&gt; str:\nr\"\"\"\n        Dump `FlatDict` to yaml string.\n        Returns:\n            (str):\n        Examples:\n            &gt;&gt;&gt; FlatDict(a=1, b=2, c=3).yamls()\n            'a: 1\\nb: 2\\nc: 3\\n'\n        \"\"\"\nkwargs.setdefault(\"Dumper\", YamlDumper)\nkwargs.setdefault(\"indent\", self.getattr(\"indent\", 2))\nreturn yaml_dump(self.dict(), *args, **kwargs)  # type: ignore\n@classmethod\ndef from_yamls(cls, string: str, *args: Any, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n        Construct `FlatDict` from yaml string.\n        Returns:\n            (FlatDict):\n        Examples:\n            &gt;&gt;&gt; FlatDict.from_yamls('a: 1\\nb: 2\\nc: 3\\n').dict()\n            {'a': 1, 'b': 2, 'c': 3}\n            &gt;&gt;&gt; FlatDict.from_yamls('- - a\\n  - 1\\n- - b\\n  - 2\\n- - c\\n  - 3\\n').dict()\n            {'a': 1, 'b': 2, 'c': 3}\n            &gt;&gt;&gt; FlatDict.from_yamls('- a: 1\\n- b: 2\\n- c: 3\\n')\n            [FlatDict(('a'): 1), FlatDict(('b'): 2), FlatDict(('c'): 3)]\n        \"\"\"\nkwargs.setdefault(\"Loader\", YamlLoader)\nreturn cls.from_dict(yaml_load(string, *args, **kwargs))\n@staticmethod\n@contextmanager\ndef open(file: File, *args: Any, encoding: str = \"utf-8\", **kwargs: Any) -&gt; Generator[IOBase | IO, Any, Any]:\nr\"\"\"\n        Open file IO from file path or IO.\n        This methods extends the ability of built-in `open` by allowing it to accept an `IOBase` object.\n        Args:\n            file: File path or IO.\n            *args: Additional arguments passed to `open`.\n                Defaults to ().\n            **kwargs: Any\n                Additional keyword arguments passed to `open`.\n                Defaults to {}.\n        Yields:\n            (Generator[IOBase | IO, Any, Any]):\n        Examples:\n            &gt;&gt;&gt; with FlatDict.open(\"tests/test.yaml\") as fp:\n            ...     print(fp.read())\n            a: 1\n            b: 2\n            c: 3\n            &lt;BLANKLINE&gt;\n            &gt;&gt;&gt; io = open(\"tests/test.yaml\")\n            &gt;&gt;&gt; with FlatDict.open(io) as fp:\n            ...     print(fp.read())\n            a: 1\n            b: 2\n            c: 3\n            &lt;BLANKLINE&gt;\n            &gt;&gt;&gt; with FlatDict.open(123, mode=\"w\") as fp:\n            ...     print(fp.read())\n            Traceback (most recent call last):\n            TypeError: expected str, bytes, os.PathLike, IO or IOBase, not int\n        \"\"\"\nif isinstance(file, (IOBase, IO)):\nyield file\nelif isinstance(file, (PathLike, str, bytes)):\ntry:\nfile = open(file, *args, encoding=encoding, **kwargs)  # type: ignore # noqa: SIM115\nyield file  # type: ignore\nfinally:\nfile.close()  # type: ignore\nelse:\nraise TypeError(f\"expected str, bytes, os.PathLike, IO or IOBase, not {type(file).__name__}\")\n@classmethod\ndef empty(cls, *args: Any, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n        Initialise an empty `FlatDict`.\n        This method is helpful when you inheriting `FlatDict` with default values defined in `__init__()`.\n        As use `type(self)()` in this case would copy all the default values, which might not be desired.\n        This method will preserve everything in `FlatDict.__class__.__dict__`.\n        Returns:\n            (FlatDict):\n        Examples:\n            &gt;&gt;&gt; d = FlatDict(a=[])\n            &gt;&gt;&gt; c = d.empty()\n            &gt;&gt;&gt; c.dict()\n            {}\n        \"\"\"\nempty = cls.__new__(cls)\nempty.merge(*args, **kwargs)  # pylint: disable=W0212\nreturn empty\ndef empty_like(self, *args: Any, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n        Initialise an empty copy of `FlatDict`.\n        This method will preserve everything in `FlatDict.__class__.__dict__` and `FlatDict.__dict__`.\n        Returns:\n            (FlatDict):\n        Examples:\n            &gt;&gt;&gt; d = FlatDict(a=[])\n            &gt;&gt;&gt; d.setattr(\"name\", \"Chang\")\n            &gt;&gt;&gt; c = d.empty_like()\n            &gt;&gt;&gt; c.dict()\n            {}\n            &gt;&gt;&gt; c.getattr(\"name\")\n            'Chang'\n        \"\"\"\nempty = self.empty(*args, **kwargs)\nempty.__dict__.update(self.__dict__)\nreturn empty\ndef all_keys(self) -&gt; Generator:\nr\"\"\"\n        Equivalent to `keys`.\n        This method is provided solely to make methods work on both `FlatDict` and `NestedDict`.\n        See Also:\n            [`all_keys`][chanfig.NestedDict.all_keys]\n        \"\"\"\nyield from self.keys()\ndef all_values(self) -&gt; Generator:\nr\"\"\"\n        Equivalent to `keys`.\n        This method is provided solely to make methods work on both `FlatDict` and `NestedDict`.\n        See Also:\n            [`all_values`][chanfig.NestedDict.all_values]\n        \"\"\"\nyield from self.values()\ndef all_items(self) -&gt; Generator:\nr\"\"\"\n        Equivalent to `keys`.\n        This method is provided solely to make methods work on both `FlatDict` and `NestedDict`.\n        See Also:\n            [`all_items`][chanfig.NestedDict.all_items]\n        \"\"\"\nyield from self.items()\ndef dropnull(self) -&gt; FlatDict:\nr\"\"\"\n        Drop key-value pairs with `Null` value.\n        Returns:\n            (FlatDict):\n        **Alias**:\n        + `dropna`\n        Examples:\n            &gt;&gt;&gt; d = FlatDict(a=Null, b=Null, c=3)\n            &gt;&gt;&gt; d.dict()\n            {'a': Null, 'b': Null, 'c': 3}\n            &gt;&gt;&gt; d.dropnull().dict()\n            {'c': 3}\n            &gt;&gt;&gt; d.dropna().dict()  # alias\n            {'c': 3}\n        \"\"\"\nreturn self.empty_like({k: v for k, v in self.all_items() if v is not Null})\ndef dropna(self) -&gt; FlatDict:\nr\"\"\"\n        Alias of [`dropnull`][chanfig.FlatDict.dropnull].\n        \"\"\"\nreturn self.dropnull()\n@staticmethod\ndef extra_repr() -&gt; str:  # pylint: disable=C0116\nreturn \"\"\ndef __repr__(self) -&gt; str:\nextra_lines = []\nextra_repr = self.extra_repr()\n# empty string will be split into list ['']\nif extra_repr:\nextra_lines = extra_repr.split(\"\\n\")\nchild_lines = []\nfor key, value in self.items():\nkey_repr = repr(key)\nvalue_repr = repr(value)\nvalue_repr = self._add_indent(value_repr)\nchild_lines.append(f\"({key_repr}): {value_repr}\")\n# child_lines.append(f\"{key_repr}: {value_repr}\")\nlines = extra_lines + child_lines\nmain_repr = self.__class__.__name__ + \"(\"\nif lines:\n# simple one-liner info, which most builtin Modules will use\nif len(extra_lines) == 1 and not child_lines:\nmain_repr += extra_lines[0]\nelif len(child_lines) == 1 and not extra_lines and len(child_lines[0]) &lt; 10:\nmain_repr += child_lines[0]\nelse:\nmain_repr += \"\\n  \" + \"\\n  \".join(lines) + \"\\n\"\nmain_repr += \")\"\nreturn main_repr\ndef _add_indent(self, text: str) -&gt; str:\nlines = text.split(\"\\n\")\n# don't do anything for single-line stuff\nif len(lines) == 1:\nreturn text\nfirst = lines.pop(0)\nlines = [(self.getattr(\"indent\", 2) * \" \") + line for line in lines]\ntext = \"\\n\".join(lines)\ntext = first + \"\\n\" + text\nreturn text\ndef __format__(self, format_spec: str) -&gt; str:\nreturn repr(self.empty_like({k: v.__format__(format_spec) for k, v in self.all_items()}))\ndef __hash__(self):\nreturn hash(frozenset(self.items()))\ndef __getstate__(self, *args: Any, **kwargs: Any):\nreturn self.__dict__\ndef __setstate__(self, states, *args: Any, **kwargs: Any):\nfor name, value in states.items():\nself.setattr(name, value)\ndef __wrapped__(self, *args: Any, **kwargs: Any):  # pragma: no cover\npass\ndef _ipython_display_(self):  # pragma: no cover\nreturn repr(self)\ndef _ipython_canary_method_should_not_exist_(self):  # pragma: no cover\nreturn None\ndef aihwerij235234ljsdnp34ksodfipwoe234234jlskjdf(self):  # pragma: no cover\nreturn None\ndef __rich__(self):  # pragma: no cover\nreturn self.__repr__()\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.get","title":"<code>get(name, default=None)</code>","text":"<p>Get value from <code>FlatDict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Any</code> required <code>default</code> <code>Any</code> <code>None</code> <p>Returns:</p> Name Type Description <code>value</code> <code>Any</code> <p>If <code>FlatDict</code> does not contain <code>name</code>, return <code>default</code>.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If <code>FlatDict</code> does not contain <code>name</code> and <code>default</code> is not specified.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict(d=1013)\n&gt;&gt;&gt; d.get('d')\n1013\n&gt;&gt;&gt; d['d']\n1013\n&gt;&gt;&gt; d.d\n1013\n&gt;&gt;&gt; d.get('d', None)\n1013\n&gt;&gt;&gt; d.get('f', 2)\n2\n&gt;&gt;&gt; d.get('f')\n&gt;&gt;&gt; d.get('f', Null)\nTraceback (most recent call last):\nKeyError: 'f'\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def get(self, name: Any, default: Any = None) -&gt; Any:\nr\"\"\"\n    Get value from `FlatDict`.\n    Args:\n        name:\n        default:\n    Returns:\n        value:\n            If `FlatDict` does not contain `name`, return `default`.\n    Raises:\n        KeyError: If `FlatDict` does not contain `name` and `default` is not specified.\n    Examples:\n        &gt;&gt;&gt; d = FlatDict(d=1013)\n        &gt;&gt;&gt; d.get('d')\n        1013\n        &gt;&gt;&gt; d['d']\n        1013\n        &gt;&gt;&gt; d.d\n        1013\n        &gt;&gt;&gt; d.get('d', None)\n        1013\n        &gt;&gt;&gt; d.get('f', 2)\n        2\n        &gt;&gt;&gt; d.get('f')\n        &gt;&gt;&gt; d.get('f', Null)\n        Traceback (most recent call last):\n        KeyError: 'f'\n    \"\"\"\nif name in self:\nreturn dict.__getitem__(self, name)\nif default is not Null:\nreturn default\nreturn self.__missing__(name)\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.set","title":"<code>set(name, value)</code>","text":"<p>Set value of <code>FlatDict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Any</code> required <code>value</code> <code>Any</code> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict()\n&gt;&gt;&gt; d.set('d', 1013)\n&gt;&gt;&gt; d.get('d')\n1013\n&gt;&gt;&gt; d['n'] = 'chang'\n&gt;&gt;&gt; d.n\n'chang'\n&gt;&gt;&gt; d.n = 'liu'\n&gt;&gt;&gt; d['n']\n'liu'\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def set(self, name: Any, value: Any) -&gt; None:\nr\"\"\"\n    Set value of `FlatDict`.\n    Args:\n        name:\n        value:\n    Examples:\n        &gt;&gt;&gt; d = FlatDict()\n        &gt;&gt;&gt; d.set('d', 1013)\n        &gt;&gt;&gt; d.get('d')\n        1013\n        &gt;&gt;&gt; d['n'] = 'chang'\n        &gt;&gt;&gt; d.n\n        'chang'\n        &gt;&gt;&gt; d.n = 'liu'\n        &gt;&gt;&gt; d['n']\n        'liu'\n    \"\"\"\nif name in self and isinstance(self.get(name), Variable):\nself.get(name).set(value)\nelse:\ndict.__setitem__(self, name, value)\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.delete","title":"<code>delete(name)</code>","text":"<p>Delete value from <code>FlatDict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Any</code> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict(d=1016, n='chang')\n&gt;&gt;&gt; d.d\n1016\n&gt;&gt;&gt; d.n\n'chang'\n&gt;&gt;&gt; d.delete('d')\n&gt;&gt;&gt; d.d\nTraceback (most recent call last):\nAttributeError: 'FlatDict' object has no attribute 'd'\n&gt;&gt;&gt; del d.n\n&gt;&gt;&gt; d.n\nTraceback (most recent call last):\nAttributeError: 'FlatDict' object has no attribute 'n'\n&gt;&gt;&gt; del d.f\nTraceback (most recent call last):\nAttributeError: 'FlatDict' object has no attribute 'f'\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def delete(self, name: Any) -&gt; None:\nr\"\"\"\n    Delete value from `FlatDict`.\n    Args:\n        name:\n    Examples:\n        &gt;&gt;&gt; d = FlatDict(d=1016, n='chang')\n        &gt;&gt;&gt; d.d\n        1016\n        &gt;&gt;&gt; d.n\n        'chang'\n        &gt;&gt;&gt; d.delete('d')\n        &gt;&gt;&gt; d.d\n        Traceback (most recent call last):\n        AttributeError: 'FlatDict' object has no attribute 'd'\n        &gt;&gt;&gt; del d.n\n        &gt;&gt;&gt; d.n\n        Traceback (most recent call last):\n        AttributeError: 'FlatDict' object has no attribute 'n'\n        &gt;&gt;&gt; del d.f\n        Traceback (most recent call last):\n        AttributeError: 'FlatDict' object has no attribute 'f'\n    \"\"\"\ndict.__delitem__(self, name)\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.validate","title":"<code>validate()</code>","text":"<p>Validate if all <code>Variable</code> in <code>FlatDict</code> are valid.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>Variable</code> has invalid type.</p> <code>ValueError</code> <p>If <code>Variable</code> has invalid value.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict(d=Variable(1016, type=int), n=Variable('chang', validator=lambda x: x.islower()))\n&gt;&gt;&gt; d.validate()\n&gt;&gt;&gt; d = FlatDict(d=Variable(1016, type=str), n=Variable('chang', validator=lambda x: x.islower()))\n&gt;&gt;&gt; d.validate()\nTraceback (most recent call last):\nTypeError: 'd' has invalid type. Value 1016 is not of type &lt;class 'str'&gt;.\n&gt;&gt;&gt; d = FlatDict(d=Variable(1016, type=int), n=Variable('chang', validator=lambda x: x.isupper()))\n&gt;&gt;&gt; d.validate()\nTraceback (most recent call last):\nValueError: 'n' has invalid value. Value chang is not valid.\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def validate(self) -&gt; None:\nr\"\"\"\n    Validate if all `Variable` in `FlatDict` are valid.\n    Raises:\n        TypeError: If `Variable` has invalid type.\n        ValueError: If `Variable` has invalid value.\n    Examples:\n        &gt;&gt;&gt; d = FlatDict(d=Variable(1016, type=int), n=Variable('chang', validator=lambda x: x.islower()))\n        &gt;&gt;&gt; d.validate()\n        &gt;&gt;&gt; d = FlatDict(d=Variable(1016, type=str), n=Variable('chang', validator=lambda x: x.islower()))\n        &gt;&gt;&gt; d.validate()\n        Traceback (most recent call last):\n        TypeError: 'd' has invalid type. Value 1016 is not of type &lt;class 'str'&gt;.\n        &gt;&gt;&gt; d = FlatDict(d=Variable(1016, type=int), n=Variable('chang', validator=lambda x: x.isupper()))\n        &gt;&gt;&gt; d.validate()\n        Traceback (most recent call last):\n        ValueError: 'n' has invalid value. Value chang is not valid.\n    \"\"\"\nfor name, value in self.all_items():\nif isinstance(value, Variable):\ntry:\nvalue.validate()\nexcept TypeError as exc:\nraise TypeError(f\"'{name}' has invalid type. {exc}\") from None\nexcept ValueError as exc:\nraise ValueError(f\"'{name}' has invalid value. {exc}\") from None\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.getattr","title":"<code>getattr(name, default=Null)</code>","text":"<p>Get attribute of <code>FlatDict</code>.</p> <p>Note that it won\u2019t retrieve value in <code>FlatDict</code>,</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required <code>default</code> <code>Any</code> <code>Null</code> <p>Returns:</p> Name Type Description <code>value</code> <code>Any</code> <p>If <code>FlatDict</code> does not contain <code>name</code>, return <code>default</code>.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>FlatDict</code> does not contain <code>name</code> and <code>default</code> is not specified.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict(a=1)\n&gt;&gt;&gt; d.get('a')\n1\n&gt;&gt;&gt; d.getattr('a')\nTraceback (most recent call last):\nAttributeError: 'FlatDict' object has no attribute 'a'\n&gt;&gt;&gt; d.getattr('b', 2)\n2\n&gt;&gt;&gt; d.setattr('b', 3)\n&gt;&gt;&gt; d.getattr('b')\n3\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def getattr(self, name: str, default: Any = Null) -&gt; Any:\nr\"\"\"\n    Get attribute of `FlatDict`.\n    Note that it won't retrieve value in `FlatDict`,\n    Args:\n        name:\n        default:\n    Returns:\n        value: If `FlatDict` does not contain `name`, return `default`.\n    Raises:\n        AttributeError: If `FlatDict` does not contain `name` and `default` is not specified.\n    Examples:\n        &gt;&gt;&gt; d = FlatDict(a=1)\n        &gt;&gt;&gt; d.get('a')\n        1\n        &gt;&gt;&gt; d.getattr('a')\n        Traceback (most recent call last):\n        AttributeError: 'FlatDict' object has no attribute 'a'\n        &gt;&gt;&gt; d.getattr('b', 2)\n        2\n        &gt;&gt;&gt; d.setattr('b', 3)\n        &gt;&gt;&gt; d.getattr('b')\n        3\n    \"\"\"\ntry:\nif name in self.__dict__:\nreturn self.__dict__[name]\nif name in self.__class__.__dict__:\nreturn self.__class__.__dict__[name]\nreturn super().getattr(name, default)  # type: ignore\nexcept AttributeError:\nif default is not Null:\nreturn default\nraise AttributeError(f\"'{self.__class__.__name__}' object has no attribute '{name}'\") from None\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.setattr","title":"<code>setattr(name, value)</code>","text":"<p>Set attribute of <code>FlatDict</code>.</p> <p>Note that it won\u2019t alter values in <code>FlatDict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required <code>value</code> <code>Any</code> required <p>Warns:</p> Type Description <code>RuntimeWarning</code> <p>If name already exists in <code>FlatDict</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict()\n&gt;&gt;&gt; d.setattr('attr', 'value')\n&gt;&gt;&gt; d.getattr('attr')\n'value'\n&gt;&gt;&gt; d.set('d', 1013)\n&gt;&gt;&gt; d.setattr('d', 1031)  # RuntimeWarning: d already exists in FlatDict.\n&gt;&gt;&gt; d.get('d')\n1013\n&gt;&gt;&gt; d.d\n1013\n&gt;&gt;&gt; d.getattr('d')\n1031\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def setattr(self, name: str, value: Any) -&gt; None:\nr\"\"\"\n    Set attribute of `FlatDict`.\n    Note that it won't alter values in `FlatDict`.\n    Args:\n        name:\n        value:\n    Warns:\n        RuntimeWarning: If name already exists in `FlatDict`.\n    Examples:\n        &gt;&gt;&gt; d = FlatDict()\n        &gt;&gt;&gt; d.setattr('attr', 'value')\n        &gt;&gt;&gt; d.getattr('attr')\n        'value'\n        &gt;&gt;&gt; d.set('d', 1013)\n        &gt;&gt;&gt; d.setattr('d', 1031)  # RuntimeWarning: d already exists in FlatDict.\n        &gt;&gt;&gt; d.get('d')\n        1013\n        &gt;&gt;&gt; d.d\n        1013\n        &gt;&gt;&gt; d.getattr('d')\n        1031\n    \"\"\"\nif name in self:\nwarn(\nf\"{name} already exists in {self.__class__.__name__}.\\n\"\nf\"Users must call `{self.__class__.__name__}.getattr()` to retrieve conflicting attribute value.\",\nRuntimeWarning,\n)\nself.__dict__[name] = value\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.delattr","title":"<code>delattr(name)</code>","text":"<p>Delete attribute of <code>FlatDict</code>.</p> <p>Note that it won\u2019t delete values in <code>FlatDict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict()\n&gt;&gt;&gt; d.setattr('name', 'chang')\n&gt;&gt;&gt; d.getattr('name')\n'chang'\n&gt;&gt;&gt; d.delattr('name')\n&gt;&gt;&gt; d.getattr('name')\nTraceback (most recent call last):\nAttributeError: 'FlatDict' object has no attribute 'name'\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def delattr(self, name: str) -&gt; None:\nr\"\"\"\n    Delete attribute of `FlatDict`.\n    Note that it won't delete values in `FlatDict`.\n    Args:\n        name:\n    Examples:\n        &gt;&gt;&gt; d = FlatDict()\n        &gt;&gt;&gt; d.setattr('name', 'chang')\n        &gt;&gt;&gt; d.getattr('name')\n        'chang'\n        &gt;&gt;&gt; d.delattr('name')\n        &gt;&gt;&gt; d.getattr('name')\n        Traceback (most recent call last):\n        AttributeError: 'FlatDict' object has no attribute 'name'\n    \"\"\"\ndel self.__dict__[name]\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.hasattr","title":"<code>hasattr(name)</code>","text":"<p>Determine if an attribute exists in <code>FlatDict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict()\n&gt;&gt;&gt; d.setattr('name', 'chang')\n&gt;&gt;&gt; d.hasattr('name')\nTrue\n&gt;&gt;&gt; d.delattr('name')\n&gt;&gt;&gt; d.hasattr('name')\nFalse\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def hasattr(self, name: str) -&gt; bool:\nr\"\"\"\n    Determine if an attribute exists in `FlatDict`.\n    Args:\n        name:\n    Returns:\n        (bool):\n    Examples:\n        &gt;&gt;&gt; d = FlatDict()\n        &gt;&gt;&gt; d.setattr('name', 'chang')\n        &gt;&gt;&gt; d.hasattr('name')\n        True\n        &gt;&gt;&gt; d.delattr('name')\n        &gt;&gt;&gt; d.hasattr('name')\n        False\n    \"\"\"\ntry:\nif name in self.__dict__ or name in self.__class__.__dict__:\nreturn True\nreturn super().hasattr(name)  # type: ignore\nexcept AttributeError:\nreturn False\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.dict","title":"<code>dict(cls=dict)</code>","text":"<p>Convert <code>FlatDict</code> to other <code>Mapping</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Callable</code> <p>Target class to be converted to.</p> <code>dict</code> <p>Returns:</p> Type Description <code>Mapping</code> See Also <p><code>to_dict</code>: Implementation of <code>dict</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n&gt;&gt;&gt; d.dict()\n{'a': 1, 'b': 2, 'c': 3}\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def dict(self, cls: Callable = dict) -&gt; Mapping:\nr\"\"\"\n    Convert `FlatDict` to other `Mapping`.\n    Args:\n        cls: Target class to be converted to.\n    Returns:\n        (Mapping):\n    See Also:\n        [`to_dict`][chanfig.flat_dict.to_dict]: Implementation of `dict`.\n    Examples:\n        &gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n        &gt;&gt;&gt; d.dict()\n        {'a': 1, 'b': 2, 'c': 3}\n    \"\"\"\nreturn cls(to_dict(self))\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.from_dict","title":"<code>from_dict(obj)</code>  <code>classmethod</code>","text":"<p>Convert <code>Mapping</code> or <code>Sequence</code> to <code>FlatDict</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; FlatDict.from_dict({'a': 1, 'b': 2, 'c': 3})\nFlatDict(\n  ('a'): 1\n  ('b'): 2\n  ('c'): 3\n)\n&gt;&gt;&gt; FlatDict.from_dict([('a', 1), ('b', 2), ('c', 3)])\nFlatDict(\n  ('a'): 1\n  ('b'): 2\n  ('c'): 3\n)\n&gt;&gt;&gt; FlatDict.from_dict([{'a': 1}, {'b': 2}, {'c': 3}])\n[FlatDict(('a'): 1), FlatDict(('b'): 2), FlatDict(('c'): 3)]\n&gt;&gt;&gt; FlatDict.from_dict({1, 2, 3})\nTraceback (most recent call last):\nTypeError: Expected Mapping or Sequence, but got &lt;class 'set'&gt;.\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>@classmethod\ndef from_dict(cls, obj: Mapping | Sequence) -&gt; Any:  # pylint: disable=R0911\nr\"\"\"\n    Convert `Mapping` or `Sequence` to `FlatDict`.\n    Examples:\n        &gt;&gt;&gt; FlatDict.from_dict({'a': 1, 'b': 2, 'c': 3})\n        FlatDict(\n          ('a'): 1\n          ('b'): 2\n          ('c'): 3\n        )\n        &gt;&gt;&gt; FlatDict.from_dict([('a', 1), ('b', 2), ('c', 3)])\n        FlatDict(\n          ('a'): 1\n          ('b'): 2\n          ('c'): 3\n        )\n        &gt;&gt;&gt; FlatDict.from_dict([{'a': 1}, {'b': 2}, {'c': 3}])\n        [FlatDict(('a'): 1), FlatDict(('b'): 2), FlatDict(('c'): 3)]\n        &gt;&gt;&gt; FlatDict.from_dict({1, 2, 3})\n        Traceback (most recent call last):\n        TypeError: Expected Mapping or Sequence, but got &lt;class 'set'&gt;.\n    \"\"\"\nif isinstance(obj, Mapping):\nreturn cls(obj)\nif isinstance(obj, Sequence):\ntry:\nreturn cls(obj)\nexcept ValueError:\nreturn [cls(json) for json in obj]\nraise TypeError(f\"Expected Mapping or Sequence, but got {type(obj)}.\")\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.interpolate","title":"<code>interpolate(use_variable=True, interpolators=None)</code>","text":"<p>Perform Variable interpolation.</p> <p>Variable interpolation allows you to set the value of one key to be the value of another key easily.</p> <p>Parameters:</p> Name Type Description Default <code>use_variable</code> <code>bool</code> <p>Whether to convert values to <code>Variable</code> objects.</p> <code>True</code> <code>interpolators</code> <code>MutableMapping | None</code> <p>Mapping contains values for interpolation. Defaults to <code>self</code>.</p> <code>None</code> See Also <p>[Variable][<code>chanfig.Variable</code>]: Mutable wrapper of immutable objects.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict(a=1, b=\"${a}\", c=\"${b}\")\n&gt;&gt;&gt; d.dict()\n{'a': 1, 'b': '${a}', 'c': '${b}'}\n&gt;&gt;&gt; d.interpolate().dict()\n{'a': 1, 'b': 1, 'c': 1}\n&gt;&gt;&gt; isinstance(d.a, Variable)\nTrue\n&gt;&gt;&gt; d.a += 1\n&gt;&gt;&gt; d.dict()\n{'a': 2, 'b': 2, 'c': 2}\n&gt;&gt;&gt; d.a is d.b and d.b is d.c\nTrue\n&gt;&gt;&gt; d = FlatDict(a=1, b=\"${a}\", c=\"${b}\")\n&gt;&gt;&gt; d.dict()\n{'a': 1, 'b': '${a}', 'c': '${b}'}\n&gt;&gt;&gt; d.interpolate(False).dict()\n{'a': 1, 'b': 1, 'c': 1}\n&gt;&gt;&gt; isinstance(d.a, Variable)\nFalse\n&gt;&gt;&gt; d.a += 1\n&gt;&gt;&gt; d.dict()\n{'a': 2, 'b': 1, 'c': 1}\n&gt;&gt;&gt; d = FlatDict(a=1, b=\"${b}\", c=\"${b}\")\n&gt;&gt;&gt; d.interpolate().dict()\nTraceback (most recent call last):\nValueError: Invalid values: {'b': '${b}'}.\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def interpolate(self, use_variable: bool = True, interpolators: MutableMapping | None = None) -&gt; FlatDict:\nr\"\"\"\n    Perform Variable interpolation.\n    Variable interpolation allows you to set the value of one key to be the value of another key easily.\n    Args:\n        use_variable: Whether to convert values to `Variable` objects.\n        interpolators: Mapping contains values for interpolation. Defaults to `self`.\n    See Also:\n        [Variable][`chanfig.Variable`]: Mutable wrapper of immutable objects.\n    Examples:\n        &gt;&gt;&gt; d = FlatDict(a=1, b=\"${a}\", c=\"${b}\")\n        &gt;&gt;&gt; d.dict()\n        {'a': 1, 'b': '${a}', 'c': '${b}'}\n        &gt;&gt;&gt; d.interpolate().dict()\n        {'a': 1, 'b': 1, 'c': 1}\n        &gt;&gt;&gt; isinstance(d.a, Variable)\n        True\n        &gt;&gt;&gt; d.a += 1\n        &gt;&gt;&gt; d.dict()\n        {'a': 2, 'b': 2, 'c': 2}\n        &gt;&gt;&gt; d.a is d.b and d.b is d.c\n        True\n        &gt;&gt;&gt; d = FlatDict(a=1, b=\"${a}\", c=\"${b}\")\n        &gt;&gt;&gt; d.dict()\n        {'a': 1, 'b': '${a}', 'c': '${b}'}\n        &gt;&gt;&gt; d.interpolate(False).dict()\n        {'a': 1, 'b': 1, 'c': 1}\n        &gt;&gt;&gt; isinstance(d.a, Variable)\n        False\n        &gt;&gt;&gt; d.a += 1\n        &gt;&gt;&gt; d.dict()\n        {'a': 2, 'b': 1, 'c': 1}\n        &gt;&gt;&gt; d = FlatDict(a=1, b=\"${b}\", c=\"${b}\")\n        &gt;&gt;&gt; d.interpolate().dict()\n        Traceback (most recent call last):\n        ValueError: Invalid values: {'b': '${b}'}.\n    \"\"\"\ninterpolators = interpolators or self\ninterpolatees = {\nk: v[2:-1] for k, v in self.all_items() if isinstance(v, str) and v.startswith(\"${\") and v.endswith(\"}\")\n}\ninvalid_variables = {k: f\"${{{v}}}\" for k, v in interpolatees.items() if k == v}\nif invalid_variables:\nraise ValueError(f\"Invalid values: {invalid_variables}.\")\nif use_variable:\nfor value in list(set(interpolatees.values()).difference(interpolatees.keys())):\nif not isinstance(interpolators[value], Variable):\ninterpolators[value] = Variable(interpolators[value])\nfor key, value in interpolatees.items():\nself[key] = interpolators[value]\nreturn self\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.merge","title":"<code>merge(*args, overwrite=True, **kwargs)</code>","text":"<p>Merge <code>other</code> into <code>FlatDict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p><code>Mapping</code> or <code>Sequence</code> to be merged.</p> <code>()</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing values.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p><code>Mapping</code> to be merged.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>self</code> <code>FlatDict</code> <p>Alias:</p> <ul> <li><code>union</code></li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n&gt;&gt;&gt; n = {'b': 'b', 'c': 'c', 'd': 'd'}\n&gt;&gt;&gt; d.merge(n).dict()\n{'a': 1, 'b': 'b', 'c': 'c', 'd': 'd'}\n&gt;&gt;&gt; l = [('c', 3), ('d', 4)]\n&gt;&gt;&gt; d.merge(l).dict()\n{'a': 1, 'b': 'b', 'c': 3, 'd': 4}\n&gt;&gt;&gt; FlatDict(a=1, b=1, c=1).union(FlatDict(b='b', c='c', d='d')).dict()  # alias\n{'a': 1, 'b': 'b', 'c': 'c', 'd': 'd'}\n&gt;&gt;&gt; d = FlatDict()\n&gt;&gt;&gt; d.merge({1: 1, 2: 2, 3:3}).dict()\n{1: 1, 2: 2, 3: 3}\n&gt;&gt;&gt; d.merge(d.clone()).dict()\n{1: 1, 2: 2, 3: 3}\n&gt;&gt;&gt; d.merge({1:3, 2:1, 3: 2, 4: 4, 5: 5}, overwrite=False).dict()\n{1: 1, 2: 2, 3: 3, 4: 4, 5: 5}\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def merge(self, *args: Any, overwrite: bool = True, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n    Merge `other` into `FlatDict`.\n    Args:\n        *args: `Mapping` or `Sequence` to be merged.\n        overwrite: Whether to overwrite existing values.\n        **kwargs: `Mapping` to be merged.\n    Returns:\n        self:\n    **Alias**:\n    + `union`\n    Examples:\n        &gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n        &gt;&gt;&gt; n = {'b': 'b', 'c': 'c', 'd': 'd'}\n        &gt;&gt;&gt; d.merge(n).dict()\n        {'a': 1, 'b': 'b', 'c': 'c', 'd': 'd'}\n        &gt;&gt;&gt; l = [('c', 3), ('d', 4)]\n        &gt;&gt;&gt; d.merge(l).dict()\n        {'a': 1, 'b': 'b', 'c': 3, 'd': 4}\n        &gt;&gt;&gt; FlatDict(a=1, b=1, c=1).union(FlatDict(b='b', c='c', d='d')).dict()  # alias\n        {'a': 1, 'b': 'b', 'c': 'c', 'd': 'd'}\n        &gt;&gt;&gt; d = FlatDict()\n        &gt;&gt;&gt; d.merge({1: 1, 2: 2, 3:3}).dict()\n        {1: 1, 2: 2, 3: 3}\n        &gt;&gt;&gt; d.merge(d.clone()).dict()\n        {1: 1, 2: 2, 3: 3}\n        &gt;&gt;&gt; d.merge({1:3, 2:1, 3: 2, 4: 4, 5: 5}, overwrite=False).dict()\n        {1: 1, 2: 2, 3: 3, 4: 4, 5: 5}\n    \"\"\"\nif not args and not kwargs:\nreturn self\nif len(args) == 1:\nargs = args[0]\nif isinstance(args, (PathLike, str, bytes)):\nargs = self.load(args)  # type: ignore\nwarn(\n\"merge file is deprecated and maybe removed in a future release. Use `merge_from_file` instead.\",\nPendingDeprecationWarning,\n)\nself._merge(self, args, overwrite=overwrite)\nelse:\nself._merge(self, args, overwrite=overwrite)\nself._merge(self, kwargs, overwrite=overwrite)\nreturn self\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.union","title":"<code>union(*args, **kwargs)</code>","text":"<p>Alias of <code>merge</code>.</p> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def union(self, *args: Any, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n    Alias of [`merge`][chanfig.FlatDict.merge].\n    \"\"\"\nreturn self.merge(*args, **kwargs)\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.merge_from_file","title":"<code>merge_from_file(file, *args, **kwargs)</code>","text":"<p>Merge content of <code>file</code> into <code>FlatDict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>File</code> required <code>*args</code> <code>Any</code> <p>Passed to <code>load</code>.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Passed to <code>load</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>self</code> <code>FlatDict</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict(a=1, b=1)\n&gt;&gt;&gt; d.merge_from_file(\"tests/test.yaml\").dict()\n{'a': 1, 'b': 2, 'c': 3}\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def merge_from_file(self, file: File, *args: Any, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n    Merge content of `file` into `FlatDict`.\n    Args:\n        file (File):\n        *args: Passed to [`load`][chanfig.FlatDict.load].\n        **kwargs: Passed to [`load`][chanfig.FlatDict.load].\n    Returns:\n        self:\n    Examples:\n        &gt;&gt;&gt; d = FlatDict(a=1, b=1)\n        &gt;&gt;&gt; d.merge_from_file(\"tests/test.yaml\").dict()\n        {'a': 1, 'b': 2, 'c': 3}\n    \"\"\"\nreturn self.merge(self.load(file, *args, **kwargs))\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.intersect","title":"<code>intersect(other)</code>","text":"<p>Intersection of <code>FlatDict</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Mapping | Iterable | PathStr</code> required <p>Returns:</p> Type Description <code>FlatDict</code> <p>Alias:</p> <ul> <li><code>inter</code></li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n&gt;&gt;&gt; n = {'b': 'b', 'c': 'c', 'd': 'd'}\n&gt;&gt;&gt; d.intersect(n).dict()\n{}\n&gt;&gt;&gt; l = [('c', 3), ('d', 4)]\n&gt;&gt;&gt; d.intersect(l).dict()\n{'c': 3}\n&gt;&gt;&gt; d.merge(l).intersect(\"tests/test.yaml\").dict()\n{'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; d.intersect(1)\nTraceback (most recent call last):\nTypeError: `other=1` should be of type Mapping, Iterable or PathStr, but got &lt;class 'int'&gt;.\n&gt;&gt;&gt; d.inter(FlatDict(b='b', c='c', d='d')).dict()  # alias\n{}\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def intersect(self, other: Mapping | Iterable | PathStr) -&gt; FlatDict:\nr\"\"\"\n    Intersection of `FlatDict` and `other`.\n    Args:\n        other (Mapping | Iterable | PathStr):\n    Returns:\n        (FlatDict):\n    **Alias**:\n    + `inter`\n    Examples:\n        &gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n        &gt;&gt;&gt; n = {'b': 'b', 'c': 'c', 'd': 'd'}\n        &gt;&gt;&gt; d.intersect(n).dict()\n        {}\n        &gt;&gt;&gt; l = [('c', 3), ('d', 4)]\n        &gt;&gt;&gt; d.intersect(l).dict()\n        {'c': 3}\n        &gt;&gt;&gt; d.merge(l).intersect(\"tests/test.yaml\").dict()\n        {'a': 1, 'b': 2, 'c': 3}\n        &gt;&gt;&gt; d.intersect(1)\n        Traceback (most recent call last):\n        TypeError: `other=1` should be of type Mapping, Iterable or PathStr, but got &lt;class 'int'&gt;.\n        &gt;&gt;&gt; d.inter(FlatDict(b='b', c='c', d='d')).dict()  # alias\n        {}\n    \"\"\"\nif isinstance(other, (PathLike, str, bytes)):\nother = self.load(other)\nif isinstance(other, (Mapping,)):\nother = self.empty_like(other).items()\nif not isinstance(other, Iterable):\nraise TypeError(f\"`other={other}` should be of type Mapping, Iterable or PathStr, but got {type(other)}.\")\nreturn self.empty_like(\n**{key: value for key, value in other if key in self and self[key] == value}  # type: ignore\n)\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.inter","title":"<code>inter(other, *args, **kwargs)</code>","text":"<p>Alias of <code>intersect</code>.</p> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def inter(self, other: Mapping | Iterable | PathStr, *args: Any, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n    Alias of [`intersect`][chanfig.FlatDict.intersect].\n    \"\"\"\nreturn self.intersect(other, *args, **kwargs)\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.difference","title":"<code>difference(other)</code>","text":"<p>Difference between <code>FlatDict</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Mapping | Iterable | PathStr</code> required <p>Returns:</p> Type Description <code>FlatDict</code> <p>Alias:</p> <ul> <li><code>diff</code></li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n&gt;&gt;&gt; n = {'b': 'b', 'c': 'c', 'd': 'd'}\n&gt;&gt;&gt; d.difference(n).dict()\n{'b': 'b', 'c': 'c', 'd': 'd'}\n&gt;&gt;&gt; l = [('c', 3), ('d', 4)]\n&gt;&gt;&gt; d.difference(l).dict()\n{'d': 4}\n&gt;&gt;&gt; d.merge(l).difference(\"tests/test.yaml\").dict()\n{}\n&gt;&gt;&gt; d.difference(1)\nTraceback (most recent call last):\nTypeError: `other=1` should be of type Mapping, Iterable or PathStr, but got &lt;class 'int'&gt;.\n&gt;&gt;&gt; FlatDict(a=1, b=1, c=1).diff(FlatDict(b='b', c='c', d='d')).dict()  # alias\n{'b': 'b', 'c': 'c', 'd': 'd'}\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def difference(self, other: Mapping | Iterable | PathStr) -&gt; FlatDict:\nr\"\"\"\n    Difference between `FlatDict` and `other`.\n    Args:\n        other:\n    Returns:\n        (FlatDict):\n    **Alias**:\n    + `diff`\n    Examples:\n        &gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n        &gt;&gt;&gt; n = {'b': 'b', 'c': 'c', 'd': 'd'}\n        &gt;&gt;&gt; d.difference(n).dict()\n        {'b': 'b', 'c': 'c', 'd': 'd'}\n        &gt;&gt;&gt; l = [('c', 3), ('d', 4)]\n        &gt;&gt;&gt; d.difference(l).dict()\n        {'d': 4}\n        &gt;&gt;&gt; d.merge(l).difference(\"tests/test.yaml\").dict()\n        {}\n        &gt;&gt;&gt; d.difference(1)\n        Traceback (most recent call last):\n        TypeError: `other=1` should be of type Mapping, Iterable or PathStr, but got &lt;class 'int'&gt;.\n        &gt;&gt;&gt; FlatDict(a=1, b=1, c=1).diff(FlatDict(b='b', c='c', d='d')).dict()  # alias\n        {'b': 'b', 'c': 'c', 'd': 'd'}\n    \"\"\"\nif isinstance(other, (PathLike, str, bytes)):\nother = self.load(other)\nif isinstance(other, (Mapping,)):\nother = self.empty_like(other).items()\nif not isinstance(other, Iterable):\nraise TypeError(f\"`other={other}` should be of type Mapping, Iterable or PathStr, but got {type(other)}.\")\nreturn self.empty_like(\n**{key: value for key, value in other if key not in self or self[key] != value}  # type: ignore\n)\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.diff","title":"<code>diff(other, *args, **kwargs)</code>","text":"<p>Alias of <code>difference</code>.</p> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def diff(self, other: Mapping | Iterable | PathStr, *args: Any, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n    Alias of [`difference`][chanfig.FlatDict.difference].\n    \"\"\"\nreturn self.difference(other, *args, **kwargs)\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.to","title":"<code>to(cls)</code>","text":"<p>Convert values of <code>FlatDict</code> to target <code>cls</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>str | torch.device | torch.dtype</code> required <p>Returns:</p> Name Type Description <code>self</code> <code>FlatDict</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n&gt;&gt;&gt; d.to(int)\nTraceback (most recent call last):\nTypeError: to() only support torch.dtype and torch.device, but got &lt;class 'int'&gt;.\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def to(self, cls: str | TorchDevice | TorchDType) -&gt; FlatDict:  # pragma: no cover\nr\"\"\"\n    Convert values of `FlatDict` to target `cls`.\n    Args:\n        cls (str | torch.device | torch.dtype):\n    Returns:\n        self:\n    Examples:\n        &gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n        &gt;&gt;&gt; d.to(int)\n        Traceback (most recent call last):\n        TypeError: to() only support torch.dtype and torch.device, but got &lt;class 'int'&gt;.\n    \"\"\"\n# pylint: disable=C0103\nif isinstance(cls, (str, TorchDevice, TorchDType)):\nfor k, v in self.all_items():\nif hasattr(v, \"to\"):\nself[k] = v.to(cls)\nreturn self\nraise TypeError(f\"to() only support torch.dtype and torch.device, but got {cls}.\")\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.cpu","title":"<code>cpu()</code>","text":"<p>Move all tensors to cpu.</p> <p>Returns:</p> Name Type Description <code>self</code> <code>FlatDict</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; d = FlatDict(a=torch.tensor(1))\n&gt;&gt;&gt; d.cpu().dict()\n{'a': tensor(1, device='cpu')}\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def cpu(self) -&gt; FlatDict:  # pragma: no cover\nr\"\"\"\n    Move all tensors to cpu.\n    Returns:\n        self:\n    Examples:\n        &gt;&gt;&gt; import torch\n        &gt;&gt;&gt; d = FlatDict(a=torch.tensor(1))\n        &gt;&gt;&gt; d.cpu().dict()  # doctest: +SKIP\n        {'a': tensor(1, device='cpu')}\n    \"\"\"\nreturn self.to(TorchDevice(\"cpu\"))\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.gpu","title":"<code>gpu()</code>","text":"<p>Move all tensors to gpu.</p> <p>Returns:</p> Name Type Description <code>self</code> <code>FlatDict</code> <p>Alias:</p> <ul> <li><code>cuda</code></li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; d = FlatDict(a=torch.tensor(1))\n&gt;&gt;&gt; d.gpu().dict()\n{'a': tensor(1, device='cuda:0')}\n&gt;&gt;&gt; d.cuda().dict()  # alias\n{'a': tensor(1, device='cuda:0')}\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def gpu(self) -&gt; FlatDict:  # pragma: no cover\nr\"\"\"\n    Move all tensors to gpu.\n    Returns:\n        self:\n    **Alias**:\n    + `cuda`\n    Examples:\n        &gt;&gt;&gt; import torch\n        &gt;&gt;&gt; d = FlatDict(a=torch.tensor(1))\n        &gt;&gt;&gt; d.gpu().dict()  # doctest: +SKIP\n        {'a': tensor(1, device='cuda:0')}\n        &gt;&gt;&gt; d.cuda().dict()  # alias  # doctest: +SKIP\n        {'a': tensor(1, device='cuda:0')}\n    \"\"\"\nreturn self.to(TorchDevice(\"cuda\"))\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.cuda","title":"<code>cuda()</code>","text":"<p>Alias of <code>gpu</code>.</p> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def cuda(self) -&gt; FlatDict:  # pragma: no cover\nr\"\"\"\n    Alias of [`gpu`][chanfig.FlatDict.gpu].\n    \"\"\"\nreturn self.gpu()\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.tpu","title":"<code>tpu()</code>","text":"<p>Move all tensors to tpu.</p> <p>Returns:</p> Name Type Description <code>self</code> <code>FlatDict</code> <p>Alias:</p> <ul> <li><code>xla</code></li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; d = FlatDict(a=torch.tensor(1))\n&gt;&gt;&gt; d.tpu().dict()\n{'a': tensor(1, device='xla:0')}\n&gt;&gt;&gt; d.xla().dict()  # alias\n{'a': tensor(1, device='xla:0')}\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def tpu(self) -&gt; FlatDict:  # pragma: no cover\nr\"\"\"\n    Move all tensors to tpu.\n    Returns:\n        self:\n    **Alias**:\n    + `xla`\n    Examples:\n        &gt;&gt;&gt; import torch\n        &gt;&gt;&gt; d = FlatDict(a=torch.tensor(1))\n        &gt;&gt;&gt; d.tpu().dict()  # doctest: +SKIP\n        {'a': tensor(1, device='xla:0')}\n        &gt;&gt;&gt; d.xla().dict()  # alias  # doctest: +SKIP\n        {'a': tensor(1, device='xla:0')}\n    \"\"\"\nreturn self.to(TorchDevice(\"xla\"))\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.xla","title":"<code>xla()</code>","text":"<p>Alias of <code>tpu</code>.</p> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def xla(self) -&gt; FlatDict:  # pragma: no cover\nr\"\"\"\n    Alias of [`tpu`][chanfig.FlatDict.tpu].\n    \"\"\"\nreturn self.tpu()\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.copy","title":"<code>copy()</code>","text":"<p>Create a shallow copy of <code>FlatDict</code>.</p> <p>Returns:</p> Type Description <code>FlatDict</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict(a=[])\n&gt;&gt;&gt; d.setattr(\"name\", \"Chang\")\n&gt;&gt;&gt; c = d.copy()\n&gt;&gt;&gt; c.dict()\n{'a': []}\n&gt;&gt;&gt; d.a.append(1)\n&gt;&gt;&gt; c.dict()\n{'a': [1]}\n&gt;&gt;&gt; c.getattr(\"name\")\n'Chang'\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def copy(self) -&gt; FlatDict:\nr\"\"\"\n    Create a shallow copy of `FlatDict`.\n    Returns:\n        (FlatDict):\n    Examples:\n        &gt;&gt;&gt; d = FlatDict(a=[])\n        &gt;&gt;&gt; d.setattr(\"name\", \"Chang\")\n        &gt;&gt;&gt; c = d.copy()\n        &gt;&gt;&gt; c.dict()\n        {'a': []}\n        &gt;&gt;&gt; d.a.append(1)\n        &gt;&gt;&gt; c.dict()\n        {'a': [1]}\n        &gt;&gt;&gt; c.getattr(\"name\")\n        'Chang'\n    \"\"\"\nreturn copy(self)\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.deepcopy","title":"<code>deepcopy(memo=None)</code>","text":"<p>Create a deep copy of <code>FlatDict</code>.</p> <p>Returns:</p> Type Description <code>FlatDict</code> <p>Alias:</p> <ul> <li><code>clone</code></li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict(a=[])\n&gt;&gt;&gt; d.setattr(\"name\", \"Chang\")\n&gt;&gt;&gt; c = d.deepcopy()\n&gt;&gt;&gt; c.dict()\n{'a': []}\n&gt;&gt;&gt; d.a.append(1)\n&gt;&gt;&gt; c.dict()\n{'a': []}\n&gt;&gt;&gt; c.getattr(\"name\")\n'Chang'\n&gt;&gt;&gt; d == d.clone()  # alias\nTrue\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def deepcopy(self, memo: Mapping | None = None) -&gt; FlatDict:  # pylint: disable=W0613\nr\"\"\"\n    Create a deep copy of `FlatDict`.\n    Returns:\n        (FlatDict):\n    **Alias**:\n    + `clone`\n    Examples:\n        &gt;&gt;&gt; d = FlatDict(a=[])\n        &gt;&gt;&gt; d.setattr(\"name\", \"Chang\")\n        &gt;&gt;&gt; c = d.deepcopy()\n        &gt;&gt;&gt; c.dict()\n        {'a': []}\n        &gt;&gt;&gt; d.a.append(1)\n        &gt;&gt;&gt; c.dict()\n        {'a': []}\n        &gt;&gt;&gt; c.getattr(\"name\")\n        'Chang'\n        &gt;&gt;&gt; d == d.clone()  # alias\n        True\n    \"\"\"\nreturn deepcopy(self)\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.clone","title":"<code>clone(memo=None)</code>","text":"<p>Alias of <code>deepcopy</code>.</p> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def clone(self, memo: Mapping | None = None) -&gt; FlatDict:\nr\"\"\"\n    Alias of [`deepcopy`][chanfig.FlatDict.deepcopy].\n    \"\"\"\nreturn self.deepcopy(memo=memo)\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.save","title":"<code>save(file, method=None, *args, **kwargs)</code>","text":"<p>Save <code>FlatDict</code> to file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If save to <code>IO</code> and <code>method</code> is not specified.</p> <code>TypeError</code> <p>If save to unsupported extension.</p> <p>Alias:</p> <ul> <li><code>save</code></li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n&gt;&gt;&gt; d.save(\"tests/test.yaml\")\n&gt;&gt;&gt; d.save(\"test.conf\")\nTraceback (most recent call last):\nTypeError: `file='test.conf'` should be in ('json',) or ('yml', 'yaml'), but got conf.\n&gt;&gt;&gt; with open(\"test.yaml\", \"w\") as f:\n...     d.save(f)\nTraceback (most recent call last):\nValueError: `method` must be specified when saving to IO.\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def save(self, file: File, method: str | None = None, *args: Any, **kwargs: Any) -&gt; None:  # pylint: disable=W1113\nr\"\"\"\n    Save `FlatDict` to file.\n    Raises:\n        ValueError: If save to `IO` and `method` is not specified.\n        TypeError: If save to unsupported extension.\n    **Alias**:\n    + `save`\n    Examples:\n        &gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n        &gt;&gt;&gt; d.save(\"tests/test.yaml\")\n        &gt;&gt;&gt; d.save(\"test.conf\")\n        Traceback (most recent call last):\n        TypeError: `file='test.conf'` should be in ('json',) or ('yml', 'yaml'), but got conf.\n        &gt;&gt;&gt; with open(\"test.yaml\", \"w\") as f:\n        ...     d.save(f)\n        Traceback (most recent call last):\n        ValueError: `method` must be specified when saving to IO.\n    \"\"\"\nif method is None:\nif isinstance(file, (IOBase, IO)):\nraise ValueError(\"`method` must be specified when saving to IO.\")\nmethod = splitext(file)[-1][1:]  # type: ignore\nextension = method.lower()  # type: ignore\nif extension in YAML:\nreturn self.yaml(file=file, *args, **kwargs)  # type: ignore\nif extension in JSON:\nreturn self.json(file=file, *args, **kwargs)  # type: ignore\nraise TypeError(f\"`file={file!r}` should be in {JSON} or {YAML}, but got {extension}.\")\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.dump","title":"<code>dump(file, method=None, *args, **kwargs)</code>","text":"<p>Alias of <code>save</code>.</p> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def dump(self, file: File, method: str | None = None, *args: Any, **kwargs: Any) -&gt; None:  # pylint: disable=W1113\nr\"\"\"\n    Alias of [`save`][chanfig.FlatDict.save].\n    \"\"\"\nreturn self.save(file, method, *args, **kwargs)\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.load","title":"<code>load(file, method=None, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Load <code>FlatDict</code> from file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>File</code> <p>File to load from.</p> required <code>method</code> <code>str | None</code> <p>File type, should be in <code>JSON</code> or <code>YAML</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>FlatDict</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If load from <code>IO</code> and <code>method</code> is not specified.</p> <code>TypeError</code> <p>If dump to unsupported extension.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict.load(\"tests/test.yaml\")\n&gt;&gt;&gt; d.dict()\n{'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; d.load(\"tests/test.conf\")\nTraceback (most recent call last):\nTypeError: `file='tests/test.conf'` should be in ('json',) or ('yml', 'yaml'), but got conf.\n&gt;&gt;&gt; with open(\"tests/test.yaml\") as f:\n...     d.load(f)\nTraceback (most recent call last):\nValueError: `method` must be specified when loading from IO.\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>@classmethod\ndef load(  # pylint: disable=W1113\ncls, file: File, method: str | None = None, *args: Any, **kwargs: Any\n) -&gt; FlatDict:\n\"\"\"\n    Load `FlatDict` from file.\n    Args:\n        file: File to load from.\n        method: File type, should be in `JSON` or `YAML`.\n    Returns:\n        (FlatDict):\n    Raises:\n        ValueError: If load from `IO` and `method` is not specified.\n        TypeError: If dump to unsupported extension.\n    Examples:\n        &gt;&gt;&gt; d = FlatDict.load(\"tests/test.yaml\")\n        &gt;&gt;&gt; d.dict()\n        {'a': 1, 'b': 2, 'c': 3}\n        &gt;&gt;&gt; d.load(\"tests/test.conf\")\n        Traceback (most recent call last):\n        TypeError: `file='tests/test.conf'` should be in ('json',) or ('yml', 'yaml'), but got conf.\n        &gt;&gt;&gt; with open(\"tests/test.yaml\") as f:\n        ...     d.load(f)\n        Traceback (most recent call last):\n        ValueError: `method` must be specified when loading from IO.\n    \"\"\"\nif method is None:\nif isinstance(file, (IOBase, IO)):\nraise ValueError(\"`method` must be specified when loading from IO.\")\nmethod = splitext(file)[-1][1:]  # type: ignore\nextension = method.lower()  # type: ignore\nif extension in JSON:\nreturn cls.from_json(file, *args, **kwargs)\nif extension in YAML:\nreturn cls.from_yaml(file, *args, **kwargs)\nraise TypeError(f\"`file={file!r}` should be in {JSON} or {YAML}, but got {extension}.\")\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.json","title":"<code>json(file, *args, **kwargs)</code>","text":"<p>Dump <code>FlatDict</code> to json file.</p> <p>This method internally calls <code>self.jsons()</code> to generate json string. You may overwrite <code>jsons</code> in case something is not json serializable.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n&gt;&gt;&gt; d.json(\"tests/test.json\")\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def json(self, file: File, *args: Any, **kwargs: Any) -&gt; None:\nr\"\"\"\n    Dump `FlatDict` to json file.\n    This method internally calls `self.jsons()` to generate json string.\n    You may overwrite `jsons` in case something is not json serializable.\n    Examples:\n        &gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n        &gt;&gt;&gt; d.json(\"tests/test.json\")\n    \"\"\"\nwith self.open(file, mode=\"w\") as fp:  # pylint: disable=C0103\nfp.write(self.jsons(*args, **kwargs))\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.from_json","title":"<code>from_json(file, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct <code>FlatDict</code> from json file.</p> <p>This method internally calls <code>self.from_jsons()</code> to construct object from json string. You may overwrite <code>from_jsons</code> in case something is not json serializable.</p> <p>Returns:</p> Type Description <code>FlatDict</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict.from_json('tests/test.json')\n&gt;&gt;&gt; d.dict()\n{'a': 1, 'b': 2, 'c': 3}\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>@classmethod\ndef from_json(cls, file: File, *args: Any, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n    Construct `FlatDict` from json file.\n    This method internally calls `self.from_jsons()` to construct object from json string.\n    You may overwrite `from_jsons` in case something is not json serializable.\n    Returns:\n        (FlatDict):\n    Examples:\n        &gt;&gt;&gt; d = FlatDict.from_json('tests/test.json')\n        &gt;&gt;&gt; d.dict()\n        {'a': 1, 'b': 2, 'c': 3}\n    \"\"\"\nwith cls.open(file) as fp:  # pylint: disable=C0103\nif isinstance(file, (IOBase, IO)):\nreturn cls.from_jsons(fp.getvalue(), *args, **kwargs)  # type: ignore\nreturn cls.from_jsons(fp.read(), *args, **kwargs)\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.jsons","title":"<code>jsons(*args, **kwargs)</code>","text":"<p>Dump <code>FlatDict</code> to json string.</p> <p>Returns:</p> Type Description <code>str</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n&gt;&gt;&gt; d.jsons()\n'{\\n  \"a\": 1,\\n  \"b\": 2,\\n  \"c\": 3\\n}'\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def jsons(self, *args: Any, **kwargs: Any) -&gt; str:\nr\"\"\"\n    Dump `FlatDict` to json string.\n    Returns:\n        (str):\n    Examples:\n        &gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n        &gt;&gt;&gt; d.jsons()\n        '{\\n  \"a\": 1,\\n  \"b\": 2,\\n  \"c\": 3\\n}'\n    \"\"\"\nkwargs.setdefault(\"cls\", JsonEncoder)\nkwargs.setdefault(\"indent\", self.getattr(\"indent\", 2))\nreturn json_dumps(self.dict(), *args, **kwargs)\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.from_jsons","title":"<code>from_jsons(string, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct <code>FlatDict</code> from json string.</p> <p>Returns:</p> Type Description <code>FlatDict</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; FlatDict.from_jsons('{\\n  \"a\": 1,\\n  \"b\": 2,\\n  \"c\": 3\\n}').dict()\n{'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; FlatDict.from_jsons('[[\"a\", 1], [\"b\", 2], [\"c\", 3]]').dict()\n{'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; FlatDict.from_jsons('[{\"a\": 1}, {\"b\": 2}, {\"c\": 3}]')\n[FlatDict(('a'): 1), FlatDict(('b'): 2), FlatDict(('c'): 3)]\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>@classmethod\ndef from_jsons(cls, string: str, *args: Any, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n    Construct `FlatDict` from json string.\n    Returns:\n        (FlatDict):\n    Examples:\n        &gt;&gt;&gt; FlatDict.from_jsons('{\\n  \"a\": 1,\\n  \"b\": 2,\\n  \"c\": 3\\n}').dict()\n        {'a': 1, 'b': 2, 'c': 3}\n        &gt;&gt;&gt; FlatDict.from_jsons('[[\"a\", 1], [\"b\", 2], [\"c\", 3]]').dict()\n        {'a': 1, 'b': 2, 'c': 3}\n        &gt;&gt;&gt; FlatDict.from_jsons('[{\"a\": 1}, {\"b\": 2}, {\"c\": 3}]')\n        [FlatDict(('a'): 1), FlatDict(('b'): 2), FlatDict(('c'): 3)]\n    \"\"\"\nreturn cls.from_dict(json_loads(string, *args, **kwargs))\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.yaml","title":"<code>yaml(file, *args, **kwargs)</code>","text":"<p>Dump <code>FlatDict</code> to yaml file.</p> <p>This method internally calls <code>self.yamls()</code> to generate yaml string. You may overwrite <code>yamls</code> in case something is not yaml serializable.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n&gt;&gt;&gt; d.yaml(\"tests/test.yaml\")\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def yaml(self, file: File, *args: Any, **kwargs: Any) -&gt; None:\nr\"\"\"\n    Dump `FlatDict` to yaml file.\n    This method internally calls `self.yamls()` to generate yaml string.\n    You may overwrite `yamls` in case something is not yaml serializable.\n    Examples:\n        &gt;&gt;&gt; d = FlatDict(a=1, b=2, c=3)\n        &gt;&gt;&gt; d.yaml(\"tests/test.yaml\")\n    \"\"\"\nwith self.open(file, mode=\"w\") as fp:  # pylint: disable=C0103\nself.yamls(fp, *args, **kwargs)\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.from_yaml","title":"<code>from_yaml(file, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct <code>FlatDict</code> from yaml file.</p> <p>This method internally calls <code>self.from_yamls()</code> to construct object from yaml string. You may overwrite <code>from_yamls</code> in case something is not yaml serializable.</p> <p>Returns:</p> Type Description <code>FlatDict</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; FlatDict.from_yaml('tests/test.yaml').dict()\n{'a': 1, 'b': 2, 'c': 3}\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>@classmethod\ndef from_yaml(cls, file: File, *args: Any, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n    Construct `FlatDict` from yaml file.\n    This method internally calls `self.from_yamls()` to construct object from yaml string.\n    You may overwrite `from_yamls` in case something is not yaml serializable.\n    Returns:\n        (FlatDict):\n    Examples:\n        &gt;&gt;&gt; FlatDict.from_yaml('tests/test.yaml').dict()\n        {'a': 1, 'b': 2, 'c': 3}\n    \"\"\"\nwith cls.open(file) as fp:  # pylint: disable=C0103\nif isinstance(file, (IOBase, IO)):\nreturn cls.from_yamls(fp.getvalue(), *args, **kwargs)  # type: ignore\nreturn cls.from_yamls(fp.read(), *args, **kwargs)\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.yamls","title":"<code>yamls(*args, **kwargs)</code>","text":"<p>Dump <code>FlatDict</code> to yaml string.</p> <p>Returns:</p> Type Description <code>str</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; FlatDict(a=1, b=2, c=3).yamls()\n'a: 1\\nb: 2\\nc: 3\\n'\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def yamls(self, *args: Any, **kwargs: Any) -&gt; str:\nr\"\"\"\n    Dump `FlatDict` to yaml string.\n    Returns:\n        (str):\n    Examples:\n        &gt;&gt;&gt; FlatDict(a=1, b=2, c=3).yamls()\n        'a: 1\\nb: 2\\nc: 3\\n'\n    \"\"\"\nkwargs.setdefault(\"Dumper\", YamlDumper)\nkwargs.setdefault(\"indent\", self.getattr(\"indent\", 2))\nreturn yaml_dump(self.dict(), *args, **kwargs)  # type: ignore\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.from_yamls","title":"<code>from_yamls(string, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct <code>FlatDict</code> from yaml string.</p> <p>Returns:</p> Type Description <code>FlatDict</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; FlatDict.from_yamls('a: 1\\nb: 2\\nc: 3\\n').dict()\n{'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; FlatDict.from_yamls('- - a\\n  - 1\\n- - b\\n  - 2\\n- - c\\n  - 3\\n').dict()\n{'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; FlatDict.from_yamls('- a: 1\\n- b: 2\\n- c: 3\\n')\n[FlatDict(('a'): 1), FlatDict(('b'): 2), FlatDict(('c'): 3)]\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>@classmethod\ndef from_yamls(cls, string: str, *args: Any, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n    Construct `FlatDict` from yaml string.\n    Returns:\n        (FlatDict):\n    Examples:\n        &gt;&gt;&gt; FlatDict.from_yamls('a: 1\\nb: 2\\nc: 3\\n').dict()\n        {'a': 1, 'b': 2, 'c': 3}\n        &gt;&gt;&gt; FlatDict.from_yamls('- - a\\n  - 1\\n- - b\\n  - 2\\n- - c\\n  - 3\\n').dict()\n        {'a': 1, 'b': 2, 'c': 3}\n        &gt;&gt;&gt; FlatDict.from_yamls('- a: 1\\n- b: 2\\n- c: 3\\n')\n        [FlatDict(('a'): 1), FlatDict(('b'): 2), FlatDict(('c'): 3)]\n    \"\"\"\nkwargs.setdefault(\"Loader\", YamlLoader)\nreturn cls.from_dict(yaml_load(string, *args, **kwargs))\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.open","title":"<code>open(file, *args, encoding='utf-8', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Open file IO from file path or IO.</p> <p>This methods extends the ability of built-in <code>open</code> by allowing it to accept an <code>IOBase</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>File</code> <p>File path or IO.</p> required <code>*args</code> <code>Any</code> <p>Additional arguments passed to <code>open</code>. Defaults to ().</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Any Additional keyword arguments passed to <code>open</code>. Defaults to {}.</p> <code>{}</code> <p>Yields:</p> Type Description <code>Generator[IOBase | IO, Any, Any]</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; with FlatDict.open(\"tests/test.yaml\") as fp:\n...     print(fp.read())\na: 1\nb: 2\nc: 3\n&gt;&gt;&gt; io = open(\"tests/test.yaml\")\n&gt;&gt;&gt; with FlatDict.open(io) as fp:\n...     print(fp.read())\na: 1\nb: 2\nc: 3\n&gt;&gt;&gt; with FlatDict.open(123, mode=\"w\") as fp:\n...     print(fp.read())\nTraceback (most recent call last):\nTypeError: expected str, bytes, os.PathLike, IO or IOBase, not int\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>@staticmethod\n@contextmanager\ndef open(file: File, *args: Any, encoding: str = \"utf-8\", **kwargs: Any) -&gt; Generator[IOBase | IO, Any, Any]:\nr\"\"\"\n    Open file IO from file path or IO.\n    This methods extends the ability of built-in `open` by allowing it to accept an `IOBase` object.\n    Args:\n        file: File path or IO.\n        *args: Additional arguments passed to `open`.\n            Defaults to ().\n        **kwargs: Any\n            Additional keyword arguments passed to `open`.\n            Defaults to {}.\n    Yields:\n        (Generator[IOBase | IO, Any, Any]):\n    Examples:\n        &gt;&gt;&gt; with FlatDict.open(\"tests/test.yaml\") as fp:\n        ...     print(fp.read())\n        a: 1\n        b: 2\n        c: 3\n        &lt;BLANKLINE&gt;\n        &gt;&gt;&gt; io = open(\"tests/test.yaml\")\n        &gt;&gt;&gt; with FlatDict.open(io) as fp:\n        ...     print(fp.read())\n        a: 1\n        b: 2\n        c: 3\n        &lt;BLANKLINE&gt;\n        &gt;&gt;&gt; with FlatDict.open(123, mode=\"w\") as fp:\n        ...     print(fp.read())\n        Traceback (most recent call last):\n        TypeError: expected str, bytes, os.PathLike, IO or IOBase, not int\n    \"\"\"\nif isinstance(file, (IOBase, IO)):\nyield file\nelif isinstance(file, (PathLike, str, bytes)):\ntry:\nfile = open(file, *args, encoding=encoding, **kwargs)  # type: ignore # noqa: SIM115\nyield file  # type: ignore\nfinally:\nfile.close()  # type: ignore\nelse:\nraise TypeError(f\"expected str, bytes, os.PathLike, IO or IOBase, not {type(file).__name__}\")\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.empty","title":"<code>empty(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialise an empty <code>FlatDict</code>.</p> <p>This method is helpful when you inheriting <code>FlatDict</code> with default values defined in <code>__init__()</code>. As use <code>type(self)()</code> in this case would copy all the default values, which might not be desired.</p> <p>This method will preserve everything in <code>FlatDict.__class__.__dict__</code>.</p> <p>Returns:</p> Type Description <code>FlatDict</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict(a=[])\n&gt;&gt;&gt; c = d.empty()\n&gt;&gt;&gt; c.dict()\n{}\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>@classmethod\ndef empty(cls, *args: Any, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n    Initialise an empty `FlatDict`.\n    This method is helpful when you inheriting `FlatDict` with default values defined in `__init__()`.\n    As use `type(self)()` in this case would copy all the default values, which might not be desired.\n    This method will preserve everything in `FlatDict.__class__.__dict__`.\n    Returns:\n        (FlatDict):\n    Examples:\n        &gt;&gt;&gt; d = FlatDict(a=[])\n        &gt;&gt;&gt; c = d.empty()\n        &gt;&gt;&gt; c.dict()\n        {}\n    \"\"\"\nempty = cls.__new__(cls)\nempty.merge(*args, **kwargs)  # pylint: disable=W0212\nreturn empty\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.empty_like","title":"<code>empty_like(*args, **kwargs)</code>","text":"<p>Initialise an empty copy of <code>FlatDict</code>.</p> <p>This method will preserve everything in <code>FlatDict.__class__.__dict__</code> and <code>FlatDict.__dict__</code>.</p> <p>Returns:</p> Type Description <code>FlatDict</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict(a=[])\n&gt;&gt;&gt; d.setattr(\"name\", \"Chang\")\n&gt;&gt;&gt; c = d.empty_like()\n&gt;&gt;&gt; c.dict()\n{}\n&gt;&gt;&gt; c.getattr(\"name\")\n'Chang'\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def empty_like(self, *args: Any, **kwargs: Any) -&gt; FlatDict:\nr\"\"\"\n    Initialise an empty copy of `FlatDict`.\n    This method will preserve everything in `FlatDict.__class__.__dict__` and `FlatDict.__dict__`.\n    Returns:\n        (FlatDict):\n    Examples:\n        &gt;&gt;&gt; d = FlatDict(a=[])\n        &gt;&gt;&gt; d.setattr(\"name\", \"Chang\")\n        &gt;&gt;&gt; c = d.empty_like()\n        &gt;&gt;&gt; c.dict()\n        {}\n        &gt;&gt;&gt; c.getattr(\"name\")\n        'Chang'\n    \"\"\"\nempty = self.empty(*args, **kwargs)\nempty.__dict__.update(self.__dict__)\nreturn empty\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.all_keys","title":"<code>all_keys()</code>","text":"<p>Equivalent to <code>keys</code>.</p> <p>This method is provided solely to make methods work on both <code>FlatDict</code> and <code>NestedDict</code>.</p> See Also <p><code>all_keys</code></p> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def all_keys(self) -&gt; Generator:\nr\"\"\"\n    Equivalent to `keys`.\n    This method is provided solely to make methods work on both `FlatDict` and `NestedDict`.\n    See Also:\n        [`all_keys`][chanfig.NestedDict.all_keys]\n    \"\"\"\nyield from self.keys()\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.all_values","title":"<code>all_values()</code>","text":"<p>Equivalent to <code>keys</code>.</p> <p>This method is provided solely to make methods work on both <code>FlatDict</code> and <code>NestedDict</code>.</p> See Also <p><code>all_values</code></p> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def all_values(self) -&gt; Generator:\nr\"\"\"\n    Equivalent to `keys`.\n    This method is provided solely to make methods work on both `FlatDict` and `NestedDict`.\n    See Also:\n        [`all_values`][chanfig.NestedDict.all_values]\n    \"\"\"\nyield from self.values()\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.all_items","title":"<code>all_items()</code>","text":"<p>Equivalent to <code>keys</code>.</p> <p>This method is provided solely to make methods work on both <code>FlatDict</code> and <code>NestedDict</code>.</p> See Also <p><code>all_items</code></p> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def all_items(self) -&gt; Generator:\nr\"\"\"\n    Equivalent to `keys`.\n    This method is provided solely to make methods work on both `FlatDict` and `NestedDict`.\n    See Also:\n        [`all_items`][chanfig.NestedDict.all_items]\n    \"\"\"\nyield from self.items()\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.dropnull","title":"<code>dropnull()</code>","text":"<p>Drop key-value pairs with <code>Null</code> value.</p> <p>Returns:</p> Type Description <code>FlatDict</code> <p>Alias:</p> <ul> <li><code>dropna</code></li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = FlatDict(a=Null, b=Null, c=3)\n&gt;&gt;&gt; d.dict()\n{'a': Null, 'b': Null, 'c': 3}\n&gt;&gt;&gt; d.dropnull().dict()\n{'c': 3}\n&gt;&gt;&gt; d.dropna().dict()  # alias\n{'c': 3}\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def dropnull(self) -&gt; FlatDict:\nr\"\"\"\n    Drop key-value pairs with `Null` value.\n    Returns:\n        (FlatDict):\n    **Alias**:\n    + `dropna`\n    Examples:\n        &gt;&gt;&gt; d = FlatDict(a=Null, b=Null, c=3)\n        &gt;&gt;&gt; d.dict()\n        {'a': Null, 'b': Null, 'c': 3}\n        &gt;&gt;&gt; d.dropnull().dict()\n        {'c': 3}\n        &gt;&gt;&gt; d.dropna().dict()  # alias\n        {'c': 3}\n    \"\"\"\nreturn self.empty_like({k: v for k, v in self.all_items() if v is not Null})\n</code></pre>"},{"location":"flat_dict/#chanfig.flat_dict.FlatDict.dropna","title":"<code>dropna()</code>","text":"<p>Alias of <code>dropnull</code>.</p> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def dropna(self) -&gt; FlatDict:\nr\"\"\"\n    Alias of [`dropnull`][chanfig.FlatDict.dropnull].\n    \"\"\"\nreturn self.dropnull()\n</code></pre>"},{"location":"nested_dict/","title":"NestedDict","text":"<p>             Bases: <code>DefaultDict[_K, _V]</code></p> <p><code>NestedDict</code> further extends <code>DefaultDict</code> object by introducing a nested structure with <code>delimiter</code>. By default, <code>delimiter</code> is <code>.</code>, but it could be modified in subclass or by calling <code>dict.setattr('delimiter', D)</code>.</p> <p><code>d = NestedDict({\"a.b.c\": 1})</code> is equivalent to <code>d = NestedDict({\"a\": {\"b\": {\"c\": 1}}})</code>, and you can access members either by <code>d[\"a.b.c\"]</code> or more simply by <code>d.a.b.c</code>.</p> <p>This behavior allows you to pass keyword arguments to other functions as easy as <code>func1(**d.func1)</code>.</p> <p>Since <code>NestedDict</code> inherits from <code>DefaultDict</code>, it also supports <code>default_factory</code>. With <code>default_factory</code>, you can assign <code>d.a.b.c = 1</code> without assign <code>d.a = NestedDict()</code> in the first place. Note that the constructor of <code>NestedDict</code> is different from <code>DefaultDict</code>, <code>default_factory</code> is not a positional argument, and must be set in a keyword argument.</p> <p><code>NestedDict</code> also introduce <code>all_keys</code>, <code>all_values</code>, <code>all_items</code> methods to get all keys, values, items respectively in the nested structure.</p> <p>Attributes:</p> Name Type Description <code>convert_mapping</code> <code>bool</code> <p>bool = False If <code>True</code>, all new values with type of <code>Mapping</code> will be converted to <code>default_factory</code>. If <code>default_factory</code> is <code>Null</code>, will create an empty instance via <code>self.empty_like</code> as <code>default_factory</code>.</p> <code>delimiter</code> <code>str</code> <p>str = \u201c.\u201d Delimiter for nested structure.</p> Notes <p>When <code>convert_mapping</code> specified, all new values with type of <code>Mapping</code> will be converted to <code>default_factory</code>. If <code>default_factory</code> is <code>Null</code>, will create an empty instance via <code>self.empty_like</code> as <code>default_factory</code>.</p> <p><code>convert_mapping</code> is automatically applied to arguments during initialisation.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; NestedDict({\"f.n\": \"chang\"})\nNestedDict(\n  ('f'): NestedDict(\n    ('n'): 'chang'\n  )\n)\n&gt;&gt;&gt; d = NestedDict({\"f.n\": \"chang\"}, default_factory=NestedDict)\n&gt;&gt;&gt; d.i.d = 1013\n&gt;&gt;&gt; d['i.d']\n1013\n&gt;&gt;&gt; d.i.d\n1013\n&gt;&gt;&gt; d.dict()\n{'f': {'n': 'chang'}, 'i': {'d': 1013}}\n</code></pre> Source code in <code>chanfig/nested_dict.py</code> Python<pre><code>class NestedDict(DefaultDict[_K, _V]):  # pylint: disable=E1136\nr\"\"\"\n    `NestedDict` further extends `DefaultDict` object by introducing a nested structure with `delimiter`.\n    By default, `delimiter` is `.`, but it could be modified in subclass or by calling `dict.setattr('delimiter', D)`.\n    `d = NestedDict({\"a.b.c\": 1})` is equivalent to `d = NestedDict({\"a\": {\"b\": {\"c\": 1}}})`,\n    and you can access members either by `d[\"a.b.c\"]` or more simply by `d.a.b.c`.\n    This behavior allows you to pass keyword arguments to other functions as easy as `func1(**d.func1)`.\n    Since `NestedDict` inherits from `DefaultDict`, it also supports `default_factory`.\n    With `default_factory`, you can assign `d.a.b.c = 1` without assign `d.a = NestedDict()` in the first place.\n    Note that the constructor of `NestedDict` is different from `DefaultDict`, `default_factory` is not a positional\n    argument, and must be set in a keyword argument.\n    `NestedDict` also introduce `all_keys`, `all_values`, `all_items` methods to get all keys, values, items\n    respectively in the nested structure.\n    Attributes:\n        convert_mapping: bool = False\n            If `True`, all new values with type of `Mapping` will be converted to `default_factory`.\n            If `default_factory` is `Null`, will create an empty instance via `self.empty_like` as `default_factory`.\n        delimiter: str = \".\"\n            Delimiter for nested structure.\n    Notes:\n        When `convert_mapping` specified, all new values with type of `Mapping` will be converted to `default_factory`.\n        If `default_factory` is `Null`, will create an empty instance via `self.empty_like` as `default_factory`.\n        `convert_mapping` is automatically applied to arguments during initialisation.\n    Examples:\n        &gt;&gt;&gt; NestedDict({\"f.n\": \"chang\"})\n        NestedDict(\n          ('f'): NestedDict(\n            ('n'): 'chang'\n          )\n        )\n        &gt;&gt;&gt; d = NestedDict({\"f.n\": \"chang\"}, default_factory=NestedDict)\n        &gt;&gt;&gt; d.i.d = 1013\n        &gt;&gt;&gt; d['i.d']\n        1013\n        &gt;&gt;&gt; d.i.d\n        1013\n        &gt;&gt;&gt; d.dict()\n        {'f': {'n': 'chang'}, 'i': {'d': 1013}}\n    \"\"\"\nconvert_mapping: bool = False\ndelimiter: str = \".\"\ndef __init__(\nself, *args: Any, default_factory: Callable | None = None, convert_mapping: bool = False, **kwargs: Any\n) -&gt; None:\nself.setattr(\"convert_mapping\", convert_mapping)\nsuper().__init__(default_factory)\nif args or kwargs:\nself.merge(*args, **kwargs)\ndef all_keys(self) -&gt; Generator:\nr\"\"\"\n        Get all keys of `NestedDict`.\n        Returns:\n            (Generator):\n        Examples:\n            &gt;&gt;&gt; d = NestedDict({'a': 1, 'b': {'c': 2, 'd': 3}})\n            &gt;&gt;&gt; list(d.all_keys())\n            ['a', 'b.c', 'b.d']\n        \"\"\"\ndelimiter = self.getattr(\"delimiter\", \".\")\n@wraps(self.all_keys)\ndef all_keys(self, prefix=\"\"):\nfor key, value in self.items():\nif prefix:\nkey = str(prefix) + str(delimiter) + str(key)\nif isinstance(value, NestedDict):\nyield from all_keys(value, key)\nelse:\nyield key\nreturn all_keys(self)\ndef all_values(self) -&gt; Generator:\nr\"\"\"\n        Get all values of `NestedDict`.\n        Returns:\n            (Generator):\n        Examples:\n            &gt;&gt;&gt; d = NestedDict({'a': 1, 'b': {'c': 2, 'd': 3}})\n            &gt;&gt;&gt; list(d.all_values())\n            [1, 2, 3]\n        \"\"\"\nfor value in self.values():\nif isinstance(value, NestedDict):\nyield from value.all_values()\nelse:\nyield value\ndef all_items(self) -&gt; Generator:\nr\"\"\"\n        Get all items of `NestedDict`.\n        Returns:\n            (Generator):\n        Examples:\n            &gt;&gt;&gt; d = NestedDict({'a': 1, 'b': {'c': 2, 'd': 3}})\n            &gt;&gt;&gt; list(d.all_items())\n            [('a', 1), ('b.c', 2), ('b.d', 3)]\n        \"\"\"\ndelimiter = self.getattr(\"delimiter\", \".\")\n@wraps(self.all_items)\ndef all_items(self, prefix=\"\"):\nfor key, value in self.items():\nif prefix:\nkey = str(prefix) + str(delimiter) + str(key)\nif isinstance(value, NestedDict):\nyield from all_items(value, key)\nelse:\nyield key, value\nreturn all_items(self)\ndef apply(self, func: Callable, *args: Any, **kwargs: Any) -&gt; NestedDict:\nr\"\"\"\n        Recursively apply a function to `NestedDict` and its children.\n        Note:\n            This method is meant for non-in-place modification of `obj`, for example, [`to`][chanfig.NestedDict.to].\n        Args:\n            func (Callable):\n        See Also:\n            [`apply_`][chanfig.NestedDict.apply_]: Apply an in-place operation.\n            [`apply`][chanfig.nested_dict.apply]: Implementation of `apply`.\n        tionples:\n            &gt;&gt;&gt; def func(d):\n            ...     if isinstance(d, NestedDict):\n            ...         d.t = 1\n            &gt;&gt;&gt; d = NestedDict()\n            &gt;&gt;&gt; d.a = NestedDict()\n            &gt;&gt;&gt; d.b = [NestedDict(),]\n            &gt;&gt;&gt; d.c = (NestedDict(),)\n            &gt;&gt;&gt; d.d = {NestedDict(),}\n            &gt;&gt;&gt; d.apply(func).dict()\n            {'a': {}, 'b': [{}], 'c': ({},), 'd': ({},)}\n        \"\"\"\nreturn apply(self, func, *args, **kwargs)\ndef apply_(self, func: Callable, *args: Any, **kwargs: Any) -&gt; NestedDict:\nr\"\"\"\n        Recursively apply a function to `NestedDict` and its children.\n        Note:\n            This method is meant for in-place modification of `obj`, for example, [`freeze`][chanfig.Config.freeze].\n        Args:\n            func (Callable):\n        See Also:\n            [`apply`][chanfig.NestedDict.apply]: Apply a non-in-place operation.\n            [`apply_`][chanfig.nested_dict.apply_]: Implementation of `apply_` method.\n        Examples:\n            &gt;&gt;&gt; def func(d):\n            ...     if isinstance(d, NestedDict):\n            ...         d.t = 1\n            &gt;&gt;&gt; d = NestedDict()\n            &gt;&gt;&gt; d.a = NestedDict()\n            &gt;&gt;&gt; d.b = [NestedDict(),]\n            &gt;&gt;&gt; d.c = (NestedDict(),)\n            &gt;&gt;&gt; d.d = {NestedDict(),}\n            &gt;&gt;&gt; d.apply_(func).dict()\n            {'a': {'t': 1}, 'b': [{'t': 1}], 'c': ({'t': 1},), 'd': ({'t': 1},), 't': 1}\n        \"\"\"\napply_(self, func, *args, **kwargs)\nreturn self\ndef get(self, name: Any, default: Any = Null) -&gt; Any:\nr\"\"\"\n        Get value from `NestedDict`.\n        Note that `default` has higher priority than `default_factory`.\n        Args:\n            name:\n            default:\n        Returns:\n            value:\n                If `NestedDict` does not contain `name`, return `default`.\n                If `default` is not specified, return `default_factory()`.\n        Raises:\n            KeyError: If `NestedDict` does not contain `name` and `default`/`default_factory` is not specified.\n        Examples:\n            &gt;&gt;&gt; d = NestedDict({\"i.d\": 1013}, default_factory=NestedDict)\n            &gt;&gt;&gt; d.get('i.d')\n            1013\n            &gt;&gt;&gt; d['i.d']\n            1013\n            &gt;&gt;&gt; d.i.d\n            1013\n            &gt;&gt;&gt; d.get('i.d', None)\n            1013\n            &gt;&gt;&gt; d.get('f', 2)\n            2\n            &gt;&gt;&gt; d.f\n            NestedDict(&lt;class 'chanfig.nested_dict.NestedDict'&gt;, )\n            &gt;&gt;&gt; del d.f\n            &gt;&gt;&gt; d = NestedDict({\"i.d\": 1013})\n            &gt;&gt;&gt; d.e\n            Traceback (most recent call last):\n            AttributeError: 'NestedDict' object has no attribute 'e'\n            &gt;&gt;&gt; d.e = {}\n            &gt;&gt;&gt; d.get('e.f')\n            Traceback (most recent call last):\n            KeyError: 'f'\n            &gt;&gt;&gt; d.get('e.f', 1)\n            1\n            &gt;&gt;&gt; d.e.f\n            Traceback (most recent call last):\n            AttributeError: 'dict' object has no attribute 'f'\n        \"\"\"\ndelimiter = self.getattr(\"delimiter\", \".\")\ntry:\nwhile isinstance(name, str) and delimiter in name:\nname, rest = name.split(delimiter, 1)\nself, name = self[name], rest  # pylint: disable=W0642\nexcept (AttributeError, TypeError):\nraise KeyError(name) from None\n# if value is a python dict\nif not isinstance(self, NestedDict):\nif name not in self and default is not Null:\nreturn default\nreturn self[name]\nreturn super().get(name, default)\ndef set(  # pylint: disable=W0221\nself,\nname: Any,\nvalue: Any,\nconvert_mapping: bool | None = None,\n) -&gt; None:\nr\"\"\"\n        Set value of `NestedDict`.\n        Args:\n            name:\n            value:\n            convert_mapping: Whether to convert `Mapping` to `NestedDict`.\n                Defaults to self.convert_mapping.\n        Examples:\n            &gt;&gt;&gt; d = NestedDict(default_factory=NestedDict)\n            &gt;&gt;&gt; d.set('i.d', 1013)\n            &gt;&gt;&gt; d.get('i.d')\n            1013\n            &gt;&gt;&gt; d.dict()\n            {'i': {'d': 1013}}\n            &gt;&gt;&gt; d['f.n'] = 'chang'\n            &gt;&gt;&gt; d.f.n\n            'chang'\n            &gt;&gt;&gt; d.n.l = 'liu'\n            &gt;&gt;&gt; d['n.l']\n            'liu'\n            &gt;&gt;&gt; d['f.n.e'] = \"error\"\n            Traceback (most recent call last):\n            ValueError: Cannot set `f.n.e` to `error`, as `f.n=chang`.\n            &gt;&gt;&gt; d['f.n.e.a'] = \"error\"\n            Traceback (most recent call last):\n            KeyError: 'e'\n            &gt;&gt;&gt; d.f.n.e.a = \"error\"\n            Traceback (most recent call last):\n            AttributeError: 'str' object has no attribute 'e'\n            &gt;&gt;&gt; d.setattr('convert_mapping', True)\n            &gt;&gt;&gt; d.a.b = {'c': {'d': 1}, 'e.f' : 2}\n            &gt;&gt;&gt; d.a.b.c.d\n            1\n            &gt;&gt;&gt; d['c.d'] = {'c': {'d': 1}, 'e.f' : 2}\n            &gt;&gt;&gt; d.c.d['e.f']\n            2\n            &gt;&gt;&gt; d.setattr('convert_mapping', False)\n            &gt;&gt;&gt; d.set('e.f', {'c': {'d': 1}, 'e.f' : 2}, convert_mapping=True)\n            &gt;&gt;&gt; d['e.f']['c.d']\n            1\n        \"\"\"\n# pylint: disable=W0642\nfull_name = name\nif convert_mapping is None:\nconvert_mapping = self.convert_mapping\ndelimiter = self.getattr(\"delimiter\", \".\")\ndefault_factory = self.getattr(\"default_factory\", self.empty_like)\ntry:\nwhile isinstance(name, str) and delimiter in name:\nname, rest = name.split(delimiter, 1)\nif name in dir(self) and isinstance(getattr(self.__class__, name), (property, cached_property)):\nself, name = getattr(self, name), rest\nelif name not in self and isinstance(self, Mapping):\ndefault = (\nself.__missing__(name, default_factory()) if hasattr(self, \"__missing__\") else default_factory()\n)\nself, name = default, rest\nelse:\nself, name = self[name], rest\nif isinstance(self, NestedDict):\ndefault_factory = self.getattr(\"default_factory\", self.empty_like)\nexcept (AttributeError, TypeError):\nraise KeyError(name) from None\nif convert_mapping and isinstance(value, Mapping):\nvalue = default_factory(value)\nif isinstance(self, NestedDict):\nsuper().set(name, value)\nelif isinstance(self, Mapping):\ndict.__setitem__(self, name, value)\nelse:\nraise ValueError(\nf\"Cannot set `{full_name}` to `{value}`, as `{delimiter.join(full_name.split(delimiter)[:-1])}={self}`.\"\n)\ndef delete(self, name: Any) -&gt; None:\nr\"\"\"\n        Delete value from `NestedDict`.\n        Args:\n            name:\n        Examples:\n            &gt;&gt;&gt; d = NestedDict({\"i.d\": 1013, \"f.n\": \"chang\"})\n            &gt;&gt;&gt; d.i.d\n            1013\n            &gt;&gt;&gt; d.f.n\n            'chang'\n            &gt;&gt;&gt; d.delete('i.d')\n            &gt;&gt;&gt; d.dict()\n            {'i': {}, 'f': {'n': 'chang'}}\n            &gt;&gt;&gt; d.i.d\n            Traceback (most recent call last):\n            AttributeError: 'NestedDict' object has no attribute 'd'\n            &gt;&gt;&gt; del d.f.n\n            &gt;&gt;&gt; d.dict()\n            {'i': {}, 'f': {}}\n            &gt;&gt;&gt; d.f.n\n            Traceback (most recent call last):\n            AttributeError: 'NestedDict' object has no attribute 'n'\n            &gt;&gt;&gt; del d.e\n            Traceback (most recent call last):\n            AttributeError: 'NestedDict' object has no attribute 'e'\n            &gt;&gt;&gt; del d['f.n']\n            Traceback (most recent call last):\n            KeyError: 'n'\n            &gt;&gt;&gt; d.e = {'a': {'b': 1}}\n            &gt;&gt;&gt; del d['e.a.b']\n        \"\"\"\ndelimiter = self.getattr(\"delimiter\", \".\")\ntry:\nwhile isinstance(name, str) and delimiter in name:\nname, rest = name.split(delimiter, 1)\nself, name = self[name], rest  # pylint: disable=W0642\nexcept (AttributeError, TypeError):\nraise KeyError(name) from None\n# if value is a python dict\nif not isinstance(self, NestedDict):\ndel self[name]\nreturn\nsuper().delete(name)\ndef pop(self, name: Any, default: Any = Null) -&gt; Any:\nr\"\"\"\n        Pop value from `NestedDict`.\n        Args:\n            name:\n            default:\n        Returns:\n            value: If `NestedDict` does not contain `name`, return `default`.\n        Examples:\n            &gt;&gt;&gt; d = NestedDict({\"i.d\": 1013, \"f.n\": \"chang\", \"n.a.b.c\": 1}, default_factory=NestedDict)\n            &gt;&gt;&gt; d.pop('i.d')\n            1013\n            &gt;&gt;&gt; d.pop('i.d', True)\n            True\n            &gt;&gt;&gt; d.pop('i.d')\n            Traceback (most recent call last):\n            KeyError: 'd'\n            &gt;&gt;&gt; d.pop('e')\n            Traceback (most recent call last):\n            KeyError: 'e'\n            &gt;&gt;&gt; d.pop('e.f')\n            Traceback (most recent call last):\n            KeyError: 'f'\n        \"\"\"\ndelimiter = self.getattr(\"delimiter\", \".\")\ntry:\nwhile isinstance(name, str) and delimiter in name:\nname, rest = name.split(delimiter, 1)\nself, name = self[name], rest  # pylint: disable=W0642\nexcept (AttributeError, TypeError):\nraise KeyError(name) from None\nif not isinstance(self, dict) or name not in self:\nif default is not Null:\nreturn default\nraise KeyError(name)\nreturn super().pop(name)\n@staticmethod\ndef _merge(this: FlatDict, that: Iterable, overwrite: bool = True) -&gt; Mapping:\nif isinstance(that, Mapping):\nthat = that.items()\nfor key, value in that:\nif key in this and isinstance(this[key], Mapping):\nif isinstance(value, Mapping):\nNestedDict._merge(this[key], value, overwrite)\nelif isinstance(this, NestedDict):\nthis.set(key, value, convert_mapping=True)\nelif overwrite:\nthis[key] = value\nelif key in dir(this) and isinstance(getattr(this.__class__, key), (property, cached_property)):\ngetattr(this, key).merge(value, overwrite=overwrite)\nelif overwrite or key not in this:\nif isinstance(this, NestedDict):\nthis.set(key, value, convert_mapping=True)\nelse:\nthis[key] = value\nreturn this\ndef intersect(  # pylint: disable=W0221\nself, other: Mapping | Iterable | PathStr, recursive: bool = True\n) -&gt; NestedDict:\nr\"\"\"\n        Intersection of `NestedDict` and `other`.\n        Args:\n            other (Mapping | Iterable | PathStr):\n            recursive (bool):\n        Examples:\n            &gt;&gt;&gt; d = NestedDict({'a': 1, 'b.c': 2, 'b.d': 3, 'c.d.e': 4, 'c.d.f': 5, 'c.e': 6})\n            &gt;&gt;&gt; n = {'b': {'c': 3, 'd': 5}, 'c.d.e': 4, 'c.d': {'f': 5}, 'd': 0}\n            &gt;&gt;&gt; d.intersect(n).dict()\n            {'c': {'d': {'e': 4, 'f': 5}}}\n            &gt;&gt;&gt; d.intersect(\"tests/test.yaml\").dict()\n            {'a': 1}\n            &gt;&gt;&gt; d.intersect(n, recursive=False).dict()\n            {}\n            &gt;&gt;&gt; l = [('a', 1), ('d', 4)]\n            &gt;&gt;&gt; d.intersect(l).dict()\n            {'a': 1}\n            &gt;&gt;&gt; d.intersect(1)\n            Traceback (most recent call last):\n            TypeError: `other=1` should be of type Mapping, Iterable or PathStr, but got &lt;class 'int'&gt;.\n        \"\"\"\nif isinstance(other, (PathLike, str, bytes)):\nother = self.load(other)\nif isinstance(other, (Mapping,)):\nother = self.empty_like(other).items()\nif not isinstance(other, Iterable):\nraise TypeError(f\"`other={other}` should be of type Mapping, Iterable or PathStr, but got {type(other)}.\")\nreturn self.empty_like(self._intersect(self, other, recursive))  # type: ignore\n@staticmethod\ndef _intersect(this: NestedDict, that: Iterable, recursive: bool = True) -&gt; Mapping:\nret: NestedDict = NestedDict()\nfor key, value in that:\nif key in this:\nif isinstance(this[key], NestedDict) and isinstance(value, Mapping) and recursive:\nintersects = this[key].intersect(value)\nif intersects:\nret[key] = intersects\nelif this[key] == value:\nret[key] = value\nreturn ret\ndef difference(  # pylint: disable=W0221, C0103\nself, other: Mapping | Iterable | PathStr, recursive: bool = True\n) -&gt; NestedDict:\nr\"\"\"\n        Difference between `NestedDict` and `other`.\n        Args:\n            other (Mapping | Iterable | PathStr):\n            recursive (bool):\n        Examples:\n            &gt;&gt;&gt; d = NestedDict({'a': 1, 'b.c': 2, 'b.d': 3, 'c.d.e': 4, 'c.d.f': 5, 'c.e': 6})\n            &gt;&gt;&gt; n = {'b': {'c': 3, 'd': 5}, 'c.d.e': 4, 'c.d': {'f': 5}, 'd': 0}\n            &gt;&gt;&gt; d.difference(n).dict()\n            {'b': {'c': 3, 'd': 5}, 'd': 0}\n            &gt;&gt;&gt; d.difference(\"tests/test.yaml\").dict()\n            {'b': 2, 'c': 3}\n            &gt;&gt;&gt; d.difference(n, recursive=False).dict()\n            {'b': {'c': 3, 'd': 5}, 'c': {'d': {'e': 4, 'f': 5}}, 'd': 0}\n            &gt;&gt;&gt; l = [('a', 1), ('d', 4)]\n            &gt;&gt;&gt; d.difference(l).dict()\n            {'d': 4}\n            &gt;&gt;&gt; d.difference(1)\n            Traceback (most recent call last):\n            TypeError: `other=1` should be of type Mapping, Iterable or PathStr, but got &lt;class 'int'&gt;.\n        \"\"\"\nif isinstance(other, (PathLike, str, bytes)):\nother = self.load(other)\nif isinstance(other, (Mapping,)):\nother = self.empty_like(other).items()\nif not isinstance(other, Iterable):\nraise TypeError(f\"`other={other}` should be of type Mapping, Iterable or PathStr, but got {type(other)}.\")\nreturn self.empty_like(self._difference(self, other, recursive))  # type: ignore\n@staticmethod\ndef _difference(this: NestedDict, that: Iterable, recursive: bool = True) -&gt; Mapping:\nret: NestedDict = NestedDict()\nfor key, value in that:\nif key not in this:\nret[key] = value\nelif isinstance(this[key], NestedDict) and isinstance(value, Mapping) and recursive:\ndifferences = this[key].difference(value)\nif differences:\nret[key] = differences\nelif this[key] != value:\nret[key] = value\nreturn ret\ndef __contains__(self, name: Any) -&gt; bool:  # type: ignore\ndelimiter = self.getattr(\"delimiter\", \".\")\ntry:\nwhile isinstance(name, str) and delimiter in name:\nname, rest = name.split(delimiter, 1)\nif super().__contains__(name):\nself, name = self[name], rest  # pylint: disable=W0642\nelse:\nreturn False\nreturn super().__contains__(name)\nexcept (TypeError, KeyError):  # TypeError when name is not in self\nreturn False\n</code></pre>"},{"location":"nested_dict/#chanfig.nested_dict.NestedDict.all_keys","title":"<code>all_keys()</code>","text":"<p>Get all keys of <code>NestedDict</code>.</p> <p>Returns:</p> Type Description <code>Generator</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = NestedDict({'a': 1, 'b': {'c': 2, 'd': 3}})\n&gt;&gt;&gt; list(d.all_keys())\n['a', 'b.c', 'b.d']\n</code></pre> Source code in <code>chanfig/nested_dict.py</code> Python<pre><code>def all_keys(self) -&gt; Generator:\nr\"\"\"\n    Get all keys of `NestedDict`.\n    Returns:\n        (Generator):\n    Examples:\n        &gt;&gt;&gt; d = NestedDict({'a': 1, 'b': {'c': 2, 'd': 3}})\n        &gt;&gt;&gt; list(d.all_keys())\n        ['a', 'b.c', 'b.d']\n    \"\"\"\ndelimiter = self.getattr(\"delimiter\", \".\")\n@wraps(self.all_keys)\ndef all_keys(self, prefix=\"\"):\nfor key, value in self.items():\nif prefix:\nkey = str(prefix) + str(delimiter) + str(key)\nif isinstance(value, NestedDict):\nyield from all_keys(value, key)\nelse:\nyield key\nreturn all_keys(self)\n</code></pre>"},{"location":"nested_dict/#chanfig.nested_dict.NestedDict.all_values","title":"<code>all_values()</code>","text":"<p>Get all values of <code>NestedDict</code>.</p> <p>Returns:</p> Type Description <code>Generator</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = NestedDict({'a': 1, 'b': {'c': 2, 'd': 3}})\n&gt;&gt;&gt; list(d.all_values())\n[1, 2, 3]\n</code></pre> Source code in <code>chanfig/nested_dict.py</code> Python<pre><code>def all_values(self) -&gt; Generator:\nr\"\"\"\n    Get all values of `NestedDict`.\n    Returns:\n        (Generator):\n    Examples:\n        &gt;&gt;&gt; d = NestedDict({'a': 1, 'b': {'c': 2, 'd': 3}})\n        &gt;&gt;&gt; list(d.all_values())\n        [1, 2, 3]\n    \"\"\"\nfor value in self.values():\nif isinstance(value, NestedDict):\nyield from value.all_values()\nelse:\nyield value\n</code></pre>"},{"location":"nested_dict/#chanfig.nested_dict.NestedDict.all_items","title":"<code>all_items()</code>","text":"<p>Get all items of <code>NestedDict</code>.</p> <p>Returns:</p> Type Description <code>Generator</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = NestedDict({'a': 1, 'b': {'c': 2, 'd': 3}})\n&gt;&gt;&gt; list(d.all_items())\n[('a', 1), ('b.c', 2), ('b.d', 3)]\n</code></pre> Source code in <code>chanfig/nested_dict.py</code> Python<pre><code>def all_items(self) -&gt; Generator:\nr\"\"\"\n    Get all items of `NestedDict`.\n    Returns:\n        (Generator):\n    Examples:\n        &gt;&gt;&gt; d = NestedDict({'a': 1, 'b': {'c': 2, 'd': 3}})\n        &gt;&gt;&gt; list(d.all_items())\n        [('a', 1), ('b.c', 2), ('b.d', 3)]\n    \"\"\"\ndelimiter = self.getattr(\"delimiter\", \".\")\n@wraps(self.all_items)\ndef all_items(self, prefix=\"\"):\nfor key, value in self.items():\nif prefix:\nkey = str(prefix) + str(delimiter) + str(key)\nif isinstance(value, NestedDict):\nyield from all_items(value, key)\nelse:\nyield key, value\nreturn all_items(self)\n</code></pre>"},{"location":"nested_dict/#chanfig.nested_dict.NestedDict.apply","title":"<code>apply(func, *args, **kwargs)</code>","text":"<p>Recursively apply a function to <code>NestedDict</code> and its children.</p> Note <p>This method is meant for non-in-place modification of <code>obj</code>, for example, <code>to</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> required See Also <p><code>apply_</code>: Apply an in-place operation. <code>apply</code>: Implementation of <code>apply</code>.</p> tionples <p>def func(d): \u2026     if isinstance(d, NestedDict): \u2026         d.t = 1 d = NestedDict() d.a = NestedDict() d.b = [NestedDict(),] d.c = (NestedDict(),) d.d = {NestedDict(),} d.apply(func).dict() {\u2018a\u2019: {}, \u2018b\u2019: [{}], \u2018c\u2019: ({},), \u2018d\u2019: ({},)}</p> Source code in <code>chanfig/nested_dict.py</code> Python<pre><code>def apply(self, func: Callable, *args: Any, **kwargs: Any) -&gt; NestedDict:\nr\"\"\"\n    Recursively apply a function to `NestedDict` and its children.\n    Note:\n        This method is meant for non-in-place modification of `obj`, for example, [`to`][chanfig.NestedDict.to].\n    Args:\n        func (Callable):\n    See Also:\n        [`apply_`][chanfig.NestedDict.apply_]: Apply an in-place operation.\n        [`apply`][chanfig.nested_dict.apply]: Implementation of `apply`.\n    tionples:\n        &gt;&gt;&gt; def func(d):\n        ...     if isinstance(d, NestedDict):\n        ...         d.t = 1\n        &gt;&gt;&gt; d = NestedDict()\n        &gt;&gt;&gt; d.a = NestedDict()\n        &gt;&gt;&gt; d.b = [NestedDict(),]\n        &gt;&gt;&gt; d.c = (NestedDict(),)\n        &gt;&gt;&gt; d.d = {NestedDict(),}\n        &gt;&gt;&gt; d.apply(func).dict()\n        {'a': {}, 'b': [{}], 'c': ({},), 'd': ({},)}\n    \"\"\"\nreturn apply(self, func, *args, **kwargs)\n</code></pre>"},{"location":"nested_dict/#chanfig.nested_dict.NestedDict.apply_","title":"<code>apply_(func, *args, **kwargs)</code>","text":"<p>Recursively apply a function to <code>NestedDict</code> and its children.</p> Note <p>This method is meant for in-place modification of <code>obj</code>, for example, <code>freeze</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> required See Also <p><code>apply</code>: Apply a non-in-place operation. <code>apply_</code>: Implementation of <code>apply_</code> method.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; def func(d):\n...     if isinstance(d, NestedDict):\n...         d.t = 1\n&gt;&gt;&gt; d = NestedDict()\n&gt;&gt;&gt; d.a = NestedDict()\n&gt;&gt;&gt; d.b = [NestedDict(),]\n&gt;&gt;&gt; d.c = (NestedDict(),)\n&gt;&gt;&gt; d.d = {NestedDict(),}\n&gt;&gt;&gt; d.apply_(func).dict()\n{'a': {'t': 1}, 'b': [{'t': 1}], 'c': ({'t': 1},), 'd': ({'t': 1},), 't': 1}\n</code></pre> Source code in <code>chanfig/nested_dict.py</code> Python<pre><code>def apply_(self, func: Callable, *args: Any, **kwargs: Any) -&gt; NestedDict:\nr\"\"\"\n    Recursively apply a function to `NestedDict` and its children.\n    Note:\n        This method is meant for in-place modification of `obj`, for example, [`freeze`][chanfig.Config.freeze].\n    Args:\n        func (Callable):\n    See Also:\n        [`apply`][chanfig.NestedDict.apply]: Apply a non-in-place operation.\n        [`apply_`][chanfig.nested_dict.apply_]: Implementation of `apply_` method.\n    Examples:\n        &gt;&gt;&gt; def func(d):\n        ...     if isinstance(d, NestedDict):\n        ...         d.t = 1\n        &gt;&gt;&gt; d = NestedDict()\n        &gt;&gt;&gt; d.a = NestedDict()\n        &gt;&gt;&gt; d.b = [NestedDict(),]\n        &gt;&gt;&gt; d.c = (NestedDict(),)\n        &gt;&gt;&gt; d.d = {NestedDict(),}\n        &gt;&gt;&gt; d.apply_(func).dict()\n        {'a': {'t': 1}, 'b': [{'t': 1}], 'c': ({'t': 1},), 'd': ({'t': 1},), 't': 1}\n    \"\"\"\napply_(self, func, *args, **kwargs)\nreturn self\n</code></pre>"},{"location":"nested_dict/#chanfig.nested_dict.NestedDict.get","title":"<code>get(name, default=Null)</code>","text":"<p>Get value from <code>NestedDict</code>.</p> <p>Note that <code>default</code> has higher priority than <code>default_factory</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Any</code> required <code>default</code> <code>Any</code> <code>Null</code> <p>Returns:</p> Name Type Description <code>value</code> <code>Any</code> <p>If <code>NestedDict</code> does not contain <code>name</code>, return <code>default</code>. If <code>default</code> is not specified, return <code>default_factory()</code>.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If <code>NestedDict</code> does not contain <code>name</code> and <code>default</code>/<code>default_factory</code> is not specified.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = NestedDict({\"i.d\": 1013}, default_factory=NestedDict)\n&gt;&gt;&gt; d.get('i.d')\n1013\n&gt;&gt;&gt; d['i.d']\n1013\n&gt;&gt;&gt; d.i.d\n1013\n&gt;&gt;&gt; d.get('i.d', None)\n1013\n&gt;&gt;&gt; d.get('f', 2)\n2\n&gt;&gt;&gt; d.f\nNestedDict(&lt;class 'chanfig.nested_dict.NestedDict'&gt;, )\n&gt;&gt;&gt; del d.f\n&gt;&gt;&gt; d = NestedDict({\"i.d\": 1013})\n&gt;&gt;&gt; d.e\nTraceback (most recent call last):\nAttributeError: 'NestedDict' object has no attribute 'e'\n&gt;&gt;&gt; d.e = {}\n&gt;&gt;&gt; d.get('e.f')\nTraceback (most recent call last):\nKeyError: 'f'\n&gt;&gt;&gt; d.get('e.f', 1)\n1\n&gt;&gt;&gt; d.e.f\nTraceback (most recent call last):\nAttributeError: 'dict' object has no attribute 'f'\n</code></pre> Source code in <code>chanfig/nested_dict.py</code> Python<pre><code>def get(self, name: Any, default: Any = Null) -&gt; Any:\nr\"\"\"\n    Get value from `NestedDict`.\n    Note that `default` has higher priority than `default_factory`.\n    Args:\n        name:\n        default:\n    Returns:\n        value:\n            If `NestedDict` does not contain `name`, return `default`.\n            If `default` is not specified, return `default_factory()`.\n    Raises:\n        KeyError: If `NestedDict` does not contain `name` and `default`/`default_factory` is not specified.\n    Examples:\n        &gt;&gt;&gt; d = NestedDict({\"i.d\": 1013}, default_factory=NestedDict)\n        &gt;&gt;&gt; d.get('i.d')\n        1013\n        &gt;&gt;&gt; d['i.d']\n        1013\n        &gt;&gt;&gt; d.i.d\n        1013\n        &gt;&gt;&gt; d.get('i.d', None)\n        1013\n        &gt;&gt;&gt; d.get('f', 2)\n        2\n        &gt;&gt;&gt; d.f\n        NestedDict(&lt;class 'chanfig.nested_dict.NestedDict'&gt;, )\n        &gt;&gt;&gt; del d.f\n        &gt;&gt;&gt; d = NestedDict({\"i.d\": 1013})\n        &gt;&gt;&gt; d.e\n        Traceback (most recent call last):\n        AttributeError: 'NestedDict' object has no attribute 'e'\n        &gt;&gt;&gt; d.e = {}\n        &gt;&gt;&gt; d.get('e.f')\n        Traceback (most recent call last):\n        KeyError: 'f'\n        &gt;&gt;&gt; d.get('e.f', 1)\n        1\n        &gt;&gt;&gt; d.e.f\n        Traceback (most recent call last):\n        AttributeError: 'dict' object has no attribute 'f'\n    \"\"\"\ndelimiter = self.getattr(\"delimiter\", \".\")\ntry:\nwhile isinstance(name, str) and delimiter in name:\nname, rest = name.split(delimiter, 1)\nself, name = self[name], rest  # pylint: disable=W0642\nexcept (AttributeError, TypeError):\nraise KeyError(name) from None\n# if value is a python dict\nif not isinstance(self, NestedDict):\nif name not in self and default is not Null:\nreturn default\nreturn self[name]\nreturn super().get(name, default)\n</code></pre>"},{"location":"nested_dict/#chanfig.nested_dict.NestedDict.set","title":"<code>set(name, value, convert_mapping=None)</code>","text":"<p>Set value of <code>NestedDict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Any</code> required <code>value</code> <code>Any</code> required <code>convert_mapping</code> <code>bool | None</code> <p>Whether to convert <code>Mapping</code> to <code>NestedDict</code>. Defaults to self.convert_mapping.</p> <code>None</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = NestedDict(default_factory=NestedDict)\n&gt;&gt;&gt; d.set('i.d', 1013)\n&gt;&gt;&gt; d.get('i.d')\n1013\n&gt;&gt;&gt; d.dict()\n{'i': {'d': 1013}}\n&gt;&gt;&gt; d['f.n'] = 'chang'\n&gt;&gt;&gt; d.f.n\n'chang'\n&gt;&gt;&gt; d.n.l = 'liu'\n&gt;&gt;&gt; d['n.l']\n'liu'\n&gt;&gt;&gt; d['f.n.e'] = \"error\"\nTraceback (most recent call last):\nValueError: Cannot set `f.n.e` to `error`, as `f.n=chang`.\n&gt;&gt;&gt; d['f.n.e.a'] = \"error\"\nTraceback (most recent call last):\nKeyError: 'e'\n&gt;&gt;&gt; d.f.n.e.a = \"error\"\nTraceback (most recent call last):\nAttributeError: 'str' object has no attribute 'e'\n&gt;&gt;&gt; d.setattr('convert_mapping', True)\n&gt;&gt;&gt; d.a.b = {'c': {'d': 1}, 'e.f' : 2}\n&gt;&gt;&gt; d.a.b.c.d\n1\n&gt;&gt;&gt; d['c.d'] = {'c': {'d': 1}, 'e.f' : 2}\n&gt;&gt;&gt; d.c.d['e.f']\n2\n&gt;&gt;&gt; d.setattr('convert_mapping', False)\n&gt;&gt;&gt; d.set('e.f', {'c': {'d': 1}, 'e.f' : 2}, convert_mapping=True)\n&gt;&gt;&gt; d['e.f']['c.d']\n1\n</code></pre> Source code in <code>chanfig/nested_dict.py</code> Python<pre><code>def set(  # pylint: disable=W0221\nself,\nname: Any,\nvalue: Any,\nconvert_mapping: bool | None = None,\n) -&gt; None:\nr\"\"\"\n    Set value of `NestedDict`.\n    Args:\n        name:\n        value:\n        convert_mapping: Whether to convert `Mapping` to `NestedDict`.\n            Defaults to self.convert_mapping.\n    Examples:\n        &gt;&gt;&gt; d = NestedDict(default_factory=NestedDict)\n        &gt;&gt;&gt; d.set('i.d', 1013)\n        &gt;&gt;&gt; d.get('i.d')\n        1013\n        &gt;&gt;&gt; d.dict()\n        {'i': {'d': 1013}}\n        &gt;&gt;&gt; d['f.n'] = 'chang'\n        &gt;&gt;&gt; d.f.n\n        'chang'\n        &gt;&gt;&gt; d.n.l = 'liu'\n        &gt;&gt;&gt; d['n.l']\n        'liu'\n        &gt;&gt;&gt; d['f.n.e'] = \"error\"\n        Traceback (most recent call last):\n        ValueError: Cannot set `f.n.e` to `error`, as `f.n=chang`.\n        &gt;&gt;&gt; d['f.n.e.a'] = \"error\"\n        Traceback (most recent call last):\n        KeyError: 'e'\n        &gt;&gt;&gt; d.f.n.e.a = \"error\"\n        Traceback (most recent call last):\n        AttributeError: 'str' object has no attribute 'e'\n        &gt;&gt;&gt; d.setattr('convert_mapping', True)\n        &gt;&gt;&gt; d.a.b = {'c': {'d': 1}, 'e.f' : 2}\n        &gt;&gt;&gt; d.a.b.c.d\n        1\n        &gt;&gt;&gt; d['c.d'] = {'c': {'d': 1}, 'e.f' : 2}\n        &gt;&gt;&gt; d.c.d['e.f']\n        2\n        &gt;&gt;&gt; d.setattr('convert_mapping', False)\n        &gt;&gt;&gt; d.set('e.f', {'c': {'d': 1}, 'e.f' : 2}, convert_mapping=True)\n        &gt;&gt;&gt; d['e.f']['c.d']\n        1\n    \"\"\"\n# pylint: disable=W0642\nfull_name = name\nif convert_mapping is None:\nconvert_mapping = self.convert_mapping\ndelimiter = self.getattr(\"delimiter\", \".\")\ndefault_factory = self.getattr(\"default_factory\", self.empty_like)\ntry:\nwhile isinstance(name, str) and delimiter in name:\nname, rest = name.split(delimiter, 1)\nif name in dir(self) and isinstance(getattr(self.__class__, name), (property, cached_property)):\nself, name = getattr(self, name), rest\nelif name not in self and isinstance(self, Mapping):\ndefault = (\nself.__missing__(name, default_factory()) if hasattr(self, \"__missing__\") else default_factory()\n)\nself, name = default, rest\nelse:\nself, name = self[name], rest\nif isinstance(self, NestedDict):\ndefault_factory = self.getattr(\"default_factory\", self.empty_like)\nexcept (AttributeError, TypeError):\nraise KeyError(name) from None\nif convert_mapping and isinstance(value, Mapping):\nvalue = default_factory(value)\nif isinstance(self, NestedDict):\nsuper().set(name, value)\nelif isinstance(self, Mapping):\ndict.__setitem__(self, name, value)\nelse:\nraise ValueError(\nf\"Cannot set `{full_name}` to `{value}`, as `{delimiter.join(full_name.split(delimiter)[:-1])}={self}`.\"\n)\n</code></pre>"},{"location":"nested_dict/#chanfig.nested_dict.NestedDict.delete","title":"<code>delete(name)</code>","text":"<p>Delete value from <code>NestedDict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Any</code> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = NestedDict({\"i.d\": 1013, \"f.n\": \"chang\"})\n&gt;&gt;&gt; d.i.d\n1013\n&gt;&gt;&gt; d.f.n\n'chang'\n&gt;&gt;&gt; d.delete('i.d')\n&gt;&gt;&gt; d.dict()\n{'i': {}, 'f': {'n': 'chang'}}\n&gt;&gt;&gt; d.i.d\nTraceback (most recent call last):\nAttributeError: 'NestedDict' object has no attribute 'd'\n&gt;&gt;&gt; del d.f.n\n&gt;&gt;&gt; d.dict()\n{'i': {}, 'f': {}}\n&gt;&gt;&gt; d.f.n\nTraceback (most recent call last):\nAttributeError: 'NestedDict' object has no attribute 'n'\n&gt;&gt;&gt; del d.e\nTraceback (most recent call last):\nAttributeError: 'NestedDict' object has no attribute 'e'\n&gt;&gt;&gt; del d['f.n']\nTraceback (most recent call last):\nKeyError: 'n'\n&gt;&gt;&gt; d.e = {'a': {'b': 1}}\n&gt;&gt;&gt; del d['e.a.b']\n</code></pre> Source code in <code>chanfig/nested_dict.py</code> Python<pre><code>def delete(self, name: Any) -&gt; None:\nr\"\"\"\n    Delete value from `NestedDict`.\n    Args:\n        name:\n    Examples:\n        &gt;&gt;&gt; d = NestedDict({\"i.d\": 1013, \"f.n\": \"chang\"})\n        &gt;&gt;&gt; d.i.d\n        1013\n        &gt;&gt;&gt; d.f.n\n        'chang'\n        &gt;&gt;&gt; d.delete('i.d')\n        &gt;&gt;&gt; d.dict()\n        {'i': {}, 'f': {'n': 'chang'}}\n        &gt;&gt;&gt; d.i.d\n        Traceback (most recent call last):\n        AttributeError: 'NestedDict' object has no attribute 'd'\n        &gt;&gt;&gt; del d.f.n\n        &gt;&gt;&gt; d.dict()\n        {'i': {}, 'f': {}}\n        &gt;&gt;&gt; d.f.n\n        Traceback (most recent call last):\n        AttributeError: 'NestedDict' object has no attribute 'n'\n        &gt;&gt;&gt; del d.e\n        Traceback (most recent call last):\n        AttributeError: 'NestedDict' object has no attribute 'e'\n        &gt;&gt;&gt; del d['f.n']\n        Traceback (most recent call last):\n        KeyError: 'n'\n        &gt;&gt;&gt; d.e = {'a': {'b': 1}}\n        &gt;&gt;&gt; del d['e.a.b']\n    \"\"\"\ndelimiter = self.getattr(\"delimiter\", \".\")\ntry:\nwhile isinstance(name, str) and delimiter in name:\nname, rest = name.split(delimiter, 1)\nself, name = self[name], rest  # pylint: disable=W0642\nexcept (AttributeError, TypeError):\nraise KeyError(name) from None\n# if value is a python dict\nif not isinstance(self, NestedDict):\ndel self[name]\nreturn\nsuper().delete(name)\n</code></pre>"},{"location":"nested_dict/#chanfig.nested_dict.NestedDict.pop","title":"<code>pop(name, default=Null)</code>","text":"<p>Pop value from <code>NestedDict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Any</code> required <code>default</code> <code>Any</code> <code>Null</code> <p>Returns:</p> Name Type Description <code>value</code> <code>Any</code> <p>If <code>NestedDict</code> does not contain <code>name</code>, return <code>default</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = NestedDict({\"i.d\": 1013, \"f.n\": \"chang\", \"n.a.b.c\": 1}, default_factory=NestedDict)\n&gt;&gt;&gt; d.pop('i.d')\n1013\n&gt;&gt;&gt; d.pop('i.d', True)\nTrue\n&gt;&gt;&gt; d.pop('i.d')\nTraceback (most recent call last):\nKeyError: 'd'\n&gt;&gt;&gt; d.pop('e')\nTraceback (most recent call last):\nKeyError: 'e'\n&gt;&gt;&gt; d.pop('e.f')\nTraceback (most recent call last):\nKeyError: 'f'\n</code></pre> Source code in <code>chanfig/nested_dict.py</code> Python<pre><code>def pop(self, name: Any, default: Any = Null) -&gt; Any:\nr\"\"\"\n    Pop value from `NestedDict`.\n    Args:\n        name:\n        default:\n    Returns:\n        value: If `NestedDict` does not contain `name`, return `default`.\n    Examples:\n        &gt;&gt;&gt; d = NestedDict({\"i.d\": 1013, \"f.n\": \"chang\", \"n.a.b.c\": 1}, default_factory=NestedDict)\n        &gt;&gt;&gt; d.pop('i.d')\n        1013\n        &gt;&gt;&gt; d.pop('i.d', True)\n        True\n        &gt;&gt;&gt; d.pop('i.d')\n        Traceback (most recent call last):\n        KeyError: 'd'\n        &gt;&gt;&gt; d.pop('e')\n        Traceback (most recent call last):\n        KeyError: 'e'\n        &gt;&gt;&gt; d.pop('e.f')\n        Traceback (most recent call last):\n        KeyError: 'f'\n    \"\"\"\ndelimiter = self.getattr(\"delimiter\", \".\")\ntry:\nwhile isinstance(name, str) and delimiter in name:\nname, rest = name.split(delimiter, 1)\nself, name = self[name], rest  # pylint: disable=W0642\nexcept (AttributeError, TypeError):\nraise KeyError(name) from None\nif not isinstance(self, dict) or name not in self:\nif default is not Null:\nreturn default\nraise KeyError(name)\nreturn super().pop(name)\n</code></pre>"},{"location":"nested_dict/#chanfig.nested_dict.NestedDict.intersect","title":"<code>intersect(other, recursive=True)</code>","text":"<p>Intersection of <code>NestedDict</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Mapping | Iterable | PathStr</code> required <code>recursive</code> <code>bool</code> <code>True</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = NestedDict({'a': 1, 'b.c': 2, 'b.d': 3, 'c.d.e': 4, 'c.d.f': 5, 'c.e': 6})\n&gt;&gt;&gt; n = {'b': {'c': 3, 'd': 5}, 'c.d.e': 4, 'c.d': {'f': 5}, 'd': 0}\n&gt;&gt;&gt; d.intersect(n).dict()\n{'c': {'d': {'e': 4, 'f': 5}}}\n&gt;&gt;&gt; d.intersect(\"tests/test.yaml\").dict()\n{'a': 1}\n&gt;&gt;&gt; d.intersect(n, recursive=False).dict()\n{}\n&gt;&gt;&gt; l = [('a', 1), ('d', 4)]\n&gt;&gt;&gt; d.intersect(l).dict()\n{'a': 1}\n&gt;&gt;&gt; d.intersect(1)\nTraceback (most recent call last):\nTypeError: `other=1` should be of type Mapping, Iterable or PathStr, but got &lt;class 'int'&gt;.\n</code></pre> Source code in <code>chanfig/nested_dict.py</code> Python<pre><code>def intersect(  # pylint: disable=W0221\nself, other: Mapping | Iterable | PathStr, recursive: bool = True\n) -&gt; NestedDict:\nr\"\"\"\n    Intersection of `NestedDict` and `other`.\n    Args:\n        other (Mapping | Iterable | PathStr):\n        recursive (bool):\n    Examples:\n        &gt;&gt;&gt; d = NestedDict({'a': 1, 'b.c': 2, 'b.d': 3, 'c.d.e': 4, 'c.d.f': 5, 'c.e': 6})\n        &gt;&gt;&gt; n = {'b': {'c': 3, 'd': 5}, 'c.d.e': 4, 'c.d': {'f': 5}, 'd': 0}\n        &gt;&gt;&gt; d.intersect(n).dict()\n        {'c': {'d': {'e': 4, 'f': 5}}}\n        &gt;&gt;&gt; d.intersect(\"tests/test.yaml\").dict()\n        {'a': 1}\n        &gt;&gt;&gt; d.intersect(n, recursive=False).dict()\n        {}\n        &gt;&gt;&gt; l = [('a', 1), ('d', 4)]\n        &gt;&gt;&gt; d.intersect(l).dict()\n        {'a': 1}\n        &gt;&gt;&gt; d.intersect(1)\n        Traceback (most recent call last):\n        TypeError: `other=1` should be of type Mapping, Iterable or PathStr, but got &lt;class 'int'&gt;.\n    \"\"\"\nif isinstance(other, (PathLike, str, bytes)):\nother = self.load(other)\nif isinstance(other, (Mapping,)):\nother = self.empty_like(other).items()\nif not isinstance(other, Iterable):\nraise TypeError(f\"`other={other}` should be of type Mapping, Iterable or PathStr, but got {type(other)}.\")\nreturn self.empty_like(self._intersect(self, other, recursive))  # type: ignore\n</code></pre>"},{"location":"nested_dict/#chanfig.nested_dict.NestedDict.difference","title":"<code>difference(other, recursive=True)</code>","text":"<p>Difference between <code>NestedDict</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Mapping | Iterable | PathStr</code> required <code>recursive</code> <code>bool</code> <code>True</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; d = NestedDict({'a': 1, 'b.c': 2, 'b.d': 3, 'c.d.e': 4, 'c.d.f': 5, 'c.e': 6})\n&gt;&gt;&gt; n = {'b': {'c': 3, 'd': 5}, 'c.d.e': 4, 'c.d': {'f': 5}, 'd': 0}\n&gt;&gt;&gt; d.difference(n).dict()\n{'b': {'c': 3, 'd': 5}, 'd': 0}\n&gt;&gt;&gt; d.difference(\"tests/test.yaml\").dict()\n{'b': 2, 'c': 3}\n&gt;&gt;&gt; d.difference(n, recursive=False).dict()\n{'b': {'c': 3, 'd': 5}, 'c': {'d': {'e': 4, 'f': 5}}, 'd': 0}\n&gt;&gt;&gt; l = [('a', 1), ('d', 4)]\n&gt;&gt;&gt; d.difference(l).dict()\n{'d': 4}\n&gt;&gt;&gt; d.difference(1)\nTraceback (most recent call last):\nTypeError: `other=1` should be of type Mapping, Iterable or PathStr, but got &lt;class 'int'&gt;.\n</code></pre> Source code in <code>chanfig/nested_dict.py</code> Python<pre><code>def difference(  # pylint: disable=W0221, C0103\nself, other: Mapping | Iterable | PathStr, recursive: bool = True\n) -&gt; NestedDict:\nr\"\"\"\n    Difference between `NestedDict` and `other`.\n    Args:\n        other (Mapping | Iterable | PathStr):\n        recursive (bool):\n    Examples:\n        &gt;&gt;&gt; d = NestedDict({'a': 1, 'b.c': 2, 'b.d': 3, 'c.d.e': 4, 'c.d.f': 5, 'c.e': 6})\n        &gt;&gt;&gt; n = {'b': {'c': 3, 'd': 5}, 'c.d.e': 4, 'c.d': {'f': 5}, 'd': 0}\n        &gt;&gt;&gt; d.difference(n).dict()\n        {'b': {'c': 3, 'd': 5}, 'd': 0}\n        &gt;&gt;&gt; d.difference(\"tests/test.yaml\").dict()\n        {'b': 2, 'c': 3}\n        &gt;&gt;&gt; d.difference(n, recursive=False).dict()\n        {'b': {'c': 3, 'd': 5}, 'c': {'d': {'e': 4, 'f': 5}}, 'd': 0}\n        &gt;&gt;&gt; l = [('a', 1), ('d', 4)]\n        &gt;&gt;&gt; d.difference(l).dict()\n        {'d': 4}\n        &gt;&gt;&gt; d.difference(1)\n        Traceback (most recent call last):\n        TypeError: `other=1` should be of type Mapping, Iterable or PathStr, but got &lt;class 'int'&gt;.\n    \"\"\"\nif isinstance(other, (PathLike, str, bytes)):\nother = self.load(other)\nif isinstance(other, (Mapping,)):\nother = self.empty_like(other).items()\nif not isinstance(other, Iterable):\nraise TypeError(f\"`other={other}` should be of type Mapping, Iterable or PathStr, but got {type(other)}.\")\nreturn self.empty_like(self._difference(self, other, recursive))  # type: ignore\n</code></pre>"},{"location":"parser/","title":"ConfigParser","text":""},{"location":"parser/#chanfig.parser.ConfigParser","title":"<code>ConfigParser</code>","text":"<p>             Bases: <code>ArgumentParser</code></p> <p>Parser to parse command-line arguments for CHANfiG.</p> <p><code>ConfigParser</code> is a subclass of <code>argparse.ArgumentParser</code>. It provides a new <code>parse</code> method to parse command-line arguments to <code>CHANfiG.Config</code> object.</p> <p>Different to <code>ArgumentParser.parse_args</code>, <code>ConfigParser.parse</code> will try to parse any command-line arguments, even if they are not pre-defined by <code>ArgumentParser.add_argument</code>. This allows to relief the burden of adding tons of arguments for each tuneable parameter. In the meantime, there is no mechanism to notify you if you made a typo in command-line arguments.</p> <p>Note that <code>ArgumentParser.parse_args</code> method is not overridden in <code>ConfigParser</code>. This is because it is still possible to construct <code>CHANfiG.Config</code> with <code>ArgumentParser.parse_args</code>, which has strict checking on command-line arguments.</p> Source code in <code>chanfig/parser.py</code> Python<pre><code>class ConfigParser(ArgumentParser):  # pylint: disable=C0115\nr\"\"\"\n    Parser to parse command-line arguments for CHANfiG.\n    `ConfigParser` is a subclass of `argparse.ArgumentParser`.\n    It provides a new `parse` method to parse command-line arguments to `CHANfiG.Config` object.\n    Different to `ArgumentParser.parse_args`, `ConfigParser.parse` will try to parse any command-line arguments,\n    even if they are not pre-defined by `ArgumentParser.add_argument`.\n    This allows to relief the burden of adding tons of arguments for each tuneable parameter.\n    In the meantime, there is no mechanism to notify you if you made a typo in command-line arguments.\n    Note that `ArgumentParser.parse_args` method is not overridden in `ConfigParser`.\n    This is because it is still possible to construct `CHANfiG.Config` with `ArgumentParser.parse_args`,\n    which has strict checking on command-line arguments.\n    \"\"\"\ndef __init__(self, *args: Any, **kwargs: Any):\nsuper().__init__(*args, **kwargs)\nself._registries[\"action\"][None] = StoreAction\nself._registries[\"action\"][\"store\"] = StoreAction\ndef parse_args(  # type: ignore\nself, args: Sequence[str] | None = None, namespace: Namespace | None = None\n) -&gt; NestedDict:\nparsed = super().parse_args(args, namespace)\nif isinstance(parsed, Namespace):\nparsed = vars(parsed)  # type: ignore\nif not isinstance(parsed, NestedDict):\nparsed = NestedDict({key: value for key, value in parsed.items() if value is not Null})  # type: ignore\nfor key, value in parsed.all_items():\nwith suppress(TypeError, ValueError, SyntaxError):\nvalue = literal_eval(value)\nparsed[key] = value\nreturn parsed  # type: ignore\ndef parse(  # pylint: disable=R0912\nself,\nargs: Sequence[str] | None = None,\nconfig: Config | NestedDict | None = None,\ndefault_config: str | None = None,\nno_default_config_action: str = \"raise\",\n) -&gt; Config:\nr\"\"\"\n        Parse the arguments for `Config`.\n        You may optionally specify a name for `default_config`,\n        and CHANfiG will read the file under this name.\n        There are three levels of config:\n        1. The base `Config` parsed into this method,\n        2. The base config file located at the path of `default_config` (if specified),\n        3. The config specified in arguments.\n        Higher levels override lower levels (i.e. 3 &gt; 2 &gt; 1).\n        Args:\n            args: The arguments to parse.\n                Defaults to sys.argv[1:].\n            config: The base `Config`.\n                Defaults to `NestedDict`.\n            default_config: Path to the base config file. If specified, CHANfiG will read the file.\n                Defaults to `None`.\n            no_default_config_action: What to do when `default_config` is specified but not found in args.\n                Can be `raise`, `warn` or `ignore`. Defaults to `raise`.\n        Returns:\n            config: The parsed `Config`.\n        Raises:\n            ValueError: If `default_config` is specified but not found in args,\n                and `no_default_config_action` is neither `warn` nor `ignore`.\n            ValueError: If `no_default_config_action` is not in `raise`, `warn` and `ignore`.\n        See Also:\n            [`parse_config`][chanfig.ConfigParser.parse_config]: Only parse valid config arguments.\n        Examples:\n            Note that all examples uses NestedDict instead of Config for avoiding circular import.\n            &gt;&gt;&gt; p = ConfigParser()\n            &gt;&gt;&gt; p.parse(['--i.d', '1013', '--f.n', 'chang']).dict()\n            {'i': {'d': 1013}, 'f': {'n': 'chang'}}\n            Values in command line overrides values in `default_config` file.\n            &gt;&gt;&gt; p = ConfigParser()\n            &gt;&gt;&gt; p.parse(['--a', '2', '--config', 'tests/test.yaml'], default_config='config').dict()\n            {'a': 2, 'b': 2, 'c': 3, 'config': 'tests/test.yaml'}\n            Values in `default_config` file overrides values in `Config` object.\n            &gt;&gt;&gt; p = ConfigParser()\n            &gt;&gt;&gt; p.parse(['--config', 'tests/test.yaml'], config=NestedDict(a=2), default_config='config').dict()\n            {'a': 1, 'b': 2, 'c': 3, 'config': 'tests/test.yaml'}\n            ValueError will be raised when `default_config` is specified but not presented in command line.\n            &gt;&gt;&gt; p = ConfigParser()\n            &gt;&gt;&gt; p.parse(['--a', '2'], default_config='config').dict()\n            Traceback (most recent call last):\n            RuntimeError: default_config is set to config, but not found in args.\n            ValueError will be suppressed when `default_config` is specified bug not presented in command line,\n            and `no_default_config_action` is set to `ignore` or `warn`.\n            &gt;&gt;&gt; p = ConfigParser()\n            &gt;&gt;&gt; p.parse(['--a', '2'], default_config='config', no_default_config_action='ignore').dict()\n            {'a': 2}\n            ValueError will be raised when `no_default_config_action` is not in `raise`, `ignore`, and `warn`.\n            &gt;&gt;&gt; p = ConfigParser()\n            &gt;&gt;&gt; p.parse(['--a', '2'], default_config='config', no_default_config_action='suppress').dict()\n            Traceback (most recent call last):\n            ValueError: no_default_config_action must be one of 'warn', 'ignore', 'raise', bug got suppress\n        \"\"\"\nif args is None:\nargs = sys.argv[1:]\nif config is None:\nfrom .config import Config  # pylint: disable=C0415\nconfig = Config()\nelse:\nself.add_config_arguments(config)\nif no_default_config_action not in (\"warn\", \"ignore\", \"raise\"):\nraise ValueError(\nf\"no_default_config_action must be one of 'warn', 'ignore', 'raise', bug got {no_default_config_action}\"\n)\n# add the command-line arguments\nkey_value_args = []\nfor arg in args:\nif args == \"--\":\nbreak\nif arg.startswith(\"--\"):\nkey_value_args.append(arg.split(\"=\", maxsplit=1))\nelse:\nif not key_value_args:\ncontinue\nkey_value_args[-1].append(arg)\nfor key_value in key_value_args:\nif key_value[0] not in self:\nif len(key_value) &gt; 2:\nself.add_argument(key_value[0], nargs=\"+\")\nelse:\nself.add_argument(key_value[0])\nparsed = self.parse_args(args)\n# parse the default config file\nif default_config is not None:\nparsed = self.merge_default_config(parsed, default_config, no_default_config_action)\n# parse the command-line arguments\nreturn config.merge(parsed)  # type: ignore\ndef parse_config(  # pylint: disable=R0912\nself,\nargs: Sequence[str] | None = None,\nconfig: Config | None = None,\ndefault_config: str | None = None,\nno_default_config_action: str = \"raise\",\n) -&gt; Config:\nr\"\"\"\n        Parse the arguments for `Config`.\n        You may optionally specify a name for `default_config`,\n        and CHANfiG will read the file under this name.\n        There are three levels of config:\n        1. The base `Config` parsed into this method,\n        2. The base config file located at the path of `default_config` (if specified),\n        3. The config specified in arguments.\n        Higher levels override lower levels (i.e. 3 &gt; 2 &gt; 1).\n        Args:\n            args: The arguments to parse.\n                Defaults to sys.argv[1:].\n            config: The base `Config`.\n                Mandatory.\n            default_config: Path to the base config file. If specified, CHANfiG will read the file.\n                Defaults to `None`.\n            no_default_config_action: What to do when `default_config` is specified but not found in args.\n                Can be `raise`, `warn` or `ignore`. Defaults to `raise`.\n        Returns:\n            config: The parsed `Config`.\n        Raises:\n            ValueError: If `default_config` is specified but not found in args,\n                and `no_default_config_action` is neither `warn` nor `ignore`.\n            ValueError: If `no_default_config_action` is not in `raise`, `warn` and `ignore`.\n        See Also:\n            [`parse`][chanfig.ConfigParser.parse]: Parse all command-line arguments.\n        Examples:\n            Note that all examples uses NestedDict instead of Config for avoiding circular import.\n            &gt;&gt;&gt; p = ConfigParser()\n            &gt;&gt;&gt; p.parse_config(['--a', '1'], config=NestedDict(a=2)).dict()\n            {'a': 1}\n            You can only parse argument that is defined in `Config`.\n            error: unrecognized arguments: --b 1\n            &gt;&gt;&gt; p = ConfigParser()\n            &gt;&gt;&gt; p.parse_config(['--b', '1'], config=NestedDict(a=2)).dict()  # doctest: +SKIP\n            Traceback (most recent call last):\n            SystemExit: 2\n        \"\"\"\nif args is None:\nargs = sys.argv[1:]\nif config is None:\nraise ValueError(\"config must be specified\")\nself.add_config_arguments(config)\nif no_default_config_action not in (\"warn\", \"ignore\", \"raise\"):\nraise ValueError(\nf\"no_default_config_action must be one of 'warn', 'ignore', 'raise', bug got {no_default_config_action}\"\n)\nparsed = self.parse_args(args)\n# parse the default config file\nif default_config is not None:\nparsed = self.merge_default_config(parsed, default_config, no_default_config_action)\n# parse the command-line arguments\nreturn config.merge(parsed)  # type: ignore\ndef add_config_arguments(self, config):\nfor key, value in config.all_items():\nif isinstance(value, Variable):\ndtype = value._type or value.dtype  # pylint: disable=W0212\nelse:\ndtype = type(value)\nname = \"--\" + key\nif name not in self:\nhelp = value._help if isinstance(value, Variable) else None  # pylint: disable=W0212,W0622\nif isinstance(value, (list, tuple, dict, set)):\nself.add_argument(name, type=dtype, nargs=\"+\", help=help)\nelse:\nself.add_argument(name, type=dtype, help=help)\ndef merge_default_config(self, parsed, default_config: str, no_default_config_action: str = \"raise\") -&gt; NestedDict:\nmessage = f\"default_config is set to {default_config}, but not found in args.\"\nif default_config in parsed:\npath = parsed[default_config]\nwarn(f\"Config has 'default_config={path}' specified, its values will override values in Config\")\nreturn NestedDict.load(path).merge(parsed)  # type: ignore\nif no_default_config_action == \"ignore\":\npass\nelif no_default_config_action == \"warn\":\nwarn(message, category=RuntimeWarning, stacklevel=2)\nelse:\nraise RuntimeError(message)\nreturn parsed\n@staticmethod\ndef identity(string):\nr\"\"\"\n        https://stackoverflow.com/questions/69896931/cant-pickle-local-object-argumentparser-init-locals-identity\n        \"\"\"\nreturn string\ndef __contains__(self, name: str):\nif name in self._option_string_actions:\nreturn True\nreturn False\n</code></pre>"},{"location":"parser/#chanfig.parser.ConfigParser.parse","title":"<code>parse(args=None, config=None, default_config=None, no_default_config_action='raise')</code>","text":"<p>Parse the arguments for <code>Config</code>.</p> <p>You may optionally specify a name for <code>default_config</code>, and CHANfiG will read the file under this name.</p> <p>There are three levels of config:</p> <ol> <li>The base <code>Config</code> parsed into this method,</li> <li>The base config file located at the path of <code>default_config</code> (if specified),</li> <li>The config specified in arguments.</li> </ol> <p>Higher levels override lower levels (i.e. 3 &gt; 2 &gt; 1).</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Sequence[str] | None</code> <p>The arguments to parse. Defaults to sys.argv[1:].</p> <code>None</code> <code>config</code> <code>Config | NestedDict | None</code> <p>The base <code>Config</code>. Defaults to <code>NestedDict</code>.</p> <code>None</code> <code>default_config</code> <code>str | None</code> <p>Path to the base config file. If specified, CHANfiG will read the file. Defaults to <code>None</code>.</p> <code>None</code> <code>no_default_config_action</code> <code>str</code> <p>What to do when <code>default_config</code> is specified but not found in args. Can be <code>raise</code>, <code>warn</code> or <code>ignore</code>. Defaults to <code>raise</code>.</p> <code>'raise'</code> <p>Returns:</p> Name Type Description <code>config</code> <code>Config</code> <p>The parsed <code>Config</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>default_config</code> is specified but not found in args, and <code>no_default_config_action</code> is neither <code>warn</code> nor <code>ignore</code>.</p> <code>ValueError</code> <p>If <code>no_default_config_action</code> is not in <code>raise</code>, <code>warn</code> and <code>ignore</code>.</p> See Also <p><code>parse_config</code>: Only parse valid config arguments.</p> <p>Examples:</p> <p>Note that all examples uses NestedDict instead of Config for avoiding circular import.</p> Python Console Session<pre><code>&gt;&gt;&gt; p = ConfigParser()\n&gt;&gt;&gt; p.parse(['--i.d', '1013', '--f.n', 'chang']).dict()\n{'i': {'d': 1013}, 'f': {'n': 'chang'}}\n</code></pre> <p>Values in command line overrides values in <code>default_config</code> file.</p> Python Console Session<pre><code>&gt;&gt;&gt; p = ConfigParser()\n&gt;&gt;&gt; p.parse(['--a', '2', '--config', 'tests/test.yaml'], default_config='config').dict()\n{'a': 2, 'b': 2, 'c': 3, 'config': 'tests/test.yaml'}\n</code></pre> <p>Values in <code>default_config</code> file overrides values in <code>Config</code> object.</p> Python Console Session<pre><code>&gt;&gt;&gt; p = ConfigParser()\n&gt;&gt;&gt; p.parse(['--config', 'tests/test.yaml'], config=NestedDict(a=2), default_config='config').dict()\n{'a': 1, 'b': 2, 'c': 3, 'config': 'tests/test.yaml'}\n</code></pre> <p>ValueError will be raised when <code>default_config</code> is specified but not presented in command line.</p> Python Console Session<pre><code>&gt;&gt;&gt; p = ConfigParser()\n&gt;&gt;&gt; p.parse(['--a', '2'], default_config='config').dict()\nTraceback (most recent call last):\nRuntimeError: default_config is set to config, but not found in args.\n</code></pre> <p>ValueError will be suppressed when <code>default_config</code> is specified bug not presented in command line, and <code>no_default_config_action</code> is set to <code>ignore</code> or <code>warn</code>.</p> Python Console Session<pre><code>&gt;&gt;&gt; p = ConfigParser()\n&gt;&gt;&gt; p.parse(['--a', '2'], default_config='config', no_default_config_action='ignore').dict()\n{'a': 2}\n</code></pre> <p>ValueError will be raised when <code>no_default_config_action</code> is not in <code>raise</code>, <code>ignore</code>, and <code>warn</code>.</p> Python Console Session<pre><code>&gt;&gt;&gt; p = ConfigParser()\n&gt;&gt;&gt; p.parse(['--a', '2'], default_config='config', no_default_config_action='suppress').dict()\nTraceback (most recent call last):\nValueError: no_default_config_action must be one of 'warn', 'ignore', 'raise', bug got suppress\n</code></pre> Source code in <code>chanfig/parser.py</code> Python<pre><code>def parse(  # pylint: disable=R0912\nself,\nargs: Sequence[str] | None = None,\nconfig: Config | NestedDict | None = None,\ndefault_config: str | None = None,\nno_default_config_action: str = \"raise\",\n) -&gt; Config:\nr\"\"\"\n    Parse the arguments for `Config`.\n    You may optionally specify a name for `default_config`,\n    and CHANfiG will read the file under this name.\n    There are three levels of config:\n    1. The base `Config` parsed into this method,\n    2. The base config file located at the path of `default_config` (if specified),\n    3. The config specified in arguments.\n    Higher levels override lower levels (i.e. 3 &gt; 2 &gt; 1).\n    Args:\n        args: The arguments to parse.\n            Defaults to sys.argv[1:].\n        config: The base `Config`.\n            Defaults to `NestedDict`.\n        default_config: Path to the base config file. If specified, CHANfiG will read the file.\n            Defaults to `None`.\n        no_default_config_action: What to do when `default_config` is specified but not found in args.\n            Can be `raise`, `warn` or `ignore`. Defaults to `raise`.\n    Returns:\n        config: The parsed `Config`.\n    Raises:\n        ValueError: If `default_config` is specified but not found in args,\n            and `no_default_config_action` is neither `warn` nor `ignore`.\n        ValueError: If `no_default_config_action` is not in `raise`, `warn` and `ignore`.\n    See Also:\n        [`parse_config`][chanfig.ConfigParser.parse_config]: Only parse valid config arguments.\n    Examples:\n        Note that all examples uses NestedDict instead of Config for avoiding circular import.\n        &gt;&gt;&gt; p = ConfigParser()\n        &gt;&gt;&gt; p.parse(['--i.d', '1013', '--f.n', 'chang']).dict()\n        {'i': {'d': 1013}, 'f': {'n': 'chang'}}\n        Values in command line overrides values in `default_config` file.\n        &gt;&gt;&gt; p = ConfigParser()\n        &gt;&gt;&gt; p.parse(['--a', '2', '--config', 'tests/test.yaml'], default_config='config').dict()\n        {'a': 2, 'b': 2, 'c': 3, 'config': 'tests/test.yaml'}\n        Values in `default_config` file overrides values in `Config` object.\n        &gt;&gt;&gt; p = ConfigParser()\n        &gt;&gt;&gt; p.parse(['--config', 'tests/test.yaml'], config=NestedDict(a=2), default_config='config').dict()\n        {'a': 1, 'b': 2, 'c': 3, 'config': 'tests/test.yaml'}\n        ValueError will be raised when `default_config` is specified but not presented in command line.\n        &gt;&gt;&gt; p = ConfigParser()\n        &gt;&gt;&gt; p.parse(['--a', '2'], default_config='config').dict()\n        Traceback (most recent call last):\n        RuntimeError: default_config is set to config, but not found in args.\n        ValueError will be suppressed when `default_config` is specified bug not presented in command line,\n        and `no_default_config_action` is set to `ignore` or `warn`.\n        &gt;&gt;&gt; p = ConfigParser()\n        &gt;&gt;&gt; p.parse(['--a', '2'], default_config='config', no_default_config_action='ignore').dict()\n        {'a': 2}\n        ValueError will be raised when `no_default_config_action` is not in `raise`, `ignore`, and `warn`.\n        &gt;&gt;&gt; p = ConfigParser()\n        &gt;&gt;&gt; p.parse(['--a', '2'], default_config='config', no_default_config_action='suppress').dict()\n        Traceback (most recent call last):\n        ValueError: no_default_config_action must be one of 'warn', 'ignore', 'raise', bug got suppress\n    \"\"\"\nif args is None:\nargs = sys.argv[1:]\nif config is None:\nfrom .config import Config  # pylint: disable=C0415\nconfig = Config()\nelse:\nself.add_config_arguments(config)\nif no_default_config_action not in (\"warn\", \"ignore\", \"raise\"):\nraise ValueError(\nf\"no_default_config_action must be one of 'warn', 'ignore', 'raise', bug got {no_default_config_action}\"\n)\n# add the command-line arguments\nkey_value_args = []\nfor arg in args:\nif args == \"--\":\nbreak\nif arg.startswith(\"--\"):\nkey_value_args.append(arg.split(\"=\", maxsplit=1))\nelse:\nif not key_value_args:\ncontinue\nkey_value_args[-1].append(arg)\nfor key_value in key_value_args:\nif key_value[0] not in self:\nif len(key_value) &gt; 2:\nself.add_argument(key_value[0], nargs=\"+\")\nelse:\nself.add_argument(key_value[0])\nparsed = self.parse_args(args)\n# parse the default config file\nif default_config is not None:\nparsed = self.merge_default_config(parsed, default_config, no_default_config_action)\n# parse the command-line arguments\nreturn config.merge(parsed)  # type: ignore\n</code></pre>"},{"location":"parser/#chanfig.parser.ConfigParser.parse_config","title":"<code>parse_config(args=None, config=None, default_config=None, no_default_config_action='raise')</code>","text":"<p>Parse the arguments for <code>Config</code>.</p> <p>You may optionally specify a name for <code>default_config</code>, and CHANfiG will read the file under this name.</p> <p>There are three levels of config:</p> <ol> <li>The base <code>Config</code> parsed into this method,</li> <li>The base config file located at the path of <code>default_config</code> (if specified),</li> <li>The config specified in arguments.</li> </ol> <p>Higher levels override lower levels (i.e. 3 &gt; 2 &gt; 1).</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Sequence[str] | None</code> <p>The arguments to parse. Defaults to sys.argv[1:].</p> <code>None</code> <code>config</code> <code>Config | None</code> <p>The base <code>Config</code>. Mandatory.</p> <code>None</code> <code>default_config</code> <code>str | None</code> <p>Path to the base config file. If specified, CHANfiG will read the file. Defaults to <code>None</code>.</p> <code>None</code> <code>no_default_config_action</code> <code>str</code> <p>What to do when <code>default_config</code> is specified but not found in args. Can be <code>raise</code>, <code>warn</code> or <code>ignore</code>. Defaults to <code>raise</code>.</p> <code>'raise'</code> <p>Returns:</p> Name Type Description <code>config</code> <code>Config</code> <p>The parsed <code>Config</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>default_config</code> is specified but not found in args, and <code>no_default_config_action</code> is neither <code>warn</code> nor <code>ignore</code>.</p> <code>ValueError</code> <p>If <code>no_default_config_action</code> is not in <code>raise</code>, <code>warn</code> and <code>ignore</code>.</p> See Also <p><code>parse</code>: Parse all command-line arguments.</p> <p>Examples:</p> <p>Note that all examples uses NestedDict instead of Config for avoiding circular import.</p> Python Console Session<pre><code>&gt;&gt;&gt; p = ConfigParser()\n&gt;&gt;&gt; p.parse_config(['--a', '1'], config=NestedDict(a=2)).dict()\n{'a': 1}\n</code></pre> <p>You can only parse argument that is defined in <code>Config</code>. error: unrecognized arguments: \u2013b 1</p> Python Console Session<pre><code>&gt;&gt;&gt; p = ConfigParser()\n&gt;&gt;&gt; p.parse_config(['--b', '1'], config=NestedDict(a=2)).dict()\nTraceback (most recent call last):\nSystemExit: 2\n</code></pre> Source code in <code>chanfig/parser.py</code> Python<pre><code>def parse_config(  # pylint: disable=R0912\nself,\nargs: Sequence[str] | None = None,\nconfig: Config | None = None,\ndefault_config: str | None = None,\nno_default_config_action: str = \"raise\",\n) -&gt; Config:\nr\"\"\"\n    Parse the arguments for `Config`.\n    You may optionally specify a name for `default_config`,\n    and CHANfiG will read the file under this name.\n    There are three levels of config:\n    1. The base `Config` parsed into this method,\n    2. The base config file located at the path of `default_config` (if specified),\n    3. The config specified in arguments.\n    Higher levels override lower levels (i.e. 3 &gt; 2 &gt; 1).\n    Args:\n        args: The arguments to parse.\n            Defaults to sys.argv[1:].\n        config: The base `Config`.\n            Mandatory.\n        default_config: Path to the base config file. If specified, CHANfiG will read the file.\n            Defaults to `None`.\n        no_default_config_action: What to do when `default_config` is specified but not found in args.\n            Can be `raise`, `warn` or `ignore`. Defaults to `raise`.\n    Returns:\n        config: The parsed `Config`.\n    Raises:\n        ValueError: If `default_config` is specified but not found in args,\n            and `no_default_config_action` is neither `warn` nor `ignore`.\n        ValueError: If `no_default_config_action` is not in `raise`, `warn` and `ignore`.\n    See Also:\n        [`parse`][chanfig.ConfigParser.parse]: Parse all command-line arguments.\n    Examples:\n        Note that all examples uses NestedDict instead of Config for avoiding circular import.\n        &gt;&gt;&gt; p = ConfigParser()\n        &gt;&gt;&gt; p.parse_config(['--a', '1'], config=NestedDict(a=2)).dict()\n        {'a': 1}\n        You can only parse argument that is defined in `Config`.\n        error: unrecognized arguments: --b 1\n        &gt;&gt;&gt; p = ConfigParser()\n        &gt;&gt;&gt; p.parse_config(['--b', '1'], config=NestedDict(a=2)).dict()  # doctest: +SKIP\n        Traceback (most recent call last):\n        SystemExit: 2\n    \"\"\"\nif args is None:\nargs = sys.argv[1:]\nif config is None:\nraise ValueError(\"config must be specified\")\nself.add_config_arguments(config)\nif no_default_config_action not in (\"warn\", \"ignore\", \"raise\"):\nraise ValueError(\nf\"no_default_config_action must be one of 'warn', 'ignore', 'raise', bug got {no_default_config_action}\"\n)\nparsed = self.parse_args(args)\n# parse the default config file\nif default_config is not None:\nparsed = self.merge_default_config(parsed, default_config, no_default_config_action)\n# parse the command-line arguments\nreturn config.merge(parsed)  # type: ignore\n</code></pre>"},{"location":"parser/#chanfig.parser.ConfigParser.identity","title":"<code>identity(string)</code>  <code>staticmethod</code>","text":"Source code in <code>chanfig/parser.py</code> Python<pre><code>@staticmethod\ndef identity(string):\nr\"\"\"\n    https://stackoverflow.com/questions/69896931/cant-pickle-local-object-argumentparser-init-locals-identity\n    \"\"\"\nreturn string\n</code></pre>"},{"location":"registry/","title":"Registry","text":"<p>             Bases: <code>NestedDict</code></p> <p><code>Registry</code> for components.</p> <p>Registry provides 3 core functionalities:</p> <ul> <li>Register a new component.</li> <li>Lookup for a component.</li> <li>Build a component.</li> </ul> <p>To facilitate the usage scenario, <code>registry</code> is designed to be a decorator. You could register a component by simply calling <code>registry.register</code>, and it will be registered with its name. You may also specify the name of the component by calling <code>registry.register(name=\"ComponentName\")</code>.</p> <p><code>build</code> makes it easy to construct a component from a configuration. <code>build</code> automatically determines the component to construct by the <code>name</code> field in the configuration. So you could either call <code>registry.build(config)</code> or <code>registry.build(**config)</code>. Beyond this, <code>build</code> is just a syntax sugar for <code>registry.init(registry.lookup(name), *args, **kwargs)</code>.</p> <p><code>lookup</code> is used to lookup for a component by its name. By default, <code>lookup</code> internally calls <code>NestedDict.get</code>, but you may override it to provide more functionalities.</p> <p><code>init</code> is used to construct a component. By default, <code>init</code> internally calls <code>cls(*args, **kwargs)</code>, but you may override it to provide more functionalities.</p> Notes <p><code>Registry</code> inherits from <code>NestedDict</code>.</p> <p>Therefore, <code>Registry</code> comes in a nested structure by nature. You could create a sub-registry by simply calling <code>registry.sub_registry = Registry</code>, and access through <code>registry.sub_registry.register()</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; @registry.register\n... @registry.register(\"Module1\")\n... class Module:\n...     def __init__(self, a, b):\n...         self.a = a\n...         self.b = b\n&gt;&gt;&gt; module = registry.register(Module, \"Module2\")\n&gt;&gt;&gt; registry\nRegistry(\n  ('Module1'): &lt;class 'chanfig.registry.Module'&gt;\n  ('Module'): &lt;class 'chanfig.registry.Module'&gt;\n  ('Module2'): &lt;class 'chanfig.registry.Module'&gt;\n)\n&gt;&gt;&gt; module = registry.register(Module, \"Module\")\nTraceback (most recent call last):\nValueError: Component with name Module already registered.\n&gt;&gt;&gt; registry.lookup(\"Module\")\n&lt;class 'chanfig.registry.Module'&gt;\n&gt;&gt;&gt; config = {\"module\": {\"name\": \"Module\", \"a\": 1, \"b\": 2}}\n&gt;&gt;&gt; # registry.register(Module)\n&gt;&gt;&gt; module = registry.build(config[\"module\"])\n&gt;&gt;&gt; type(module)\n&lt;class 'chanfig.registry.Module'&gt;\n&gt;&gt;&gt; module.a\n1\n&gt;&gt;&gt; module.b\n2\n</code></pre> Source code in <code>chanfig/registry.py</code> Python<pre><code>class Registry(NestedDict):\n\"\"\"\n    `Registry` for components.\n    Registry provides 3 core functionalities:\n    - Register a new component.\n    - Lookup for a component.\n    - Build a component.\n    To facilitate the usage scenario, `registry` is designed to be a decorator.\n    You could register a component by simply calling `registry.register`, and it will be registered with its name.\n    You may also specify the name of the component by calling `registry.register(name=\"ComponentName\")`.\n    `build` makes it easy to construct a component from a configuration.\n    `build` automatically determines the component to construct by the `name` field in the configuration.\n    So you could either call `registry.build(config)` or `registry.build(**config)`.\n    Beyond this, `build` is just a syntax sugar for `registry.init(registry.lookup(name), *args, **kwargs)`.\n    `lookup` is used to lookup for a component by its name.\n    By default, `lookup` internally calls `NestedDict.get`, but you may override it to provide more functionalities.\n    `init` is used to construct a component.\n    By default, `init` internally calls `cls(*args, **kwargs)`, but you may override it to provide more functionalities.\n    Notes:\n        `Registry` inherits from `NestedDict`.\n        Therefore, `Registry` comes in a nested structure by nature.\n        You could create a sub-registry by simply calling `registry.sub_registry = Registry`,\n        and access through `registry.sub_registry.register()`.\n    Examples:\n        &gt;&gt;&gt; registry = Registry()\n        &gt;&gt;&gt; @registry.register\n        ... @registry.register(\"Module1\")\n        ... class Module:\n        ...     def __init__(self, a, b):\n        ...         self.a = a\n        ...         self.b = b\n        &gt;&gt;&gt; module = registry.register(Module, \"Module2\")\n        &gt;&gt;&gt; registry\n        Registry(\n          ('Module1'): &lt;class 'chanfig.registry.Module'&gt;\n          ('Module'): &lt;class 'chanfig.registry.Module'&gt;\n          ('Module2'): &lt;class 'chanfig.registry.Module'&gt;\n        )\n        &gt;&gt;&gt; module = registry.register(Module, \"Module\")\n        Traceback (most recent call last):\n        ValueError: Component with name Module already registered.\n        &gt;&gt;&gt; registry.lookup(\"Module\")\n        &lt;class 'chanfig.registry.Module'&gt;\n        &gt;&gt;&gt; config = {\"module\": {\"name\": \"Module\", \"a\": 1, \"b\": 2}}\n        &gt;&gt;&gt; # registry.register(Module)\n        &gt;&gt;&gt; module = registry.build(config[\"module\"])\n        &gt;&gt;&gt; type(module)\n        &lt;class 'chanfig.registry.Module'&gt;\n        &gt;&gt;&gt; module.a\n        1\n        &gt;&gt;&gt; module.b\n        2\n    \"\"\"\noverride: bool = False\ndef __init__(self, override: bool = False):\nsuper().__init__()\nself.setattr(\"override\", override)\ndef register(self, component: Any = None, name: Optional[Any] = None) -&gt; Callable:\nr\"\"\"\n        Register a new component.\n        Args:\n            component: The component to register.\n            name: The name of the component.\n        Returns:\n            component: The registered component.\n                Registered component are expected to be `Callable`.\n        Raises:\n            ValueError: If the component with the same name already registered and `Registry.override=False`.\n        Examples:\n            &gt;&gt;&gt; registry = Registry()\n            &gt;&gt;&gt; @registry.register\n            ... @registry.register(\"Module1\")\n            ... class Module:\n            ...     def __init__(self, a, b):\n            ...         self.a = a\n            ...         self.b = b\n            &gt;&gt;&gt; module = registry.register(Module, \"Module2\")\n            &gt;&gt;&gt; registry\n            Registry(\n              ('Module1'): &lt;class 'chanfig.registry.Module'&gt;\n              ('Module'): &lt;class 'chanfig.registry.Module'&gt;\n              ('Module2'): &lt;class 'chanfig.registry.Module'&gt;\n            )\n        \"\"\"\nif name in self and not self.override:\nraise ValueError(f\"Component with name {name} already registered.\")\n# Registry.register()\nif name is not None:\nself.set(name, component)\nreturn component  # type: ignore\n# @Registry.register\nif callable(component) and name is None:\nself.set(component.__name__, component)\nreturn component\n# @Registry.register()\ndef decorator(name: Optional[Any] = None):\n@wraps(self.register)\ndef wrapper(component):\nif name is None:\nself.set(component.__name__, component)\nelse:\nself.set(name, component)\nreturn component\nreturn wrapper\nreturn decorator(component)\ndef lookup(self, name: str) -&gt; Any:\nr\"\"\"\n        Lookup for a component.\n        Args:\n            name:\n        Returns:\n            (Any): The component.\n        Raises:\n            KeyError: If the component is not registered.\n        Examples:\n            &gt;&gt;&gt; registry = Registry()\n            &gt;&gt;&gt; @registry.register\n            ... class Module:\n            ...     def __init__(self, a, b):\n            ...         self.a = a\n            ...         self.b = b\n            &gt;&gt;&gt; registry.lookup(\"Module\")\n            &lt;class 'chanfig.registry.Module'&gt;\n        \"\"\"\nreturn self[name]\n@staticmethod\ndef init(cls: Callable, *args: Any, **kwargs: Any) -&gt; Any:  # type: ignore # pylint: disable=W0211\nr\"\"\"\n        Constructor of component.\n        Args:\n            cls: The component to construct.\n            *args: The arguments to pass to the component.\n            **kwargs: The keyword arguments to pass to the component.\n        Returns:\n            (Any):\n        Examples:\n            &gt;&gt;&gt; class Module:\n            ...     def __init__(self, a, b):\n            ...         self.a = a\n            ...         self.b = b\n            &gt;&gt;&gt; kwargs = {\"a\": 1, \"b\": 2}\n            &gt;&gt;&gt; module = Registry.init(Module, **kwargs)\n            &gt;&gt;&gt; type(module)\n            &lt;class 'chanfig.registry.Module'&gt;\n            &gt;&gt;&gt; module.a\n            1\n            &gt;&gt;&gt; module.b\n            2\n        \"\"\"\nreturn cls(*args, **kwargs)\ndef build(self, name: Union[str, Mapping], *args: Any, **kwargs: Any) -&gt; Any:\nr\"\"\"\n        Build a component.\n        Args:\n            name (str | Mapping):\n                If its a `Mapping`, it must contain `\"name\"` as a member, the rest will be treated as `**kwargs`.\n                Note that values in `kwargs` will override values in `name` if its a `Mapping`.\n            *args: The arguments to pass to the component.\n            **kwargs: The keyword arguments to pass to the component.\n        Returns:\n            (Any):\n        Raises:\n            KeyError: If the component is not registered.\n        Examples:\n            &gt;&gt;&gt; registry = Registry()\n            &gt;&gt;&gt; @registry.register\n            ... class Module:\n            ...     def __init__(self, a, b):\n            ...         self.a = a\n            ...         self.b = b\n            &gt;&gt;&gt; config = {\"module\": {\"name\": \"Module\", \"a\": 1, \"b\": 2}}\n            &gt;&gt;&gt; # registry.register(Module)\n            &gt;&gt;&gt; module = registry.build(**config[\"module\"])\n            &gt;&gt;&gt; type(module)\n            &lt;class 'chanfig.registry.Module'&gt;\n            &gt;&gt;&gt; module.a\n            1\n            &gt;&gt;&gt; module.b\n            2\n            &gt;&gt;&gt; module = registry.build(config[\"module\"], a=2)\n            &gt;&gt;&gt; module.a\n            2\n        \"\"\"\nif isinstance(name, Mapping):\nname = deepcopy(name)\nname, kwargs = name.pop(\"name\"), dict(name, **kwargs)  # type: ignore\nreturn self.init(self.lookup(name), *args, **kwargs)  # type: ignore\ndef __wrapped__(self, *args: Any, **kwargs: Any):\npass\n</code></pre>"},{"location":"registry/#chanfig.registry.Registry.register","title":"<code>register(component=None, name=None)</code>","text":"<p>Register a new component.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>Any</code> <p>The component to register.</p> <code>None</code> <code>name</code> <code>Optional[Any]</code> <p>The name of the component.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>component</code> <code>Callable</code> <p>The registered component. Registered component are expected to be <code>Callable</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the component with the same name already registered and <code>Registry.override=False</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; @registry.register\n... @registry.register(\"Module1\")\n... class Module:\n...     def __init__(self, a, b):\n...         self.a = a\n...         self.b = b\n&gt;&gt;&gt; module = registry.register(Module, \"Module2\")\n&gt;&gt;&gt; registry\nRegistry(\n  ('Module1'): &lt;class 'chanfig.registry.Module'&gt;\n  ('Module'): &lt;class 'chanfig.registry.Module'&gt;\n  ('Module2'): &lt;class 'chanfig.registry.Module'&gt;\n)\n</code></pre> Source code in <code>chanfig/registry.py</code> Python<pre><code>def register(self, component: Any = None, name: Optional[Any] = None) -&gt; Callable:\nr\"\"\"\n    Register a new component.\n    Args:\n        component: The component to register.\n        name: The name of the component.\n    Returns:\n        component: The registered component.\n            Registered component are expected to be `Callable`.\n    Raises:\n        ValueError: If the component with the same name already registered and `Registry.override=False`.\n    Examples:\n        &gt;&gt;&gt; registry = Registry()\n        &gt;&gt;&gt; @registry.register\n        ... @registry.register(\"Module1\")\n        ... class Module:\n        ...     def __init__(self, a, b):\n        ...         self.a = a\n        ...         self.b = b\n        &gt;&gt;&gt; module = registry.register(Module, \"Module2\")\n        &gt;&gt;&gt; registry\n        Registry(\n          ('Module1'): &lt;class 'chanfig.registry.Module'&gt;\n          ('Module'): &lt;class 'chanfig.registry.Module'&gt;\n          ('Module2'): &lt;class 'chanfig.registry.Module'&gt;\n        )\n    \"\"\"\nif name in self and not self.override:\nraise ValueError(f\"Component with name {name} already registered.\")\n# Registry.register()\nif name is not None:\nself.set(name, component)\nreturn component  # type: ignore\n# @Registry.register\nif callable(component) and name is None:\nself.set(component.__name__, component)\nreturn component\n# @Registry.register()\ndef decorator(name: Optional[Any] = None):\n@wraps(self.register)\ndef wrapper(component):\nif name is None:\nself.set(component.__name__, component)\nelse:\nself.set(name, component)\nreturn component\nreturn wrapper\nreturn decorator(component)\n</code></pre>"},{"location":"registry/#chanfig.registry.Registry.lookup","title":"<code>lookup(name)</code>","text":"<p>Lookup for a component.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Any</code> <p>The component.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the component is not registered.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; @registry.register\n... class Module:\n...     def __init__(self, a, b):\n...         self.a = a\n...         self.b = b\n&gt;&gt;&gt; registry.lookup(\"Module\")\n&lt;class 'chanfig.registry.Module'&gt;\n</code></pre> Source code in <code>chanfig/registry.py</code> Python<pre><code>def lookup(self, name: str) -&gt; Any:\nr\"\"\"\n    Lookup for a component.\n    Args:\n        name:\n    Returns:\n        (Any): The component.\n    Raises:\n        KeyError: If the component is not registered.\n    Examples:\n        &gt;&gt;&gt; registry = Registry()\n        &gt;&gt;&gt; @registry.register\n        ... class Module:\n        ...     def __init__(self, a, b):\n        ...         self.a = a\n        ...         self.b = b\n        &gt;&gt;&gt; registry.lookup(\"Module\")\n        &lt;class 'chanfig.registry.Module'&gt;\n    \"\"\"\nreturn self[name]\n</code></pre>"},{"location":"registry/#chanfig.registry.Registry.init","title":"<code>init(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Constructor of component.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Callable</code> <p>The component to construct.</p> required <code>*args</code> <code>Any</code> <p>The arguments to pass to the component.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments to pass to the component.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; class Module:\n...     def __init__(self, a, b):\n...         self.a = a\n...         self.b = b\n&gt;&gt;&gt; kwargs = {\"a\": 1, \"b\": 2}\n&gt;&gt;&gt; module = Registry.init(Module, **kwargs)\n&gt;&gt;&gt; type(module)\n&lt;class 'chanfig.registry.Module'&gt;\n&gt;&gt;&gt; module.a\n1\n&gt;&gt;&gt; module.b\n2\n</code></pre> Source code in <code>chanfig/registry.py</code> Python<pre><code>@staticmethod\ndef init(cls: Callable, *args: Any, **kwargs: Any) -&gt; Any:  # type: ignore # pylint: disable=W0211\nr\"\"\"\n    Constructor of component.\n    Args:\n        cls: The component to construct.\n        *args: The arguments to pass to the component.\n        **kwargs: The keyword arguments to pass to the component.\n    Returns:\n        (Any):\n    Examples:\n        &gt;&gt;&gt; class Module:\n        ...     def __init__(self, a, b):\n        ...         self.a = a\n        ...         self.b = b\n        &gt;&gt;&gt; kwargs = {\"a\": 1, \"b\": 2}\n        &gt;&gt;&gt; module = Registry.init(Module, **kwargs)\n        &gt;&gt;&gt; type(module)\n        &lt;class 'chanfig.registry.Module'&gt;\n        &gt;&gt;&gt; module.a\n        1\n        &gt;&gt;&gt; module.b\n        2\n    \"\"\"\nreturn cls(*args, **kwargs)\n</code></pre>"},{"location":"registry/#chanfig.registry.Registry.build","title":"<code>build(name, *args, **kwargs)</code>","text":"<p>Build a component.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | Mapping</code> <p>If its a <code>Mapping</code>, it must contain <code>\"name\"</code> as a member, the rest will be treated as <code>**kwargs</code>. Note that values in <code>kwargs</code> will override values in <code>name</code> if its a <code>Mapping</code>.</p> required <code>*args</code> <code>Any</code> <p>The arguments to pass to the component.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments to pass to the component.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the component is not registered.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; registry = Registry()\n&gt;&gt;&gt; @registry.register\n... class Module:\n...     def __init__(self, a, b):\n...         self.a = a\n...         self.b = b\n&gt;&gt;&gt; config = {\"module\": {\"name\": \"Module\", \"a\": 1, \"b\": 2}}\n&gt;&gt;&gt; # registry.register(Module)\n&gt;&gt;&gt; module = registry.build(**config[\"module\"])\n&gt;&gt;&gt; type(module)\n&lt;class 'chanfig.registry.Module'&gt;\n&gt;&gt;&gt; module.a\n1\n&gt;&gt;&gt; module.b\n2\n&gt;&gt;&gt; module = registry.build(config[\"module\"], a=2)\n&gt;&gt;&gt; module.a\n2\n</code></pre> Source code in <code>chanfig/registry.py</code> Python<pre><code>def build(self, name: Union[str, Mapping], *args: Any, **kwargs: Any) -&gt; Any:\nr\"\"\"\n    Build a component.\n    Args:\n        name (str | Mapping):\n            If its a `Mapping`, it must contain `\"name\"` as a member, the rest will be treated as `**kwargs`.\n            Note that values in `kwargs` will override values in `name` if its a `Mapping`.\n        *args: The arguments to pass to the component.\n        **kwargs: The keyword arguments to pass to the component.\n    Returns:\n        (Any):\n    Raises:\n        KeyError: If the component is not registered.\n    Examples:\n        &gt;&gt;&gt; registry = Registry()\n        &gt;&gt;&gt; @registry.register\n        ... class Module:\n        ...     def __init__(self, a, b):\n        ...         self.a = a\n        ...         self.b = b\n        &gt;&gt;&gt; config = {\"module\": {\"name\": \"Module\", \"a\": 1, \"b\": 2}}\n        &gt;&gt;&gt; # registry.register(Module)\n        &gt;&gt;&gt; module = registry.build(**config[\"module\"])\n        &gt;&gt;&gt; type(module)\n        &lt;class 'chanfig.registry.Module'&gt;\n        &gt;&gt;&gt; module.a\n        1\n        &gt;&gt;&gt; module.b\n        2\n        &gt;&gt;&gt; module = registry.build(config[\"module\"], a=2)\n        &gt;&gt;&gt; module.a\n        2\n    \"\"\"\nif isinstance(name, Mapping):\nname = deepcopy(name)\nname, kwargs = name.pop(\"name\"), dict(name, **kwargs)  # type: ignore\nreturn self.init(self.lookup(name), *args, **kwargs)  # type: ignore\n</code></pre>"},{"location":"utils/","title":"Utilities","text":""},{"location":"utils/#chanfigload","title":"chanfig.load","text":"<p>Load a file into a <code>NestedDict</code>.</p> <p>This function simply calls <code>NestedDict.load</code>.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>PathStr</code> <p>The file to load.</p> required <code>*args</code> <code>Any</code> <p>The arguments to pass to <code>NestedDict.load</code>.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments to pass to <code>NestedDict.load</code>.</p> <code>{}</code> See Also <p><code>load</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from chanfig import load\n&gt;&gt;&gt; config = load(\"tests/test.yaml\")\n&gt;&gt;&gt; config\nNestedDict(\n  ('a'): 1\n  ('b'): 2\n  ('c'): 3\n)\n</code></pre> Source code in <code>chanfig/functional.py</code> Python<pre><code>def load(file: PathStr, cls: Type = NestedDict, *args: Any, **kwargs: Any) -&gt; NestedDict:  # pylint: disable=W1113\nr\"\"\"\n    Load a file into a `NestedDict`.\n    This function simply calls `NestedDict.load`.\n    Args:\n        file: The file to load.\n        *args: The arguments to pass to `NestedDict.load`.\n        **kwargs: The keyword arguments to pass to `NestedDict.load`.\n    See Also:\n        [`load`][chanfig.FlatDict.load]\n    Examples:\n        &gt;&gt;&gt; from chanfig import load\n        &gt;&gt;&gt; config = load(\"tests/test.yaml\")\n        &gt;&gt;&gt; config\n        NestedDict(\n          ('a'): 1\n          ('b'): 2\n          ('c'): 3\n        )\n    \"\"\"\nreturn cls.load(file, *args, **kwargs)  # type: ignore\n</code></pre> <p>options: heading_level: 0</p>"},{"location":"utils/#chanfigsave","title":"chanfig.save","text":"<p>Save <code>FlatDict</code> to file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If save to <code>IO</code> and <code>method</code> is not specified.</p> <code>TypeError</code> <p>If save to unsupported extension.</p> <p>Alias:</p> <ul> <li><code>save</code></li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; obj = {\"a\": 1, \"b\": 2, \"c\": 3}\n&gt;&gt;&gt; save(obj, \"test.yaml\")\n&gt;&gt;&gt; save(obj, \"test.json\")\n&gt;&gt;&gt; save(obj, \"test.conf\")\nTraceback (most recent call last):\nTypeError: `file='test.conf'` should be in ('json',) or ('yml', 'yaml'), but got conf.\n&gt;&gt;&gt; with open(\"test.yaml\", \"w\") as f:\n...     save(obj, f)\nTraceback (most recent call last):\nValueError: `method` must be specified when saving to IO.\n</code></pre> Source code in <code>chanfig/functional.py</code> Python<pre><code>def save(obj, file: File, method: Optional[str] = None, *args: Any, **kwargs: Any) -&gt; None:  # pylint: disable=W1113\nr\"\"\"\n    Save `FlatDict` to file.\n    Raises:\n        ValueError: If save to `IO` and `method` is not specified.\n        TypeError: If save to unsupported extension.\n    **Alias**:\n    + `save`\n    Examples:\n        &gt;&gt;&gt; obj = {\"a\": 1, \"b\": 2, \"c\": 3}\n        &gt;&gt;&gt; save(obj, \"test.yaml\")\n        &gt;&gt;&gt; save(obj, \"test.json\")\n        &gt;&gt;&gt; save(obj, \"test.conf\")\n        Traceback (most recent call last):\n        TypeError: `file='test.conf'` should be in ('json',) or ('yml', 'yaml'), but got conf.\n        &gt;&gt;&gt; with open(\"test.yaml\", \"w\") as f:\n        ...     save(obj, f)\n        Traceback (most recent call last):\n        ValueError: `method` must be specified when saving to IO.\n    \"\"\"\nif isinstance(obj, FlatDict):\nreturn obj.save(file, method, *args, **kwargs)\ndata = to_dict(obj)\nif method is None:\nif isinstance(file, IOBase):\nraise ValueError(\"`method` must be specified when saving to IO.\")\nmethod = splitext(file)[-1][1:]  # type: ignore\nextension = method.lower()  # type: ignore\nif extension in YAML:\nwith FlatDict.open(file, mode=\"w\") as fp:  # pylint: disable=C0103\nyaml_dump(data, fp, *args, **kwargs)\nreturn\nif extension in JSON:\nwith FlatDict.open(file, mode=\"w\") as fp:  # pylint: disable=C0103\nfp.write(json_dumps(data, *args, **kwargs))\nreturn\nraise TypeError(f\"`file={file!r}` should be in {JSON} or {YAML}, but got {extension}.\")  # type: ignore\n</code></pre> <p>options: heading_level: 0</p>"},{"location":"utils/#chanfigto_dict","title":"chanfig.to_dict","text":"<p>Convert an object to a dict.</p> <p>Note that when converting a <code>set</code> object, it may be converted to a <code>tuple</code> object if its values is not hashable.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Object to be converted.</p> required <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>A dict.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; to_dict(1)\n1\n&gt;&gt;&gt; to_dict([1, 2, 3])\n[1, 2, 3]\n&gt;&gt;&gt; to_dict((1, 2, 3))\n(1, 2, 3)\n&gt;&gt;&gt; to_dict({1, 2, 3})\n{1, 2, 3}\n&gt;&gt;&gt; to_dict({'a': 1, 'b': 2})\n{'a': 1, 'b': 2}\n&gt;&gt;&gt; to_dict(Variable(1))\n1\n&gt;&gt;&gt; to_dict(FlatDict(a=[[[[[FlatDict(b=1)]]]]]))\n{'a': [[[[[{'b': 1}]]]]]}\n&gt;&gt;&gt; to_dict(FlatDict(a={FlatDict(b=1)}))\n{'a': ({'b': 1},)}\n</code></pre> Source code in <code>chanfig/flat_dict.py</code> Python<pre><code>def to_dict(obj: Any) -&gt; Mapping[str, Any]:  # pylint: disable=R0911\nr\"\"\"\n    Convert an object to a dict.\n    Note that when converting a `set` object, it may be converted to a `tuple` object if its values is not hashable.\n    Args:\n        obj: Object to be converted.\n    Returns:\n        A dict.\n    Examples:\n        &gt;&gt;&gt; to_dict(1)\n        1\n        &gt;&gt;&gt; to_dict([1, 2, 3])\n        [1, 2, 3]\n        &gt;&gt;&gt; to_dict((1, 2, 3))\n        (1, 2, 3)\n        &gt;&gt;&gt; to_dict({1, 2, 3})\n        {1, 2, 3}\n        &gt;&gt;&gt; to_dict({'a': 1, 'b': 2})\n        {'a': 1, 'b': 2}\n        &gt;&gt;&gt; to_dict(Variable(1))\n        1\n        &gt;&gt;&gt; to_dict(FlatDict(a=[[[[[FlatDict(b=1)]]]]]))\n        {'a': [[[[[{'b': 1}]]]]]}\n        &gt;&gt;&gt; to_dict(FlatDict(a={FlatDict(b=1)}))\n        {'a': ({'b': 1},)}\n    \"\"\"\nif isinstance(obj, Mapping):\nreturn {k: to_dict(v) for k, v in obj.items()}\nif isinstance(obj, list):\nreturn [to_dict(v) for v in obj]  # type: ignore\nif isinstance(obj, tuple):\nreturn tuple(to_dict(v) for v in obj)  # type: ignore\nif isinstance(obj, set):\ntry:\nreturn {to_dict(v) for v in obj}  # type: ignore\nexcept TypeError:\nreturn tuple(to_dict(v) for v in obj)  # type: ignore\nif isinstance(obj, Variable):\nreturn obj.value\nreturn obj\n</code></pre> <p>options: heading_level: 0</p>"},{"location":"utils/#chanfigapply","title":"chanfig.apply","text":"<p>Apply <code>func</code> to all children of <code>obj</code>.</p> <p>Note that this method is meant for non-in-place modification of <code>obj</code> and should return the original object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Object to apply function.</p> required <code>func</code> <code>Callable</code> <p>Function to be applied.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to be passed to <code>func</code>.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to be passed to <code>func</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Return value of <code>func</code>.</p> See Also <p><code>apply_</code>: Apply an in-place operation.</p> Source code in <code>chanfig/nested_dict.py</code> Python<pre><code>def apply(obj: Any, func: Callable, *args: Any, **kwargs: Any) -&gt; Any:\nr\"\"\"\n    Apply `func` to all children of `obj`.\n    Note that this method is meant for non-in-place modification of `obj` and should return the original object.\n    Args:\n        obj: Object to apply function.\n        func: Function to be applied.\n        *args: Positional arguments to be passed to `func`.\n        **kwargs: Keyword arguments to be passed to `func`.\n    Returns:\n        (Any): Return value of `func`.\n    See Also:\n        [`apply_`][chanfig.nested_dict.apply_]: Apply an in-place operation.\n    \"\"\"\nif isinstance(obj, NestedDict):\nreturn obj.empty_like(**{k: apply(v, func, *args, **kwargs) for k, v in obj.items()})\nif isinstance(obj, Mapping):\nreturn {k: apply(v, func, *args, **kwargs) for k, v in obj.items()}\nif isinstance(obj, list):\nreturn [apply(v, func, *args, **kwargs) for v in obj]\nif isinstance(obj, tuple):\nreturn tuple(apply(v, func, *args, **kwargs) for v in obj)\nif isinstance(obj, set):\ntry:\nreturn {apply(v, func, *args, **kwargs) for v in obj}\nexcept TypeError:\ntuple(apply(v, func, *args, **kwargs) for v in obj)\nreturn func(*args, **kwargs) if ismethod(func) else func(obj, *args, **kwargs)\n</code></pre> <p>options: heading_level: 0</p>"},{"location":"utils/#chanfigapply_","title":"chanfig.apply_","text":"<p>Apply <code>func</code> to all children of <code>obj</code>.</p> <p>Note that this method is meant for non-in-place modification of <code>obj</code> and should return a new object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Object to apply function.</p> required <code>func</code> <code>Callable</code> <p>Function to be applied.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to be passed to <code>func</code>.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to be passed to <code>func</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Return value of <code>func</code>.</p> See Also <p><code>apply_</code>: Apply a non-in-place operation.</p> Source code in <code>chanfig/nested_dict.py</code> Python<pre><code>def apply_(obj: Any, func: Callable, *args: Any, **kwargs: Any) -&gt; Any:\nr\"\"\"\n    Apply `func` to all children of `obj`.\n    Note that this method is meant for non-in-place modification of `obj` and should return a new object.\n    Args:\n        obj: Object to apply function.\n        func: Function to be applied.\n        *args: Positional arguments to be passed to `func`.\n        **kwargs: Keyword arguments to be passed to `func`.\n    Returns:\n        (Any): Return value of `func`.\n    See Also:\n        [`apply_`][chanfig.nested_dict.apply]: Apply a non-in-place operation.\n    \"\"\"\nif isinstance(obj, Mapping):\nfor v in obj.values():\napply_(v, func, *args, **kwargs)\nif isinstance(obj, (list, tuple, set)):\nfor v in obj:\napply_(v, func, *args, **kwargs)\nreturn func(*args, **kwargs) if ismethod(func) else func(obj, *args, **kwargs)\n</code></pre> <p>options: heading_level: 0</p>"},{"location":"utils/#chanfigutilssingleton","title":"chanfig.utils.Singleton","text":"<p>             Bases: <code>type</code></p> <p>Metaclass for Singleton Classes.</p> Source code in <code>chanfig/utils.py</code> Python<pre><code>class Singleton(type):\nr\"\"\"\n    Metaclass for Singleton Classes.\n    \"\"\"\n__instances__: Mapping[type, object] = {}\ndef __call__(cls, *args: Any, **kwargs: Any):\nif cls not in cls.__instances__:\ncls.__instances__[cls] = super().__call__(*args, **kwargs)  # type: ignore\nreturn cls.__instances__[cls]\n</code></pre> <p>options: heading_level: 0</p>"},{"location":"utils/#chanfigutilsnull","title":"chanfig.utils.Null","text":"<p><code>Null</code> is an instance of <code>NULL</code>.</p> <p>Since the metaclass of <code>NULL</code> is <code>Singleton</code>, it is advised to use <code>obj is Null</code> to determine if <code>obj</code> is <code>Null</code>.</p>"},{"location":"utils/#chanfigutilsnull_1","title":"chanfig.utils.NULL","text":"<p>NULL class.</p> <p><code>get</code> method in CHANfiG may accept <code>None</code> or <code>Ellipse</code>(<code>...</code>) as value of <code>default</code>. Therefore, it is mandatory to have a different default value for <code>default</code>.</p> <p><code>Null</code> is an instance of <code>NULL</code> and is recommended to be used as <code>obj is Null</code>.</p> Source code in <code>chanfig/utils.py</code> Python<pre><code>class NULL(metaclass=Singleton):\nr\"\"\"\n    NULL class.\n    `get` method in CHANfiG may accept `None` or `Ellipse`(`...`) as value of `default`.\n    Therefore, it is mandatory to have a different default value for `default`.\n    `Null` is an instance of `NULL` and is recommended to be used as `obj is Null`.\n    \"\"\"\ndef __repr__(self):\nreturn \"Null\"\ndef __nonzero__(self):\nreturn False\ndef __len__(self):\nreturn 0\ndef __call__(self, *args: Any, **kwargs: Any):\nreturn self\ndef __contains__(self, name):\nreturn False\ndef __iter__(self):\nreturn self\ndef __next__(self):\nraise StopIteration\ndef __getattr__(self, name):\nreturn self\ndef __getitem__(self, index):\nreturn self\n</code></pre> <p>options: heading_level: 0</p>"},{"location":"utils/#chanfigutilsjsonencoder","title":"chanfig.utils.JsonEncoder","text":"<p>             Bases: <code>JSONEncoder</code></p> <p>JSON encoder for Config.</p> Source code in <code>chanfig/utils.py</code> Python<pre><code>class JsonEncoder(JSONEncoder):\nr\"\"\"\n    JSON encoder for Config.\n    \"\"\"\ndef default(self, o: Any) -&gt; Any:\nif hasattr(o, \"__json__\"):\nreturn o.__json__()\nreturn super().default(o)\n</code></pre> <p>options: heading_level: 0</p>"},{"location":"utils/#chanfigutilsyamldumper","title":"chanfig.utils.YamlDumper","text":"<p>             Bases: <code>SafeDumper</code></p> <p>YAML Dumper for Config.</p> Source code in <code>chanfig/utils.py</code> Python<pre><code>class YamlDumper(SafeDumper):  # pylint: disable=R0903\nr\"\"\"\n    YAML Dumper for Config.\n    \"\"\"\ndef increase_indent(self, flow: bool = False, indentless: bool = False):  # pylint: disable=W0235\nreturn super().increase_indent(flow, indentless)\n</code></pre> <p>options: heading_level: 0</p>"},{"location":"utils/#chanfigutilsyamlloader","title":"chanfig.utils.YamlLoader","text":"<p>             Bases: <code>SafeLoader</code></p> <p>YAML Loader for Config.</p> Source code in <code>chanfig/utils.py</code> Python<pre><code>class YamlLoader(SafeLoader):  # pylint: disable=R0901,R0903\nr\"\"\"\n    YAML Loader for Config.\n    \"\"\"\n</code></pre> <p>options: heading_level: 0</p>"},{"location":"variable/","title":"Variable","text":"<p>             Bases: <code>Generic[_V]</code></p> <p>Mutable wrapper for immutable objects.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to wrap.</p> <code>Null</code> <code>type</code> <code>Optional[type]</code> <p>Desired type of the value.</p> <code>None</code> <code>choices</code> <code>Optional[List]</code> <p>Possible values of the value.</p> <code>None</code> <code>validator</code> <code>Optional[Callable]</code> <p><code>Callable</code> that validates the value.</p> <code>None</code> <code>required</code> <code>bool</code> <p>Whether the value is required.</p> <code>False</code> <code>help</code> <code>Optional[str]</code> <p>Help message of the value.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If <code>required</code> is <code>True</code> and <code>value</code> is <code>Null</code>.</p> <code>TypeError</code> <p>If <code>type</code> is specified and <code>value</code> is not an instance of <code>type</code>.</p> <code>ValueError</code> <p>| If <code>choices</code> is specified and <code>value</code> is not in <code>choices</code>. If <code>validator</code> is specified and <code>validator</code> returns <code>False</code>.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>Any</code> <p>The wrapped value.</p> <code>dtype</code> <code>Type</code> <p>The type of the wrapped value.</p> Notes <p><code>Variable</code> by default wrap the instance type to type of the wrapped object. Therefore, <code>isinstance(Variable(1), int)</code> will return <code>True</code>.</p> <p>To temporarily disable this behavior, you can call context manager <code>with Variable.unwrapped()</code>.</p> <p>To permanently disable this behavior, you can call <code>Variable.unwrap()</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; v = Variable(1)\n&gt;&gt;&gt; n = v\n&gt;&gt;&gt; v, n\n(1, 1)\n&gt;&gt;&gt; v += 1\n&gt;&gt;&gt; v, n\n(2, 2)\n&gt;&gt;&gt; v.value = 3\n&gt;&gt;&gt; v, n\n(3, 3)\n&gt;&gt;&gt; n.set(4)\n&gt;&gt;&gt; v, n\n(4, 4)\n&gt;&gt;&gt; n = 5\n&gt;&gt;&gt; v, n\n(4, 5)\n&gt;&gt;&gt; f'{v} &lt; {n}'\n'4 &lt; 5'\n&gt;&gt;&gt; isinstance(v, int)\nTrue\n&gt;&gt;&gt; type(v)\n&lt;class 'chanfig.variable.Variable'&gt;\n&gt;&gt;&gt; v.dtype\n&lt;class 'int'&gt;\n&gt;&gt;&gt; with v.unwrapped():\n...    isinstance(v, int)\nFalse\n&gt;&gt;&gt; v = Variable('hello')\n&gt;&gt;&gt; f'{v}, world!'\n'hello, world!'\n&gt;&gt;&gt; v += ', world!'\n&gt;&gt;&gt; v\n'hello, world!'\n&gt;&gt;&gt; \"hello\" in v\nTrue\n</code></pre> Source code in <code>chanfig/variable.py</code> Python<pre><code>class Variable(Generic[_V]):  # pylint: disable=R0902\nr\"\"\"\n    Mutable wrapper for immutable objects.\n    Args:\n        value: The value to wrap.\n        type: Desired type of the value.\n        choices: Possible values of the value.\n        validator: `Callable` that validates the value.\n        required: Whether the value is required.\n        help: Help message of the value.\n    Raises:\n        RuntimeError: If `required` is `True` and `value` is `Null`.\n        TypeError: If `type` is specified and `value` is not an instance of `type`.\n        ValueError: |\n            If `choices` is specified and `value` is not in `choices`.\n            If `validator` is specified and `validator` returns `False`.\n    Attributes:\n        value: The wrapped value.\n        dtype: The type of the wrapped value.\n    Notes:\n        `Variable` by default wrap the instance type to type of the wrapped object.\n        Therefore, `isinstance(Variable(1), int)` will return `True`.\n        To temporarily disable this behavior, you can call context manager `with Variable.unwrapped()`.\n        To permanently disable this behavior, you can call `Variable.unwrap()`.\n    Examples:\n        &gt;&gt;&gt; v = Variable(1)\n        &gt;&gt;&gt; n = v\n        &gt;&gt;&gt; v, n\n        (1, 1)\n        &gt;&gt;&gt; v += 1\n        &gt;&gt;&gt; v, n\n        (2, 2)\n        &gt;&gt;&gt; v.value = 3\n        &gt;&gt;&gt; v, n\n        (3, 3)\n        &gt;&gt;&gt; n.set(4)\n        &gt;&gt;&gt; v, n\n        (4, 4)\n        &gt;&gt;&gt; n = 5\n        &gt;&gt;&gt; v, n\n        (4, 5)\n        &gt;&gt;&gt; f'{v} &lt; {n}'\n        '4 &lt; 5'\n        &gt;&gt;&gt; isinstance(v, int)\n        True\n        &gt;&gt;&gt; type(v)\n        &lt;class 'chanfig.variable.Variable'&gt;\n        &gt;&gt;&gt; v.dtype\n        &lt;class 'int'&gt;\n        &gt;&gt;&gt; with v.unwrapped():\n        ...    isinstance(v, int)\n        False\n        &gt;&gt;&gt; v = Variable('hello')\n        &gt;&gt;&gt; f'{v}, world!'\n        'hello, world!'\n        &gt;&gt;&gt; v += ', world!'\n        &gt;&gt;&gt; v\n        'hello, world!'\n        &gt;&gt;&gt; \"hello\" in v\n        True\n    \"\"\"\nwrap_type: bool = True\n_storage: List[Any]\n_type: Optional[type] = None\n_choices: Optional[List] = None\n_validator: Optional[Callable] = None\n_required: bool = False\n_help: Optional[str] = None\ndef __init__(  # pylint: disable=R0913\nself,\nvalue: Any = Null,\ntype: Optional[type] = None,  # pylint: disable=W0622\nchoices: Optional[List] = None,\nvalidator: Optional[Callable] = None,\nrequired: bool = False,\nhelp: Optional[str] = None,  # pylint: disable=W0622\n) -&gt; None:\nself._storage = [value]\nself._type = type\nself._choices = choices\nself._validator = validator\nself._required = required\nself._help = help\n@property  # type: ignore\ndef __class__(self) -&gt; type:\nreturn self.value.__class__ if self.wrap_type else type(self)\n@property\ndef value(self) -&gt; Any:\nr\"\"\"\n        Fetch the object wrapped in `Variable`.\n        \"\"\"\nreturn self._storage[0]\n@value.setter\ndef value(self, value) -&gt; None:\nr\"\"\"\n        Assign value to the object wrapped in `Variable`.\n        \"\"\"\nself.validate(value)\nself._storage[0] = self._get_value(value)\n@property\ndef dtype(self) -&gt; Type:\nr\"\"\"\n        Data type of the object wrapped in `Variable`.\n        Examples:\n            &gt;&gt;&gt; id = Variable(1013)\n            &gt;&gt;&gt; type(id)\n            &lt;class 'chanfig.variable.Variable'&gt;\n            &gt;&gt;&gt; id.dtype\n            &lt;class 'int'&gt;\n            &gt;&gt;&gt; issubclass(id.dtype, int)\n            True\n        \"\"\"\nreturn self.value.__class__\n@property\ndef storage(self) -&gt; List[Any]:\nr\"\"\"\n        Storage of `Variable`.\n        \"\"\"\nreturn self._storage\n@property\ndef type(self) -&gt; Optional[type]:\nreturn self._type\n@property\ndef choices(self) -&gt; Optional[List]:\nreturn self._choices\n@property\ndef validator(self) -&gt; Optional[Callable]:\nreturn self._validator\n@property\ndef required(self) -&gt; bool:\nreturn self._required\n@property\ndef help(self) -&gt; str:\nreturn self._help or \"\"\ndef validate(self, *args) -&gt; None:\nr\"\"\"\n        Validate if the value is valid.\n        \"\"\"\nif len(args) == 0:\nvalue = self.value\nelif len(args) == 1:\nvalue = args[0]\nelse:\nraise ValueError(\"Too many arguments.\")\nif self._required and value is Null:\nraise RuntimeError(\"Value is required.\")\nif self._type is not None and not isinstance(value, self._type):\nraise TypeError(f\"Value {value} is not of type {self._type}.\")\nif self._choices is not None and value not in self._choices:\nraise ValueError(f\"Value {value} is not in choices {self._choices}.\")\nif self._validator is not None and not self._validator(value):\nraise ValueError(f\"Value {value} is not valid.\")\ndef get(self) -&gt; Any:\nr\"\"\"\n        Fetch the object wrapped in `Variable`.\n        \"\"\"\nreturn self.value\ndef set(self, value) -&gt; None:\nr\"\"\"\n        Assign value to the object wrapped in `Variable`.\n        `Variable.set` is extremely useful when you want to change the value without changing the reference.\n        In `FlatDict.set`, all assignments of `Variable` calls `Variable.set` Internally.\n        \"\"\"\nself.value = value\ndef to(self, cls: Callable) -&gt; Any:  # pylint: disable=C0103\nr\"\"\"\n        Convert the object wrapped in `Variable` to target `cls`.\n        Args:\n            cls: The type to convert to.\n        Examples:\n            &gt;&gt;&gt; id = Variable(1013)\n            &gt;&gt;&gt; id.to(float)\n            1013.0\n            &gt;&gt;&gt; id.to(str)\n            '1013.0'\n        \"\"\"\nself.value = cls(self.value)\nreturn self\ndef int(self) -&gt; int:\nr\"\"\"\n        Convert the object wrapped in `Variable` to python `int`.\n        Examples:\n            &gt;&gt;&gt; id = Variable(1013.0)\n            &gt;&gt;&gt; id.int()\n            1013\n        \"\"\"\nreturn self.to(int)\ndef float(self) -&gt; float:\nr\"\"\"\n        Convert the object wrapped in `Variable` to python `float`.\n        Examples:\n            &gt;&gt;&gt; id = Variable(1013)\n            &gt;&gt;&gt; id.float()\n            1013.0\n        \"\"\"\nreturn self.to(float)\ndef str(self) -&gt; str:\nr\"\"\"\n        Convert the object wrapped in `Variable` to python `float`.\n        Examples:\n            &gt;&gt;&gt; id = Variable(1013)\n            &gt;&gt;&gt; id.str()\n            '1013'\n        \"\"\"\nreturn self.to(str)\ndef wrap(self) -&gt; None:\nr\"\"\"\n        Wrap the type of `Variable`.\n        Examples:\n            &gt;&gt;&gt; id = Variable(1013)\n            &gt;&gt;&gt; id.unwrap()\n            &gt;&gt;&gt; isinstance(id, int)\n            False\n            &gt;&gt;&gt; id.wrap()\n            &gt;&gt;&gt; isinstance(id, int)\n            True\n        \"\"\"\nself.wrap_type = True\ndef unwrap(self) -&gt; None:\nr\"\"\"\n        Unwrap the type of `Variable`.\n        Examples:\n            &gt;&gt;&gt; id = Variable(1013)\n            &gt;&gt;&gt; id.unwrap()\n            &gt;&gt;&gt; isinstance(id, int)\n            False\n        \"\"\"\nself.wrap_type = False\n@contextmanager\ndef unwrapped(self):\nr\"\"\"\n        Context manager which temporarily unwrap the `Variable`.\n        Examples:\n            &gt;&gt;&gt; id = Variable(1013)\n            &gt;&gt;&gt; isinstance(id, int)\n            True\n            &gt;&gt;&gt; with id.unwrapped():\n            ...    isinstance(id, int)\n            False\n        \"\"\"\nwrap_type = self.wrap_type\nself.wrap_type = False\ntry:\nyield self\nfinally:\nself.wrap_type = wrap_type\n@staticmethod\ndef _get_value(obj) -&gt; Any:\nif isinstance(obj, Variable):\nreturn obj.value\nreturn obj\ndef __getattr__(self, attr) -&gt; Any:\nreturn getattr(self.value, attr)\ndef __lt__(self, other) -&gt; bool:\nreturn self.value &lt; self._get_value(other)\ndef __le__(self, other) -&gt; bool:\nreturn self.value &lt;= self._get_value(other)\ndef __eq__(self, other) -&gt; bool:\nreturn self.value == self._get_value(other)\ndef __ne__(self, other) -&gt; bool:\nreturn self.value != self._get_value(other)\ndef __ge__(self, other) -&gt; bool:\nreturn self.value &gt;= self._get_value(other)\ndef __gt__(self, other) -&gt; bool:\nreturn self.value &gt; self._get_value(other)\ndef __index__(self):\nreturn self.value.__index__()\ndef __invert__(self):\nreturn ~self.value\ndef __abs__(self):\nreturn abs(self.value)\ndef __add__(self, other):\nreturn Variable(self.value + self._get_value(other))\ndef __radd__(self, other):\nreturn Variable(self._get_value(other) + self.value)\ndef __iadd__(self, other):\nself.value += self._get_value(other)\nreturn self\ndef __and__(self, other):\nreturn Variable(self.value &amp; self._get_value(other))\ndef __rand__(self, other):\nreturn Variable(self._get_value(other) &amp; self.value)\ndef __iand__(self, other):\nself.value &amp;= self._get_value(other)\nreturn self\ndef __floordiv__(self, other):\nreturn Variable(self.value // self._get_value(other))\ndef __rfloordiv__(self, other):\nreturn Variable(self._get_value(other) // self.value)\ndef __ifloordiv__(self, other):\nself.value //= self._get_value(other)\nreturn self\ndef __mod__(self, other):\nreturn Variable(self.value % self._get_value(other))\ndef __rmod__(self, other):\nreturn Variable(self._get_value(other) % self.value)\ndef __imod__(self, other):\nself.value %= self._get_value(other)\nreturn self\ndef __mul__(self, other):\nreturn Variable(self.value * self._get_value(other))\ndef __rmul__(self, other):\nreturn Variable(self._get_value(other) * self.value)\ndef __imul__(self, other):\nself.value *= self._get_value(other)\nreturn self\ndef __matmul__(self, other):\nreturn Variable(self.value @ self._get_value(other))\ndef __rmatmul__(self, other):\nreturn Variable(self._get_value(other) @ self.value)\ndef __imatmul__(self, other):\nself.value @= self._get_value(other)\nreturn self\ndef __pow__(self, other):\nreturn Variable(self.value ** self._get_value(other))\ndef __rpow__(self, other):\nreturn Variable(self._get_value(other) ** self.value)\ndef __ipow__(self, other):\nself.value **= self._get_value(other)\nreturn self\ndef __truediv__(self, other):\nreturn Variable(self.value / self._get_value(other))\ndef __rtruediv__(self, other):\nreturn Variable(self._get_value(other) / self.value)\ndef __itruediv__(self, other):\nself.value /= self._get_value(other)\nreturn self\ndef __sub__(self, other):\nreturn Variable(self.value - self._get_value(other))\ndef __rsub__(self, other):\nreturn Variable(self._get_value(other) - self.value)\ndef __isub__(self, other):\nself.value -= self._get_value(other)\nreturn self\ndef __copy__(self):\nreturn Variable(self.value)\ndef __deepcopy__(self, memo: Optional[Mapping] = None):\nreturn Variable(copy(self.value))\ndef __format__(self, format_spec):\nreturn self.value if isinstance(self, str) else format(self.value, format_spec)\ndef __iter__(self):\nreturn iter(self.value)\ndef __next__(self):\nreturn next(self.value)\ndef __hash__(self):\nreturn hash(self.value)\ndef __repr__(self):\nreturn repr(self.value)\ndef __str__(self):\nreturn self.value if isinstance(self, str) else str(self.value)\ndef __json__(self):\nreturn self.value\ndef __contains__(self, name):\nreturn name in self.value\n</code></pre>"},{"location":"variable/#chanfig.variable.Variable.value","title":"<code>value: Any</code>  <code>property</code> <code>writable</code>","text":"<p>Fetch the object wrapped in <code>Variable</code>.</p>"},{"location":"variable/#chanfig.variable.Variable.dtype","title":"<code>dtype: Type</code>  <code>property</code>","text":"<p>Data type of the object wrapped in <code>Variable</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; id = Variable(1013)\n&gt;&gt;&gt; type(id)\n&lt;class 'chanfig.variable.Variable'&gt;\n&gt;&gt;&gt; id.dtype\n&lt;class 'int'&gt;\n&gt;&gt;&gt; issubclass(id.dtype, int)\nTrue\n</code></pre>"},{"location":"variable/#chanfig.variable.Variable.storage","title":"<code>storage: List[Any]</code>  <code>property</code>","text":"<p>Storage of <code>Variable</code>.</p>"},{"location":"variable/#chanfig.variable.Variable.validate","title":"<code>validate(*args)</code>","text":"<p>Validate if the value is valid.</p> Source code in <code>chanfig/variable.py</code> Python<pre><code>def validate(self, *args) -&gt; None:\nr\"\"\"\n    Validate if the value is valid.\n    \"\"\"\nif len(args) == 0:\nvalue = self.value\nelif len(args) == 1:\nvalue = args[0]\nelse:\nraise ValueError(\"Too many arguments.\")\nif self._required and value is Null:\nraise RuntimeError(\"Value is required.\")\nif self._type is not None and not isinstance(value, self._type):\nraise TypeError(f\"Value {value} is not of type {self._type}.\")\nif self._choices is not None and value not in self._choices:\nraise ValueError(f\"Value {value} is not in choices {self._choices}.\")\nif self._validator is not None and not self._validator(value):\nraise ValueError(f\"Value {value} is not valid.\")\n</code></pre>"},{"location":"variable/#chanfig.variable.Variable.get","title":"<code>get()</code>","text":"<p>Fetch the object wrapped in <code>Variable</code>.</p> Source code in <code>chanfig/variable.py</code> Python<pre><code>def get(self) -&gt; Any:\nr\"\"\"\n    Fetch the object wrapped in `Variable`.\n    \"\"\"\nreturn self.value\n</code></pre>"},{"location":"variable/#chanfig.variable.Variable.set","title":"<code>set(value)</code>","text":"<p>Assign value to the object wrapped in <code>Variable</code>.</p> <p><code>Variable.set</code> is extremely useful when you want to change the value without changing the reference.</p> <p>In <code>FlatDict.set</code>, all assignments of <code>Variable</code> calls <code>Variable.set</code> Internally.</p> Source code in <code>chanfig/variable.py</code> Python<pre><code>def set(self, value) -&gt; None:\nr\"\"\"\n    Assign value to the object wrapped in `Variable`.\n    `Variable.set` is extremely useful when you want to change the value without changing the reference.\n    In `FlatDict.set`, all assignments of `Variable` calls `Variable.set` Internally.\n    \"\"\"\nself.value = value\n</code></pre>"},{"location":"variable/#chanfig.variable.Variable.to","title":"<code>to(cls)</code>","text":"<p>Convert the object wrapped in <code>Variable</code> to target <code>cls</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Callable</code> <p>The type to convert to.</p> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; id = Variable(1013)\n&gt;&gt;&gt; id.to(float)\n1013.0\n&gt;&gt;&gt; id.to(str)\n'1013.0'\n</code></pre> Source code in <code>chanfig/variable.py</code> Python<pre><code>def to(self, cls: Callable) -&gt; Any:  # pylint: disable=C0103\nr\"\"\"\n    Convert the object wrapped in `Variable` to target `cls`.\n    Args:\n        cls: The type to convert to.\n    Examples:\n        &gt;&gt;&gt; id = Variable(1013)\n        &gt;&gt;&gt; id.to(float)\n        1013.0\n        &gt;&gt;&gt; id.to(str)\n        '1013.0'\n    \"\"\"\nself.value = cls(self.value)\nreturn self\n</code></pre>"},{"location":"variable/#chanfig.variable.Variable.int","title":"<code>int()</code>","text":"<p>Convert the object wrapped in <code>Variable</code> to python <code>int</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; id = Variable(1013.0)\n&gt;&gt;&gt; id.int()\n1013\n</code></pre> Source code in <code>chanfig/variable.py</code> Python<pre><code>def int(self) -&gt; int:\nr\"\"\"\n    Convert the object wrapped in `Variable` to python `int`.\n    Examples:\n        &gt;&gt;&gt; id = Variable(1013.0)\n        &gt;&gt;&gt; id.int()\n        1013\n    \"\"\"\nreturn self.to(int)\n</code></pre>"},{"location":"variable/#chanfig.variable.Variable.float","title":"<code>float()</code>","text":"<p>Convert the object wrapped in <code>Variable</code> to python <code>float</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; id = Variable(1013)\n&gt;&gt;&gt; id.float()\n1013.0\n</code></pre> Source code in <code>chanfig/variable.py</code> Python<pre><code>def float(self) -&gt; float:\nr\"\"\"\n    Convert the object wrapped in `Variable` to python `float`.\n    Examples:\n        &gt;&gt;&gt; id = Variable(1013)\n        &gt;&gt;&gt; id.float()\n        1013.0\n    \"\"\"\nreturn self.to(float)\n</code></pre>"},{"location":"variable/#chanfig.variable.Variable.str","title":"<code>str()</code>","text":"<p>Convert the object wrapped in <code>Variable</code> to python <code>float</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; id = Variable(1013)\n&gt;&gt;&gt; id.str()\n'1013'\n</code></pre> Source code in <code>chanfig/variable.py</code> Python<pre><code>def str(self) -&gt; str:\nr\"\"\"\n    Convert the object wrapped in `Variable` to python `float`.\n    Examples:\n        &gt;&gt;&gt; id = Variable(1013)\n        &gt;&gt;&gt; id.str()\n        '1013'\n    \"\"\"\nreturn self.to(str)\n</code></pre>"},{"location":"variable/#chanfig.variable.Variable.wrap","title":"<code>wrap()</code>","text":"<p>Wrap the type of <code>Variable</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; id = Variable(1013)\n&gt;&gt;&gt; id.unwrap()\n&gt;&gt;&gt; isinstance(id, int)\nFalse\n&gt;&gt;&gt; id.wrap()\n&gt;&gt;&gt; isinstance(id, int)\nTrue\n</code></pre> Source code in <code>chanfig/variable.py</code> Python<pre><code>def wrap(self) -&gt; None:\nr\"\"\"\n    Wrap the type of `Variable`.\n    Examples:\n        &gt;&gt;&gt; id = Variable(1013)\n        &gt;&gt;&gt; id.unwrap()\n        &gt;&gt;&gt; isinstance(id, int)\n        False\n        &gt;&gt;&gt; id.wrap()\n        &gt;&gt;&gt; isinstance(id, int)\n        True\n    \"\"\"\nself.wrap_type = True\n</code></pre>"},{"location":"variable/#chanfig.variable.Variable.unwrap","title":"<code>unwrap()</code>","text":"<p>Unwrap the type of <code>Variable</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; id = Variable(1013)\n&gt;&gt;&gt; id.unwrap()\n&gt;&gt;&gt; isinstance(id, int)\nFalse\n</code></pre> Source code in <code>chanfig/variable.py</code> Python<pre><code>def unwrap(self) -&gt; None:\nr\"\"\"\n    Unwrap the type of `Variable`.\n    Examples:\n        &gt;&gt;&gt; id = Variable(1013)\n        &gt;&gt;&gt; id.unwrap()\n        &gt;&gt;&gt; isinstance(id, int)\n        False\n    \"\"\"\nself.wrap_type = False\n</code></pre>"},{"location":"variable/#chanfig.variable.Variable.unwrapped","title":"<code>unwrapped()</code>","text":"<p>Context manager which temporarily unwrap the <code>Variable</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; id = Variable(1013)\n&gt;&gt;&gt; isinstance(id, int)\nTrue\n&gt;&gt;&gt; with id.unwrapped():\n...    isinstance(id, int)\nFalse\n</code></pre> Source code in <code>chanfig/variable.py</code> Python<pre><code>@contextmanager\ndef unwrapped(self):\nr\"\"\"\n    Context manager which temporarily unwrap the `Variable`.\n    Examples:\n        &gt;&gt;&gt; id = Variable(1013)\n        &gt;&gt;&gt; isinstance(id, int)\n        True\n        &gt;&gt;&gt; with id.unwrapped():\n        ...    isinstance(id, int)\n        False\n    \"\"\"\nwrap_type = self.wrap_type\nself.wrap_type = False\ntry:\nyield self\nfinally:\nself.wrap_type = wrap_type\n</code></pre>"},{"location":"blog/","title":"CHANfiG","text":""},{"location":"zh/#_1","title":"\u4ecb\u7ecd","text":"<p>CHANfiG \u5e0c\u671b\u80fd\u8ba9\u4f60\u7684\u914d\u7f6e\u66f4\u52a0\u7b80\u5355\u3002</p> <p>\u8bad\u7ec3\u4e00\u4e2a\u673a\u5668\u5b66\u4e60\u6a21\u578b\u6709\u65e0\u6570\u4e2a\u53ef\u8c03\u8282\u7684\u53c2\u6570\u3002 \u4e3a\u4e86\u8c03\u8282\u6240\u6709\u53c2\u6570\uff0c\u7814\u7a76\u5458\u4eec\u5e38\u5e38\u9700\u8981\u64b0\u5199\u5de8\u5927\u7684\u914d\u7f6e\u6587\u4ef6\uff0c\u6709\u65f6\u751a\u81f3\u957f\u8fbe\u6570\u5343\u884c\u3002 \u5927\u591a\u6570\u53c2\u6570\u53ea\u662f\u65b9\u6cd5\u9ed8\u8ba4\u53c2\u6570\u7684\u7b80\u5355\u91cd\u590d\uff0c\u8fd9\u5bfc\u81f4\u4e86\u5f88\u591a\u4e0d\u5fc5\u8981\u7684\u58f0\u660e\u3002 \u6b64\u5916\uff0c\u8c03\u8282\u8fd9\u4e9b\u53c2\u6570\u540c\u6837\u5f88\u7e41\u7410\uff0c\u9700\u8981\u5b9a\u4f4d\u5e76\u6253\u5f00\u914d\u7f6e\u6587\u4ef6\uff0c\u4f5c\u51fa\u4fee\u6539\uff0c\u7136\u540e\u4fdd\u5b58\u5173\u95ed\u3002 \u8fd9\u4e2a\u8fc7\u7a0b\u6d6a\u8d39\u4e86\u65e0\u6570\u7684\u5b9d\u8d35\u65f6\u95f4 \u8fd9\u65e0\u7591\u662f\u4e00\u79cd\u72af\u7f6a \u3002 \u4f7f\u7528<code>argparse</code>\u53ef\u4ee5\u5728\u4e00\u5b9a\u7a0b\u5ea6\u4e0a\u7f13\u89e3\u8c03\u53c2\u7684\u4e0d\u53d8\uff0c\u4f46\u662f\uff0c\u8981\u8ba9\u4ed6\u548c\u914d\u7f6e\u6587\u4ef6\u9002\u914d\u4f9d\u7136\u9700\u8981\u5f88\u591a\u5de5\u4f5c\uff0c\u5e76\u4e14\u7f3a\u4e4f\u5d4c\u5957\u4e5f\u9650\u5236\u4e86\u4ed6\u7684\u6f5c\u529b\u3002</p> <p>CHANfiG \u65e8\u5728\u5e26\u6765\u6539\u53d8\u3002</p> <p>\u4f60\u53ea\u9700\u8981\u5728\u547d\u4ee4\u884c\u4e2d\u8f93\u5165\u4f60\u7684\u4fee\u6539\uff0c\u7136\u540e\u628a\u5269\u4e0b\u7684\u4ea4\u7ed9 CHANfiG\u3002</p> <p>CHANfiG \u5f88\u5927\u7a0b\u5ea6\u4e0a\u542f\u53d1\u81eaYACS\u3002 \u4e0d\u540c\u4e8e YACS \u7684\u8303\u5f0f\uff08<code>\u4ee3\u7801 + \u5b9e\u9a8cE\u7684YACS\u914d\u7f6e\u6587\u4ef6 (+ \u5916\u90e8\u4f9d\u8d56 + \u786c\u4ef6 + \u5176\u4ed6\u4ee4\u4eba\u8ba8\u538c\u7684\u672f\u8bed ...) = \u53ef\u91cd\u590d\u7684\u5b9e\u9a8cE</code>\uff09\uff0c CHANfiG \u7684\u8303\u5f0f\u662f\uff1a</p> <p><code>\u4ee3\u7801 + \u547d\u4ee4\u884c\u53c2\u6570 (+ \u53ef\u9009\u7684CHANfiG\u914d\u7f6e\u6587\u4ef6 + \u5916\u90e8\u4f9d\u8d56 + \u786c\u4ef6 + \u5176\u4ed6\u4ee4\u4eba\u8ba8\u538c\u7684\u672f\u8bed ...) = \u53ef\u91cd\u590d\u7684\u5b9e\u9a8cE (+ \u53ef\u9009\u7684CHANfiG\u914d\u7f6e\u6587\u4ef6)</code></p>"},{"location":"zh/#_2","title":"\u7ec4\u4ef6","text":"<p>\u4e00\u4e2a\u914d\u7f6e\u6587\u4ef6\u53ef\u4ee5\u88ab\u770b\u4f5c\u4e00\u4e2a\u5d4c\u5957\u7684\u5b57\u5178\u7ed3\u6784\u3002</p> <p>\u4f46\u662f\uff0c\u9ed8\u8ba4\u7684 Python \u5b57\u5178\u5341\u5206\u96be\u4ee5\u64cd\u4f5c\u3002</p> <p>\u8bbf\u95ee\u5b57\u5178\u6210\u5458\u7684\u552f\u4e00\u65b9\u5f0f\u662f<code>dict['name']</code>\uff0c\u8fd9\u65e0\u7591\u662f\u6781\u5176\u7e41\u7410\u7684\u3002 \u66f4\u7cdf\u7cd5\u7684\uff0c\u5982\u679c\u8fd9\u4e2a\u5b57\u5178\u548c\u914d\u7f6e\u4e00\u6837\u662f\u4e00\u4e2a\u5d4c\u5957\u7ed3\u6784\uff0c\u8bbf\u95ee\u6210\u5458\u5c06\u4f1a\u53d8\u6210\u7c7b\u4f3c\u4e8e<code>dict['parent']['children']['name']</code>\u7684\u6837\u5b50\u3002</p> <p>\u591f\u4e86\u5c31\u662f\u591f\u4e86\uff0c\u662f\u65f6\u5019\u505a\u51fa\u6539\u53d8\u4e86\u3002</p> <p>\u6211\u4eec\u9700\u8981\u5c5e\u6027\u65b9\u5f0f\u7684\u8bbf\u95ee\uff0c\u5e76\u4e14\u6211\u4eec\u73b0\u5728\u5c31\u9700\u8981\u3002 <code>dict.name</code>\u548c<code>dict.parent.children.name</code>\u662f\u6240\u6709\u4f60\u9700\u8981\u7684\u3002</p> <p>\u5c3d\u7ba1\u6b64\u524d\u5df2\u7ecf\u6709\u5de5\u4f5c\u6765\u5b9e\u73b0\u7c7b\u4f3c\u7684\u5bf9\u5b57\u5178\u6210\u5458\u7684\u5c5e\u6027\u65b9\u5f0f\u8bbf\u95ee\u3002\u4f46\u662f\u4ed6\u4eec\u8981\u4e48\u4f7f\u7528\u4e00\u4e2a\u72ec\u7acb\u7684\u5b57\u5178\u6765\u5b58\u50a8\u5c5e\u6027\u65b9\u5f0f\u8bbf\u95ee\u7684\u4fe1\u606f\uff08EasyDict\uff09\uff0c\u800c\u8fd9\u53ef\u80fd\u5bfc\u81f4\u5c5e\u6027\u65b9\u5f0f\u8bbf\u95ee\u548c\u5b57\u5178\u65b9\u5f0f\u8bbf\u95ee\u7684\u4e0d\u4e00\u81f4\uff1b\u8981\u4e48\u91cd\u65b0\u4f7f\u7528\u65e2\u6709\u7684<code>__dict__</code>\u7136\u540e\u5bf9\u5b57\u5178\u65b9\u5f0f\u8bbf\u95ee\u8fdb\u884c\u91cd\u5b9a\u5411\uff08ml_collections\uff09\uff0c\u800c\u8fd9\u53ef\u80fd\u5bfc\u81f4\u5c5e\u6027\u548c\u5b57\u5178\u6210\u5458\u5b58\u5728\u51b2\u7a81\u3002</p> <p>\u4e3a\u4e86\u89e3\u51b3\u4e0a\u8ff0\u9650\u5236\uff0c\u6211\u4eec\u7ee7\u627f\u4e86 Python \u5185\u7f6e\u7684<code>dict</code>\u6765\u521b\u5efa<code>FlatDict</code>\u3001<code>DefaultDict</code>\u3001<code>NestedDict</code>\u3001<code>Config</code>\u548c<code>Registry</code>\u5bf9\u8c61\u3002 \u6211\u4eec\u540c\u65f6\u4ecb\u7ecd\u4e86<code>Variable</code>\u6765\u5728\u591a\u4e2a\u4f4d\u7f6e\u5171\u4eab\u503c\uff0c\u548c<code>ConfigParser</code>\u6765\u89e3\u6790\u547d\u4ee4\u884c\u53c2\u6570\u3002</p>"},{"location":"zh/#flatdict","title":"FlatDict","text":"<p><code>FlatDict</code>\u5728\u4e09\u4e2a\u65b9\u9762\u5bf9\u9ed8\u8ba4\u7684<code>dict</code>\u505a\u51fa\u6539\u8fdb\u3002</p>"},{"location":"zh/#_3","title":"\u5b57\u5178\u64cd\u4f5c","text":"<p><code>FlatDict</code>\u652f\u6301\u53d8\u91cf\u63d2\u503c\u3002 \u5c06\u4e00\u4e2a\u6210\u5458\u7684\u503c\u8bbe\u7f6e\u4e3a<code>${}</code>\u5305\u88f9\u7684\u53e6\u4e00\u4e2a\u6210\u5458\u540d\uff0c\u7136\u540e\u8c03\u7528<code>interpolate</code>\u65b9\u6cd5\u3002 \u8fd9\u4e2a\u6210\u5458\u7684\u503c\u5c06\u4f1a\u81ea\u52a8\u66ff\u6362\u4e3a\u53e6\u4e00\u4e2a\u6210\u5458\u7684\u503c\u3002</p> <p><code>FlatDict</code>\u5305\u62ec\u4e86\u4e00\u4e2a<code>merge</code>\u65b9\u6cd5\uff0c\u4ed6\u4f7f\u4f60\u80fd\u5c06\u4e00\u4e2a<code>Mapping</code>\u3001<code>Iterable</code>\u6216\u8005\u4e00\u4e2a\u8def\u5f84\u5408\u5e76\u8fdb\u5165\u4e00\u4e2a<code>FlatDict</code>\u5bf9\u8c61\u3002 \u4e0e<code>update</code>\u65b9\u6cd5\u4e0d\u540c\uff0c<code>merge</code>\u65b9\u6cd5\u662f\u8d4b\u503c\u800c\u4e0d\u662f\u66ff\u6362\uff0c\u8fd9\u4f7f\u5f97\u4ed6\u80fd\u66f4\u597d\u7684\u4e0e<code>DefaultDict</code>\u5bf9\u8c61\u914d\u5408\u4f7f\u7528\u3002</p> <p>\u6b64\u5916\uff0c<code>FlatDict</code>\u5f15\u5165\u4e86<code>difference</code>\u548c<code>intersect</code>\uff0c\u8fd9\u4e9b\u4f7f\u5176\u53ef\u4ee5\u975e\u5e38\u7b80\u5355\u7684\u5c06<code>FlatDict</code>\u548c\u5176\u4ed6<code>Mapping</code>\u3001<code>Iterable</code>\u6216\u8005\u4e00\u4e2a\u8def\u5f84\u8fdb\u884c\u5bf9\u6bd4\u3002</p>"},{"location":"zh/#_4","title":"\u673a\u5668\u5b66\u4e60\u64cd\u4f5c","text":"<p><code>FlatDict</code>\u652f\u6301\u4e0e Pytorch Tensor \u7c7b\u4f3c\u7684<code>to</code>\u65b9\u6cd5\u3002 \u4f60\u53ef\u4ee5\u5f88\u7b80\u5355\u7684\u901a\u8fc7\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u6240\u6709<code>FlatDict</code>\u7684\u6210\u5458\u503c\u8f6c\u6362\u4e3a\u67d0\u79cd\u7c7b\u578b\u6216\u8005\u8f6c\u79fb\u5230\u67d0\u4e2a\u8bbe\u5907\u4e0a\u3002</p> <p><code>FlatDict</code>\u540c\u65f6\u96c6\u6210\u4e86<code>cpu</code>\u3001<code>gpu</code> (<code>cuda</code>)\u3001<code>tpu</code> (<code>xla</code>)\u65b9\u6cd5\u6765\u63d0\u4f9b\u66f4\u4fbf\u6377\u7684\u8bbf\u95ee\u3002</p>"},{"location":"zh/#io","title":"IO \u64cd\u4f5c","text":"<p><code>FlatDict</code>\u652f\u6301<code>json</code>\u3001<code>jsons</code>\u3001<code>yaml</code>\u548c<code>yamls</code>\u65b9\u6cd5\u6765\u5c06<code>FlatDict</code>\u5bf9\u8c61\u5b58\u50a8\u5230\u6587\u4ef6\u6216\u8005\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\u3002 \u5b83\u8fd8\u63d0\u4f9b\u4e86<code>from_json</code>\u3001<code>from_jsons</code>\u3001<code>from_yaml</code>\u548c<code>from_yamls</code>\u6765\u4ece\u4e00\u4e2a\u5b57\u7b26\u4e32\u6216\u8005\u6587\u4ef6\u4e2d\u6784\u5efa<code>FlatDict</code>\u5bf9\u8c61\u3002</p> <p><code>FlatDict</code>\u4e5f\u5305\u62ec\u4e86<code>dump</code>\u548c<code>load</code>\u65b9\u6cd5\uff0c\u4ed6\u4eec\u53ef\u4ee5\u4ece\u6587\u4ef6\u6269\u5c55\u540d\u4e2d\u81ea\u52a8\u63a8\u65ad\u7c7b\u578b\u7136\u540e\u5c06<code>FlatDict</code>\u5bf9\u8c61\u5b58\u50a8\u5230\u6587\u4ef6\u4e2d/\u4ece\u6587\u4ef6\u4e2d\u52a0\u8f7d<code>FlatDict</code>\u5bf9\u8c61\u3002</p>"},{"location":"zh/#defaultdict","title":"DefaultDict","text":"<p>\u4e3a\u4e86\u6ee1\u8db3\u9ed8\u8ba4\u503c\u7684\u9700\u8981\uff0c\u6211\u4eec\u5305\u62ec\u4e86\u4e00\u4e2a<code>DefaultDict</code>\uff0c\u4ed6\u63a5\u53d7<code>default_factory</code>\u53c2\u6570\uff0c\u5e76\u548c<code>collections.defaultdict</code>\u4e00\u6837\u5de5\u4f5c\u3002</p>"},{"location":"zh/#nesteddict","title":"NestedDict","text":"<p>\u7531\u4e8e\u5927\u591a\u6570\u914d\u7f6e\u90fd\u662f\u4e00\u4e2a\u5d4c\u5957\u7684\u7ed3\u6784\uff0c\u6211\u4eec\u8fdb\u4e00\u6b65\u63d0\u51fa\u4e86<code>NestedDict</code>\u3002</p> <p>\u57fa\u4e8e<code>DefaultDict</code>\uff0c<code>NestedDict</code>\u63d0\u4f9b\u4e86<code>all_keys</code>\u3001<code>all_values</code>\u3001<code>all_items</code>\u65b9\u6cd5\u6765\u5141\u8bb8\u4e00\u6b21\u6027\u904d\u5386\u6574\u4e2a\u5d4c\u5957\u7ed3\u6784\u3002</p> <p><code>NestedDict</code>\u540c\u65f6\u63d0\u4f9b\u4e86\u4e00\u4e2a<code>apply</code>\u65b9\u6cd5\uff0c\u5b83\u53ef\u4ee5\u4f7f\u64cd\u7eb5\u5d4c\u5957\u7ed3\u6784\u66f4\u52a0\u5bb9\u6613\u3002</p>"},{"location":"zh/#config","title":"Config","text":"<p><code>Config</code>\u901a\u8fc7\u4e24\u4e2a\u65b9\u9762\u6765\u8fdb\u4e00\u6b65\u63d0\u5347\u529f\u80fd\u6027\uff1a \u652f\u6301<code>freeze</code>\u6765\u51bb\u7ed3\u548c<code>defrost</code>\u89e3\u51bb\u5b57\u5178\u548c \u52a0\u5165\u5185\u7f6e\u7684<code>ConfigParser</code>\u6765\u89e3\u6790\u547d\u4ee4\u884c\u8bed\u53e5\u3002</p> <p>\u6ce8\u610f<code>Config</code>\u9ed8\u8ba4\u8bbe\u7f6e<code>default_factory=Config()</code>\u6765\u63d0\u4f9b\u4fbf\u5229\u3002</p>"},{"location":"zh/#registry","title":"Registry","text":"<p><code>Registry</code>\u7ee7\u627f\u81ea<code>NestedDict</code>\uff0c\u5e76\u4e14\u63d0\u4f9b<code>register</code>\u3001<code>lookup</code>\u548c<code>build</code>\u6765\u5e2e\u52a9\u4f60\u6ce8\u518c\u6784\u9020\u51fd\u6570\u5e76\u4ece<code>Config</code>\u6765\u521b\u5efa\u5bf9\u8c61\u3002</p>"},{"location":"zh/#variable","title":"Variable","text":"<p>\u6709\u4e00\u4e2a\u503c\u5728\u591a\u4e2a\u5730\u65b9\u4ee5\u591a\u4e2a\u540d\u5b57\u51fa\u73b0\uff1f\u6211\u4eec\u7ed9\u4f60\u63d0\u4f9b\u63a9\u62a4\u3002</p> <p>\u53ea\u8981\u5c06\u503c\u4ee5<code>Variable</code>\u5305\u88c5\uff0c\u7136\u540e\u6bcf\u5904\u66f4\u6539\u90fd\u4f1a\u5728\u5904\u5904\u4f53\u73b0\u3002</p> <p><code>Variable</code>\u540c\u65f6\u652f\u6301<code>type</code>\u3001<code>choices</code>\u3001<code>validator</code>\u3001<code>required</code>\u6765\u786e\u4fdd\u503c\u7684\u6b63\u786e\u6027\u3002</p> <p>\u4e3a\u4e86\u66f4\u52a0\u7b80\u5355\uff0c<code>Variable</code>\u8fd8\u652f\u6301<code>help</code>\u6765\u5728\u4f7f\u7528<code>ConfigParser</code>\u65f6\u63d0\u4f9b\u63cf\u8ff0\u3002</p>"},{"location":"zh/#configparser","title":"ConfigParser","text":"<p><code>ConfigParser</code>\u5728<code>ArgumentParser</code>\u7684\u57fa\u7840\u4e4b\u4e0a\uff0c\u63d0\u4f9b\u4e86<code>parse</code>\u548c<code>parse_config</code>\u6765\u89e3\u6790\u547d\u4ee4\u884c\u53c2\u6570\u5e76\u521b\u5efa/\u66f4\u65b0<code>Config</code>\u3002</p>"},{"location":"zh/#_5","title":"\u4f7f\u7528","text":"<p>CHANfiG \u6709\u7740\u5f3a\u5927\u7684\u524d\u5411\u517c\u5bb9\u80fd\u529b\uff0c\u80fd\u591f\u826f\u597d\u7684\u517c\u5bb9\u4ee5\u5f80\u57fa\u4e8e yaml \u548c json \u7684\u914d\u7f6e\u6587\u4ef6\u3002</p> <p>\u5982\u679c\u4f60\u6b64\u524d\u4f7f\u7528 yacs\uff0c\u53ea\u9700\u7b80\u5355\u5c06<code>CfgNode</code>\u66ff\u6362\u4e3a<code>Config</code>\u4fbf\u53ef\u4ee5\u4eab\u53d7\u6240\u6709 CHANfiG \u6240\u63d0\u4f9b\u7684\u4fbf\u5229\u3002</p> <p>\u66f4\u8fdb\u4e00\u6b65\u7684\uff0c\u5982\u679c\u4f60\u53d1\u73b0<code>Config</code>\u4e2d\u7684\u540d\u5b57\u5bf9\u4e8e\u547d\u4ee4\u884c\u6765\u8bf4\u8fc7\u957f\uff0c\u4f60\u53ef\u4ee5\u7b80\u5355\u7684\u8c03\u7528<code>self.add_argument</code>\u5e76\u8bbe\u7f6e\u6070\u5f53\u7684<code>dest</code>\u6765\u5728\u547d\u4ee4\u884c\u4e2d\u4f7f\u7528\u66f4\u77ed\u7684\u540d\u5b57\uff0c\u6b63\u5982<code>argparse</code>\u6240\u505a\u7684\u90a3\u6837\u3002</p> Python<pre><code>from chanfig import Config, Variable\nclass Model:\ndef __init__(self, encoder, dropout=0.1, activation='ReLU'):\nself.encoder = Encoder(**encoder)\nself.dropout = Dropout(dropout)\nself.activation = getattr(Activation, activation)\ndef main(config):\nmodel = Model(**config.model)\noptimizer = Optimizer(**config.optimizer)\nscheduler = Scheduler(**config.scheduler)\ndataset = Dataset(**config.dataset)\ndataloader = Dataloader(**config.dataloader)\nclass TestConfig(Config):\ndef __init__(self):\nsuper().__init__()\ndropout = Variable(0.1)\nself.name = \"CHANfiG\"\nself.seed = 1013\nself.data.batch_size = 64\nself.model.encoder.num_layers = 6\nself.model.decoder.num_layers = 6\nself.model.dropout = dropout\nself.model.encoder.dropout = dropout\nself.model.decoder.dropout = dropout\nself.activation = \"GELU\"\nself.optim.lr = 1e-3\nself.add_argument(\"--batch_size\", dest=\"data.batch_size\")\nself.add_argument(\"--lr\", dest=\"optim.lr\")\ndef post(self):\nself.id = f\"{self.name}_{self.seed}\"\nif __name__ == '__main__':\n# config = Config.load('config.yaml')  # \u5982\u679c\u4f60\u60f3\u8bfb\u53d6\u4e00\u4e2a yaml\n# config = Config.load('config.json')  # \u5982\u679c\u4f60\u60f3\u8bfb\u53d6\u4e00\u4e2a json\n# existing_configs = {'data.batch_size': 64, 'model.encoder.num_layers': 8}\n# config = Config(**existing_configs)  # \u5982\u679c\u4f60\u6709\u4e9bconfig\u9700\u8981\u8bfb\u53d6\nconfig = TestConfig()\nconfig = config.parse()\n# config.merge('dataset.yaml')  # \u5982\u679c\u4f60\u60f3\u5408\u5e76\u4e00\u4e2a yaml\n# config.merge('dataset.json')  # \u5982\u679c\u4f60\u60f3\u5408\u5e76\u4e00\u4e2a json\n# \u6ce8\u610f\u88ab\u5408\u5e76\u7684\u503c\u5177\u6709\u66f4\u9ad8\u7684\u4f18\u5148\u7ea7\nconfig.model.decoder.num_layers = 8\nconfig.freeze()\nprint(config)\n# main(config)\n# config.yaml('config.yaml')  # \u5982\u679c\u4f60\u60f3\u4fdd\u5b58\u4e00\u4e2a yaml\n# config.json('config.json')  # \u5982\u679c\u4f60\u60f3\u4fdd\u5b58\u4e00\u4e2a json\n</code></pre> <p>\u6240\u6709\u4f60\u9700\u8981\u505a\u7684\u4ec5\u4ec5\u662f\u8fd0\u884c\u4e00\u884c\uff1a</p> Bash<pre><code>python main.py --model.encoder.num_layers 8 --model.dropout=0.2 --lr 5e-3\n</code></pre> <p>\u5f53\u7136\uff0c\u4f60\u4e5f\u53ef\u4ee5\u8bfb\u53d6\u4e00\u4e2a\u9ed8\u8ba4\u914d\u7f6e\u6587\u4ef6\u7136\u540e\u5728\u4ed6\u57fa\u7840\u4e0a\u4fee\u6539\uff1a</p> <p>\u6ce8\u610f\uff0c\u4f60\u5fc5\u987b\u6307\u5b9a<code>config.parse(default_config='config')</code>\u6765\u6b63\u786e\u8bfb\u53d6\u9ed8\u8ba4\u914d\u7f6e\u6587\u4ef6\u3002</p> Bash<pre><code>python main.py --config meow.yaml --model.encoder.num_layers 8 --model.dropout=0.2 --lr 5e-3\n</code></pre> <p>\u5982\u679c\u4f60\u4fdd\u5b58\u4e86\u914d\u7f6e\u6587\u4ef6\uff0c\u90a3\u4ed6\u5e94\u8be5\u770b\u8d77\u6765\u50cf\u8fd9\u6837\uff1a</p> YAML<pre><code>activation: GELU\ndata:\nbatch_size: 64\nid: CHANfiG_1013\nmodel:\ndecoder:\ndropout: 0.1\nnum_layers: 6\ndropout: 0.1\nencoder:\ndropout: 0.1\nnum_layers: 6\nname: CHANfiG\noptim:\nlr: 0.005\nseed: 1013\n</code></pre> JSON<pre><code>{\n\"name\": \"CHANfiG\",\n\"seed\": 1013,\n\"data\": {\n\"batch_size\": 64\n},\n\"model\": {\n\"encoder\": {\n\"num_layers\": 6,\n\"dropout\": 0.1\n},\n\"decoder\": {\n\"num_layers\": 6,\n\"dropout\": 0.1\n},\n\"dropout\": 0.1\n},\n\"activation\": \"GELU\",\n\"optim\": {\n\"lr\": 0.005\n},\n\"id\": \"CHANfiG_1013\"\n}\n</code></pre> <p>\u5728\u65b9\u6cd5\u4e2d\u5b9a\u4e49\u9ed8\u8ba4\u53c2\u6570\uff0c\u5728\u547d\u4ee4\u884c\u4e2d\u4fee\u6539\uff0c\u7136\u540e\u5c06\u5269\u4e0b\u7684\u4ea4\u7ed9 CHANfiG\u3002</p>"},{"location":"zh/#_6","title":"\u5b89\u88c5","text":"<p>\u5b89\u88c5 pypi \u4e0a\u6700\u8fd1\u7684\u7a33\u5b9a\u7248\u672c\uff1a</p> Bash<pre><code>pip install chanfig\n</code></pre> <p>\u4ece\u6e90\u7801\u5b89\u88c5\u6700\u65b0\u7684\u7248\u672c\uff1a</p> Bash<pre><code>pip install git+https://github.com/ZhiyuanChen/CHANfiG\n</code></pre> <p>\u4ed6\u672c\u8be5\u5982\u6b64\u5de5\u4f5c\u3002</p>"},{"location":"zh/#_7","title":"\u6388\u6743","text":"<p>CHANfiG \u4f9d\u636e\u4e0b\u5217\u8bb8\u53ef\u8bc1\u8fdb\u884c\u591a\u91cd\u6388\u6743\uff1a</p> <ul> <li>Unlicense</li> <li>GPL 2.0 (or any later version)</li> <li>MIT</li> <li>Apache 2.0</li> <li>BSD 2-Clause</li> <li>BSD 3-Clause</li> <li>BSD 4-Clause</li> </ul> <p>\u5982\u679c\u4f60\u4f7f\u7528\u672c\u5de5\u4f5c\uff0c\u4f60\u53ef\u4ee5\u4ece\u4e2d\u4efb\u9009\uff08\u4e00\u4e2a\u6216\u8005\u591a\u4e2a\uff09\u8bb8\u53ef\u8bc1\u3002</p> <p><code>SPDX-License-Identifier: Unlicense OR GPL-2.0-or-later OR MIT OR Apache-2.0 OR BSD-2-Clause OR BSD-3-Clause OR BSD-4-Clause</code></p>"}]}